var documenterSearchIndex = {"docs":
[{"location":"indepth_installation/#In-Depth-Installation-Instructions-for-New-Users,-Developer-Install,-and-Julia-1.10-and-Older","page":"Installation","title":"In-Depth Installation Instructions for New Users, Developer Install, and Julia 1.10 and Older","text":"","category":"section"},{"location":"indepth_installation/","page":"Installation","title":"Installation","text":"The OWENS software has been developed and designed to highly flexible and to operate in the paradigm similar to modern open source software, leveraging tools such as the terminal, git, public software repositories, and automated package management both for the operating system and the programming language. Before attempting these instructions, if you are not familiar with these types of tools, please consider becoming familiar with them prior to proceeding.  Here are some of the first google hits for guides:","category":"page"},{"location":"indepth_installation/","page":"Installation","title":"Installation","text":"https://www.redhat.com/sysadmin/beginners-guide-vim\nhttps://www.freecodecamp.org/news/the-beginners-guide-to-git-github.com/\nhttps://www.howtogeek.com/63997/how-to-install-programs-in-ubuntu-in-the-command-line/","category":"page"},{"location":"indepth_installation/","page":"Installation","title":"Installation","text":"The use of precompiled binaries for the optional OpenFAST fortran libraries significantly simplifies use and installation.  However, if you need to make modifications to the OpenFAST coupling, it requires an entirely different level of software development skills, and would require the user to become proficient at developing and compiling the standalone OpenFAST code first.","category":"page"},{"location":"indepth_installation/#Main-New-Programs'-Installation-(Julia,-Paraview,-Optionally-VSCode)","page":"Installation","title":"Main New Programs' Installation (Julia, Paraview, Optionally VSCode)","text":"","category":"section"},{"location":"indepth_installation/","page":"Installation","title":"Installation","text":"Install julia, paraview, and visual studio by downloading/installing the OS specific versions for each, either manually (links below for your convenience) or through your favorite package manager:","category":"page"},{"location":"indepth_installation/","page":"Installation","title":"Installation","text":"https://julialang.org/downloads/\nhttps://www.paraview.org/download/\nhttps://visualstudio.microsoft.com/downloads/","category":"page"},{"location":"indepth_installation/","page":"Installation","title":"Installation","text":"Be sure julia is on your path (should happen automatically as part of the installation process)","category":"page"},{"location":"indepth_installation/","page":"Installation","title":"Installation","text":"It is recommended, but not required to set up VS code as also described below.","category":"page"},{"location":"indepth_installation/","page":"Installation","title":"Installation","text":"Windows notes: ","category":"page"},{"location":"indepth_installation/","page":"Installation","title":"Installation","text":"details are key, hash mismatch may mean that you are behind a proxy and the proxy isn't setup correctly.  For visual studio, the default installation and recommendations should work.  If importing the provided vs-code profile, the quick keys may need to be remapped to control from cmd.  \nSet up the environment variables below and be sure Julia is also on the path (https://www.wikihow.com/Create-an-Environment-Variable-in-Windows-10)","category":"page"},{"location":"indepth_installation/#Environment-Variables","page":"Installation","title":"Environment Variables","text":"","category":"section"},{"location":"indepth_installation/","page":"Installation","title":"Installation","text":"If you are using a proxy, such as those at the national labs be sure that the proxy variables are also declared/exported in your .bash_profile or .bashrc or the equivalent list of environment variables in Windows.  Additionally, you may need to tell your system where the SSL cert file is, and CA bundle. For those at Sandia, more information can be found at: https://wiki.sandia.gov/pages/viewpage.action?pageId=227381234#SandiaProxyConfiguration,Troubleshooting&HTTPS/SSLinterception-SSLCertificate.1.  ","category":"page"},{"location":"indepth_installation/","page":"Installation","title":"Installation","text":"You cay need to then tell julia where the SSLCAROOTS are.  Then in some instances, the built in julia git system has trouble with proxies, so you can tell it to use the command line interface git.","category":"page"},{"location":"indepth_installation/","page":"Installation","title":"Installation","text":"Here is an example section of a mac .zshrc script with dummy variables filled in assuming the machine is behind a proxy. If you aren't behind a proxy you should be able to just ignore all of the first block, and possibly the SSL CA, and CLI_GIT variables depending on your operating system and if you choose to use SSH keys.","category":"page"},{"location":"indepth_installation/","page":"Installation","title":"Installation","text":"export HTTP_PROXY=\"http://user:nopass@proxy.yourproxy.com:80/\"\nexport HTTPS_PROXY=\"http://user:nopass@proxy.yourproxy.com:80/\"\nexport no_proxy=*.local,169.254/16,*.yourproxy.com,*.srn.yourproxy.com,localhost,127.0.0.1,::1\nexport NO_PROXY=*.local,169.254/16,*.yourproxy.com,*.srn.yourproxy.com,localhost,127.0.0.1,::1\ngit config --global http.proxy http://user:nopass@proxy.yourproxy.com:80\ngit config --global https.proxy http://user:nopass@proxy.yourproxy.com:80\n\nexport SSL_CERT_FILE=/Users/kevmoor/.ssh/your_root_ca.pem\nexport REQUESTS_CA_BUNDLE=${SSL_CERT_FILE}\n\nexport JULIA_SSL_CA_ROOTS_PATH=\"\"\nexport JULIA_PKG_USE_CLI_GIT=true\nexport JULIA_NUM_THREADS=1\nexport OMP_NUM_THREADS=10","category":"page"},{"location":"indepth_installation/#Test-That-Julia-Runs","page":"Installation","title":"Test That Julia Runs","text":"","category":"section"},{"location":"indepth_installation/","page":"Installation","title":"Installation","text":"the following should get you in and out of the julia interactive repl, open up a terminal and type","category":"page"},{"location":"indepth_installation/","page":"Installation","title":"Installation","text":"julia \nexit()","category":"page"},{"location":"indepth_installation/#Brief-Julia-Primer","page":"Installation","title":"Brief Julia Primer","text":"","category":"section"},{"location":"indepth_installation/","page":"Installation","title":"Installation","text":"Now open the julia interactive repl and run the following blocks, a multi-line block should be entered as one.","category":"page"},{"location":"indepth_installation/","page":"Installation","title":"Installation","text":"julia","category":"page"},{"location":"indepth_installation/","page":"Installation","title":"Installation","text":"\nprintln(\"This is intended just to get you rolling, comprehensive documentation can be found at https://docs.julialang.org/en/v1/\")\nprintln(\"More detail on major differences between codes can be found at https://docs.julialang.org/en/v1/manual/noteworthy-differences/\")\n\n###############################################################\n###############################################################\n###############################################################\n\nprintln(\"#####################\")\nprintln(\"Basic Data Handling\")\nprintln(\"#####################\")\n# Create a multidimensional array\nnewMatrix = zeros(2,3)\n# Mutate the contents\nnewMatrix[1,2] = 1.0\n\n#Create New Scalar\nnewScalar = 5.0\n\nprintln(\"Print the first matrix\")\n# Print the contents and observe the mutation\nfor irow = 1:length(newMatrix[:,1])\n    println(newMatrix[irow,:])\nend\n\n# Copy the newMatrix and scalar\nnewMatrix2 = newMatrix\nnewScalar2 = newScalar\n# Mutate the second matrix and scalar\nnewMatrix[1,2] = 2.0\nnewScalar2 = 2.0\n\n#Make a printing function inline\nfunction printme(matrix, scalar)\n    for irow = 1:length(matrix[:,1])\n        println(matrix[irow,:])\n    end\n    println(\"Scalar: $scalar\")\nend\n\nprintln(\"Printing the second matrix and scalar\")\nprintme(newMatrix2,newScalar2)\nprintln(\"Printing the first matrix again\")\nprintme(newMatrix,newScalar)\nif newMatrix[1,2] == newMatrix2[1,2]\n    println(\"B=A references the arrays\")\n    println(\"B=copy(A) breaks the reference and does a true copy\")\n    println(\"B=deepcopy(A) is needed if it is a multi-level type, like a struct or dictionary\")\n    println(\"However, scalars are not linked.  This is because a scalar is directly looking at a memory element, while arrays are pointing to the memory elements\")\nend\n\n###############################################################\n###############################################################\n###############################################################\n\nprintln(\"\\n#####################\")\nprintln(\"Scope of Functions\")\nprintln(\"#####################\")\n\n\nfunction coolfunction(input1,input2; mykeyname=\"default\",mykeyname2=5.0)\n    if mykeyname==\"default\"\n        return input1.+input2[1,1,1], 1.0\n    else\n        input2[1,1,1] = 1.0 # Since arrays are always passed by reference, we can mutate it here and it will be mutated above\n        return input1.+mykeyname2, 0.0\n    end\nend\n\noutputs = coolfunction(ones(3).*5,zeros(4,5,2)) \nprintln(\"use the defaults for the optional args and dump the output into a tuple\")\nprintln(\"First output $(outputs[1]), Second output $(outputs[2])\")\n\nprintln(\"supply the optional args and dump the output into newly allocated items\")\nmyinput = zeros(4,5,2)\nmykeyname = \"notdefault\"\ntestinput = 5.0\noutputs1, output2 = coolfunction(ones(3).*5,myinput;mykeyname,mykeyname2=testinput)\nprintln(\"First output $(outputs1), Second output $(output2)\")\n\nprintln(\"now show that myinput was mutated within the function since it was passed by reference\")\nprintln(myinput)\n\n\n###############################################################\n###############################################################\n###############################################################\n\nprintln(\"\\n#####################\")\nprintln(\"Types\")\nprintln(\"#####################\")\n\nfirst = 1.0\nprintln(typeof(first))\n\nsecond = 2\nprintln(typeof(second))\n\n###############################################################\n###############################################################\n###############################################################\n\nprintln(\"\\n#####################\")\nprintln(\"Structs\")\nprintln(\"#####################\")\n\nmutable struct mystruct\n    coolterm1\n    othercoolterm\nend\n\nnewStruct = mystruct(1.0,2.0)\n\nprintln(newStruct.coolterm1)\nprintln(newStruct.othercoolterm)\n\n###############################################################\n###############################################################\n###############################################################\n\nprintln(\"\\n#####################\")\nprintln(\"Package Manager with Standard Packages\")\nprintln(\"#####################\")\n\nusing Pkg\nPkg.add(\"PyPlot\") #Note, this will take a while (maybe 10 min depending on your connection) since it is pulling conda and installing it behind the ~/.julia folder \n# if you want to use your already installed python, you can instead run\n# ENV[\"PYTHON\"] = \"path to your desired python install\"\n# Pkg.add(\"PyCall\")\n# Pkg.add(\"PyPlot\")\n\nPkg.add(\"DelimitedFiles\")\n\nimport PyPlot\nimport DelimitedFiles\n\nx = [1; 2; 3; 4];\n\ny = [5; 6; 7; 8];\n\nopen(\"delim_file.txt\", \"w\") do io\n        DelimitedFiles.writedlm(io, [x y])\n       end\n\ndata = DelimitedFiles.readdlm(\"delim_file.txt\", '\\t', Int, '\\n')\n\nPyPlot.figure()\nPyPlot.plot(data[:,1],data[:,2],label=\"data\")\nPyPlot.xlabel(\"x\")\nPyPlot.ylabel(\"y\")\nPyPlot.legend()\n\nthisFilesPath = splitdir(@__FILE__)[1]\n\nPyPlot.savefig(\"$(thisFilesPath)/saveme.pdf\",transparent = true)\n\nrun(`rm $(thisFilesPath)/saveme.pdf`) #system run\nrm(\"delim_file.txt\") # julia's function that does the same thing\n\n###############################################################\n###############################################################\n###############################################################","category":"page"},{"location":"indepth_installation/#OWENS-Installation-for-Julia-1.11","page":"Installation","title":"OWENS Installation for Julia 1.11+","text":"","category":"section"},{"location":"indepth_installation/","page":"Installation","title":"Installation","text":"using Pkg\nPkg.add(PackageSpec(url=\"https://github.com/sandialabs/OWENS.jl.git\"))","category":"page"},{"location":"indepth_installation/","page":"Installation","title":"Installation","text":"Note that there are many packages used in the examples.  While they are installed within the OWENS.jl environment, if you want to additionally install them in your 1.11+ environment where you will likely be running from:","category":"page"},{"location":"indepth_installation/","page":"Installation","title":"Installation","text":"using Pkg\nPkg.add([\"Statistics\",\"Dierckx\",\"QuadGK\",\"FLOWMath\",\"HDF5\",\"ImplicitAD\",\"GXBeam\",\"DelimitedFiles\",\"FFTW\",\"YAML\",\"OrderedCollections\"])","category":"page"},{"location":"indepth_installation/","page":"Installation","title":"Installation","text":"If you want to show any of the plots in the examples, they currently use the PyPlot interface, which means that julia has to install its own conda in the back end, which can take some time.  Alternatively, you can point to your own python if desired.","category":"page"},{"location":"indepth_installation/","page":"Installation","title":"Installation","text":"using Pkg\n# Install PyPlot if not already installed\nPkg.add(\"PyPlot\") #Note, this will take a while (maybe 10 min depending on your connection) since it is pulling conda and installing it behind the ~/.julia folder \n# if you want to use your already installed python, you can instead run\n# ENV[\"PYTHON\"] = \"path to your desired python install\"\n# Pkg.add(\"PyCall\")\n# Pkg.add(\"PyPlot\")","category":"page"},{"location":"indepth_installation/#OWENS-Installation-for-Julia-1.10-and-older-(down-to-1.6)","page":"Installation","title":"OWENS Installation for Julia 1.10 and older (down to 1.6)","text":"","category":"section"},{"location":"indepth_installation/","page":"Installation","title":"Installation","text":"These steps require a secure download, such as through the SSH keys detailed above, to avoid man-in-the-middle attacks. ","category":"page"},{"location":"indepth_installation/","page":"Installation","title":"Installation","text":"\nusing Pkg\n\nprintln(\"\\n#####################\")\nprintln(\"Install OWENS\")\nprintln(\"#####################\")\n\nPkg.add([\"Statistics\",\"Dierckx\",\"QuadGK\",\"FLOWMath\",\"HDF5\",\"ImplicitAD\",\"GXBeam\",\"DelimitedFiles\",\"FFTW\",\"YAML\",\"OrderedCollections\"])\n\nPkg.add([\nPackageSpec(url=\"https://github.com/byuflowlab/Composites.jl.git\"),\nPackageSpec(url=\"https://github.com/sandialabs/OWENSOpenFAST_jll.jl.git\"),\nPackageSpec(url=\"https://github.com/sandialabs/OWENSOpenFASTWrappers.jl.git\"),\nPackageSpec(url=\"https://github.com/sandialabs/OWENSAero.jl.git\"),\nPackageSpec(url=\"https://github.com/sandialabs/OWENSFEA.jl.git\"),\nPackageSpec(url=\"https://github.com/sandialabs/OWENS.jl.git\"),\n])","category":"page"},{"location":"indepth_installation/#Testing-Your-Build-of-OWENS","page":"Installation","title":"Testing Your Build of OWENS","text":"","category":"section"},{"location":"indepth_installation/","page":"Installation","title":"Installation","text":"clone the owens repository which contains example scripts that will setup and run example turbines from end to end","category":"page"},{"location":"indepth_installation/","page":"Installation","title":"Installation","text":"git clone git@github.com:sandialabs/OWENS.jl\ncd OWENS.jl/examples/literate/\njulia B_detailedInputs.jl","category":"page"},{"location":"indepth_installation/","page":"Installation","title":"Installation","text":"You can visualize the output vtk/vtu/pvd paraview files with paraview, install paraview via     apt-get -y install paraview # or on mac, brew install paraview","category":"page"},{"location":"indepth_installation/","page":"Installation","title":"Installation","text":"You can also run julia more interactively and maintain variables in scope for inspections etc if you don't have an IDE set up (but be careful of assuming a variable was cleared when it wasn't!) by starting the repl and essentially copying and pasing the run script via","category":"page"},{"location":"indepth_installation/","page":"Installation","title":"Installation","text":"julia","category":"page"},{"location":"indepth_installation/","page":"Installation","title":"Installation","text":"    include(\"path/to/file.jl\")","category":"page"},{"location":"indepth_installation/#Visual-Studio-Code-IDE","page":"Installation","title":"Visual Studio Code IDE","text":"","category":"section"},{"location":"indepth_installation/","page":"Installation","title":"Installation","text":"You can install VScode and get a debugger etc.  In VScode, there is a setting file which sets up VS code for julia and sets some quick keys that can be changed if desired (OWENS.jl/docs/OWENS.code-profile). ","category":"page"},{"location":"indepth_installation/","page":"Installation","title":"Installation","text":"With the sample profile loaded into VSCode, If you want to clear out all the variables and restart do ","category":"page"},{"location":"indepth_installation/","page":"Installation","title":"Installation","text":"cmd-j cmd-k,","category":"page"},{"location":"indepth_installation/","page":"Installation","title":"Installation","text":"if you want to clear out the console ","category":"page"},{"location":"indepth_installation/","page":"Installation","title":"Installation","text":"cmd-j cmd-c","category":"page"},{"location":"indepth_installation/","page":"Installation","title":"Installation","text":"open the workspace ","category":"page"},{"location":"indepth_installation/","page":"Installation","title":"Installation","text":"cmd-j cmd-w","category":"page"},{"location":"indepth_installation/","page":"Installation","title":"Installation","text":"run highlighted code ","category":"page"},{"location":"indepth_installation/","page":"Installation","title":"Installation","text":"shift-enter","category":"page"},{"location":"indepth_installation/","page":"Installation","title":"Installation","text":"run the currently selected file","category":"page"},{"location":"indepth_installation/","page":"Installation","title":"Installation","text":"cmd-shift-enter","category":"page"},{"location":"indepth_installation/","page":"Installation","title":"Installation","text":"You can also use the gui buttons.","category":"page"},{"location":"indepth_installation/#VSCode-Julia-Debugger","page":"Installation","title":"VSCode Julia Debugger","text":"","category":"section"},{"location":"indepth_installation/","page":"Installation","title":"Installation","text":"It is a lot like matlab, but you are working with a compiled code, so in the debugger portion of the vscode gui, you need to check which code is compiled and which is interpereted, and turn off the compilation for the packages you are trying to debug.  The debugger will not step through compiled code. Also, some lines of code have many instructions, particularly function calls with conversions on the inputs, etc, so if you are trying to use the step in gui button, you may need to click it multiple times.","category":"page"},{"location":"indepth_installation/","page":"Installation","title":"Installation","text":"If you are working on a module and want it to reload with your most recent local changes without committing to master, pushing, and telling julia to update the package which is pointing to the git repo:","category":"page"},{"location":"indepth_installation/#Install-custom-repositories-you-want-to-develop","page":"Installation","title":"Install custom repositories you want to develop","text":"","category":"section"},{"location":"indepth_installation/","page":"Installation","title":"Installation","text":"start Julia from the cloned directory and use the command:","category":"page"},{"location":"indepth_installation/","page":"Installation","title":"Installation","text":"] dev .","category":"page"},{"location":"indepth_installation/","page":"Installation","title":"Installation","text":"This type of installation will cause the module to reload each time Julia starts without needing to tell Julia to update. NOTE: even though julia 1.11 can to a regular install with a single line and resolve the custom dependencies, for the dev install it doesn't appear to automatically do so; so you may need to be careful about the installation order of dev packages to ensure you have downstream dependencies satisfied.","category":"page"},{"location":"indepth_installation/","page":"Installation","title":"Installation","text":"Alternatively, you can effectively copy and paste the module in, like so:","category":"page"},{"location":"indepth_installation/","page":"Installation","title":"Installation","text":"include(\"path/to/module.jl/source/module.jl\")","category":"page"},{"location":"indepth_installation/","page":"Installation","title":"Installation","text":"then you don't even have to restart julia when you make changes, but be careful to only do this for a limited number of modules, and if you are changing constants, like c library interfaces, or the libraries themselves, then you need to restart julia to get it to pick up the most recent changes.","category":"page"},{"location":"indepth_installation/","page":"Installation","title":"Installation","text":"You can also install a specific branch of a remote repository package without having to clone the repo and checkout the branch:","category":"page"},{"location":"indepth_installation/","page":"Installation","title":"Installation","text":"using Pkg\nPkg.add(url = \"git@github.com:sandialabs/OWENS.jl.git\", rev = \"dev\")","category":"page"},{"location":"indepth_installation/#Custom-Install-of-Optional-OpenFAST-Dependices","page":"Installation","title":"Custom Install of Optional OpenFAST Dependices","text":"","category":"section"},{"location":"indepth_installation/","page":"Installation","title":"Installation","text":"You'll need your system to be capable of compiling OpenFAST (https://openfast.readthedocs.io/en/main/), either with cmake, and the sample instructions below, or the OpenFAST visual studio code recipes, more of which can be found in the OpenFAST documentation.     mkdir coderepos     cd coderepos     # Install openfast coupled libraries !NOTE!: if you change the location of the compiled libraries, you may need to update the rpath variable, or recompile.     git clone –depth 1 git@github.com:andrew-platt/openfast.git     # if this errors, you can clone git@github.com:OpenFAST/openfast.git it just doesn't have the latest updates from Andy, but the interface should be the same and should run.     cd openfast     git remote set-branches origin '*'     git fetch –depth 1 origin f/ADIcbindingmultiRotor     git checkout f/ADIcbindingmultiRotor     mkdir build     cd build     # can also add -DOPENMP=ON if desired for acceleration of OLAF     # you can rebuild later by removing the build folder and following these instructions again.     cmake -DBUILDSHAREDLIBS=ON ..     make ifwcbinding     make moordyncbinding     make hydrodyncbinding     make aerodyninflowcbinding     make aerodyndriver     make turbsim     cd ../../","category":"page"},{"location":"indepth_installation/","page":"Installation","title":"Installation","text":"There is also a OWENSOpenFASTWrappers.jl/deps/legacy_build.jl script which can be useful.","category":"page"},{"location":"indepth_installation/","page":"Installation","title":"Installation","text":"Then, within OWENS, you would provide the path to the resulting binaries you'd like to use. e.g. ","category":"page"},{"location":"indepth_installation/","page":"Installation","title":"Installation","text":"adi_lib=\"buildpath/openfast/build/modules/AeroDyn/libaerodyn_inflow_c_binding.so\"","category":"page"},{"location":"indepth_installation/","page":"Installation","title":"Installation","text":"instead of the default, which points to the precompiled OWENSOpenFAST_jll.jl binaries.","category":"page"},{"location":"indepth_installation/#Set-up-SSH-Keys","page":"Installation","title":"Set up SSH Keys","text":"","category":"section"},{"location":"indepth_installation/","page":"Installation","title":"Installation","text":"If you choose to install packages using ssh instead of https, (or if you make a private repository), you'll need to set up SSH keys and replace all of the https://github.com with git@github.com in the installation steps. Note that for installation behind the Sandia network, you will need to be on the network and follow additional instructions at https://wiki.sandia.gov/pages/viewpage.action?pageId=227381234#SandiaProxyConfiguration,Troubleshooting&HTTPS/SSLinterception-SSLCertificate.1. For windows, note that you may have to use id_ecdsa keys.","category":"page"},{"location":"indepth_installation/","page":"Installation","title":"Installation","text":"# Go to your gihub account settings\n# left side, SSH and GPG keys\n# new ssh key\n# name: owensrepos # or whatever you'd like\n# back in the terminal, use the following, or the equivalent for Windows found in the github docs (https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent)\nssh-keygen -t rsa -m PEM -C username@youremail.gov\n# enter, enter, enter (i.e. use defaults with !NO PASSWORD! since it is not necessary)\ncd ~\nls -a\ncd .ssh\nvim id_rsa.pub\n#copy the contents to github.com (User icon > Settings > SSH and GPG > New SSH Key) and paste them back in your browser to the ssh key box and create the key\n# esc : q enter # to get out of vim\ncd ~","category":"page"},{"location":"indepth_installation/","page":"Installation","title":"Installation","text":"Additionally, if you find that your ssh is erroring when you try to install packages, try editing your ~/.ssh/config and add:","category":"page"},{"location":"indepth_installation/","page":"Installation","title":"Installation","text":"Host *\nPubkeyAcceptedAlgorithms +ssh-rsa\nPubkeyAcceptedAlgorithms +ssh-ed25519","category":"page"},{"location":"legacyUserGuide/#TODO:-condense-and-update-this-with-the-latest-updates","page":"Legacy User Guide","title":"TODO: condense and update this with the latest updates","text":"","category":"section"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"subtitle: |   Version 1.0","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"User Guide","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"*Brian C. Owens\n  *","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Wind Energy Technologies\n  Sandia National Laboratories","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"*November 11, 2013\n  * title: |   Offshore Wind Energy Simulation","category":"page"},{"location":"legacyUserGuide/#Analysis-Tool:-OWENS","page":"Legacy User Guide","title":"Analysis Tool: OWENS","text":"","category":"section"},{"location":"legacyUserGuide/#Contents-{#contents-.TOC-Heading}","page":"Legacy User Guide","title":"Contents {#contents .TOC-Heading}","text":"","category":"section"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Introduction 1","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Overview of OWENS Model Formulation 1","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Basic Formulation Concepts 1","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Equations of Motion 2","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Overview of OWENS Analysis Framework 4","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"OWENS Installation 7","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Platform dynamics software interface 7","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"OWENS Command Line Execution 8","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Static Analysis Execution 8","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Modal Analysis Execution 8","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Creating Campbell Diagrams of a VAWT Configuration 9","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Transient Analysis Execution 11","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Specified rotor speed profile 11","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Forced start-up mode using generator 11","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Self-starting turbine mode 12","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Transient Analysis Execution Using Reduced Order Model 12","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"OWENS Input Files 13","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"OWENS Main Input File (.owens) 14","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Mesh File (.mesh) 15","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Element Property File (.el) 15","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Element Orientation File (.ort) 16","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Joint File (.jnt) 16","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Concentrated Nodal Terms File 16","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Boundary Conditions File (.bc) 17","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Platform Simulation File (.plat) 17","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Initial Conditions File 18","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Blade Data File (.bld) 18","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Aerodynamic Loads File 18","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Drivetrain Properties File 18","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Generator Properties File 19","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"OWENS Output Files 20","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Static Analysis Output 20","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Modal Analysis Output 20","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Transient Analysis Output 21","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"References 21","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Appendix A: Mapping from local nodal DOF numbering to global DOF numbering 22","category":"page"},{"location":"legacyUserGuide/#Introduction","page":"Legacy User Guide","title":"Introduction","text":"","category":"section"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"This user guide presents instructions for using the Offshore Wind ENergy Simulation (OWENS) analysis tool. This structural dynamics finite element analysis tool is intended to be used for the analysis of vertical-axis wind turbine (VAWT) on a floating platform, and is used in conjunction with the VAWTGen mesh generator described in a separate user manual[1]. An overview of the OWENS analysis tool is presented. The execution, analysis modes, input files, and resulting output files for OWENS are discussed in detail. Visualization options for modal and transient analysis are also presented. Version 1.0 of OWENS presents a structural dynamics tool for modal and transient analysis of an arbitrary VAWT structure affixed to a floating platform. Simple drivetrain and generator modules are also present in this version. Future work will implement fully coupled hydrodynamic, aerodynamic, and more robust nonlinear formulations.","category":"page"},{"location":"legacyUserGuide/#","page":"Legacy User Guide","title":"","text":"","category":"section"},{"location":"legacyUserGuide/#Overview-of-OWENS-Model-Formulation","page":"Legacy User Guide","title":"Overview of OWENS Model Formulation","text":"","category":"section"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"The fundamental requirements of the aeroelastic analysis tool for off-shore VAWTs necessitates a flexible framework capable of considering arbitrary configuration geometries, arbitrary loading scenarios, and the ability to interface with various modules that account for the interaction of the environment and power generation hardware with the turbine structure. The finite element method provides a means to satisfy these general requirements. If a sufficiently robust element is developed, a mesh (collection of elements) of an arbitrary VAWT configuration may be constructed via a mesh generator. The ability to capture various couplings and provide an accurate representation of turbine behavior will depend on the robustness of the element formulation.","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"The finite element method requires boundary conditions to be imposed on the elements by specifying loads or displacements at discrete points (nodes) in the mesh. These boundary conditions provide a clear interface between aerodynamic and hydrodynamic modules that impart forces on the turbine. With boundary conditions specified, unspecified displacements and loads may be calculated. Next, displacement motions of the turbine may be provided to aerodynamic and hydrodynamic modules to calculate loads on the turbine. This gives rise to mutual causation because in reality loads and displacements are intricately connected. Iterative procedures, however, often allow for a convergence to be reached, eliminating this issue for all practical purposes.","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"The subsections that follow will present basic formulation concepts for the OWENS analysis tool.","category":"page"},{"location":"legacyUserGuide/#Basic-Formulation-Concepts","page":"Legacy User Guide","title":"Basic Formulation Concepts","text":"","category":"section"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Basic formulation concepts will be discussed before describing components of the proposed formulation in detail. As stated earlier, the finite element method is utilized for its robustness and flexibility. A robust element formulation will become the foundation of the aeroelastic analysis tool. Analysis of the dynamic response of the turbine is challenging because of rotating components. Because almost all structural components of the turbine will be rotating at some rotor speed (𝛺), it is convenient to perform the formulation in a rotating reference frame. Such a frame is capable of capturing rotational effects, including centrifugal stiffening/softening and Coriolis effects.","category":"page"},{"location":"legacyUserGuide/#Equations-of-Motion","page":"Legacy User Guide","title":"Equations of Motion","text":"","category":"section"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Equations of motion for the platform are developed by treating the platform as a rigid body, whereas the turbine is treated as a rotating deformable body. Motions of discrete points on the turbine can be expressed as the sum of the turbine motion (deformation and rigid rotor rotation) and the platform motion (rigid). Expressions for the velocities of the platform and for an arbitrary point on the turbine are shown below:","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"oversetV_platform = frac_^(N)d dtoversetR_PN = dotU_1widehatn_1 + dotU_2widehatn_2 + dotU_3widehatn_3","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"oversetomega_platform = omega_1widehatp_1 + omega_2widehatp_2 + omega_3widehatp_3","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"oversetv = oversetV_platform + lbrack(oversetomega_platform + Omegawidehath_3) times oversetrrbrack + frac_^(H)d dtoversetr","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"(Image: figs/userguide1.png){width=\"2.3in\" height=\"2.28in\"}","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Figure 1 Illustration of frames, position vectors, and angular velocities","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Figure 1 presents an illustration of the frames, angular velocities, and positions vectors that will be described. Here, U~i~ represents the displacement components of the platform center of mass, and 𝜔~i~ represents the angular velocity components of the platform. The inertial frame is represented by the n~i~ coordinate axes, the platform frame is represented by the p~i~ coordinate axes, and the rotating hub frame is represented by the h~i\\ ~coordinate axes. The vector r defines the position of an arbitrary point on the turbine with respect to the hub frame origin. The time derivative of this vector is taken within the hub frame and is essentially the time derivative of turbine deformations. The platform and hub frame origins are coincident, and there is no translational velocity of the hub frame relative to the turbine frame. Hamilton's principle relates the variation of kinetic energy (T) and potential energy (V), and virtual work of non-conservative forces (δW~np­~) to formulate equations of motion. Hamilton's extended principle is written simply as:","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"deltaint_t_1^t_2leftlbrack T(t) - V(t) rightrbrack dt +int_t_1^t_2delta W_np = 0","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"The kinetic energy of the system may be written compactly as:","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"T_system = T_platform + T_turbine","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"T_platform = frac12M_platformoversetV_platform bullet oversetV_platform + frac12(oversetomega_platform)^Tlbrack Jrbrackoversetomega_platform","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"T_turbine = frac12int_V^rhooversetv bullet oversetvdV","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"The platform kinetic energy is decomposed into two parts, translational kinetic energy and rotational kinetic energy (where [J] is the moment of inertia tensor for the platform). The turbine (which will be represented by a collection of elements) kinetic energy is expressed in terms of the volume integral of the turbine density and the velocity of infinitesimal points in the turbine (as developed earlier).","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Note that the quantities described above may be represented or \"coordinatized\" in any frame. Indeed, some vectors were expressed in the inertial (n~i~) frame, and others in the rotating hub (h~i~) frame. Because the rotating turbine represents the bulk of the modeling effort, the implementation of the equations of motion will be coordinatized in the hub frame. Platform motions and forces, however, are described in the inertial or platform frames. Therefore, transformations between the various frames are performed where necessary.","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"In the development of equations of motion, one can choose to retain the rotor angular velocity/acceleration (Omega) and platform angular velocity/acceleration (omega_i) as degrees of freedom in the resulting system of equations or as specified parameters. Retaining these terms as degrees of freedom is undesirable because it adds significant complexity to the formulation and introduces a significant number of nonlinear terms. More critically, however, is that the analysis tool must be interfaced with independent modules for aerodynamics, hydrodynamics, and generator dynamics that will affect these rotational motion quantities. Therefore, it is not possible to retain these variables as degrees of freedom in the model formulation without losing the ability to interface generic modules. Accordingly, these variables will be retained as specified motion parameters. The value of these parameters will be updated by post-processing routines after gathering information from the aforementioned modules and turbine motions.","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"The resulting equations of motion for a floating turbine structure will be of the following form (hyperbolic):","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"lbrack Mrbrackleft ddotU right + lbrack Crbrackleft dotU right + lbrack Krbrackleft U right = left F right","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"This can be decomposed to show contributions from the turbine and platform and show couplings between the two:","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"beginbmatrix\nM_TT  M_TP \nM_PT  M_PP\nendbmatrixbeginBmatrix\nddotU_T \nddotU_P\nendBmatrix + beginbmatrix\nC_TT  C_TP \nC_PT  C_PP\nendbmatrixbeginBmatrix\ndotU_T \ndotU_P\nendBmatrix + beginbmatrix\nK_TT  K_TP \nK_PT  K_PP\nendbmatrixbeginBmatrix\nU_T \nU_P\nendBmatrix = beginBmatrix\nF_T \nF_P\nendBmatrix","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Such that M, C, and K represent the system mass, damping, and stiffness matrices respectively. The terms U~T~ and U~P~ denote the displacement of the turbine and platform respectively. The terms F~T~ and F~P~ denote the forces acting on the turbine and platform respectively. Terms with subscript \"TT\" denote influence of the turbine forces on the turbine response. Whereas, terms with subscript \"TP\" denote influence of turbine forces on the platform response, and terms with subscript \"PT\" denote influence of the platform forces on the turbine response. Finally, terms with subscript \"PP\" denote the influence of platform forces on the platform response. Although not explicitly shown here, the rotor velocity/acceleration and platform velocity/acceleration are incorporated in the system damping and stiffness matrices through gyroscopic effects.","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Modal analysis may be performed on the above system of equations to examine the stability of the turbine configuration. Whereas understanding the stability of a turbine to avoid potential resonance issues is critical, transient conditions such as rotor start-up, turbulent/unsteady winds, and unsteady waves require a transient analysis capability. Implicit time integration methods have been considered for their ability to reduce time step restriction and maintain efficiency.","category":"page"},{"location":"legacyUserGuide/#-2","page":"Legacy User Guide","title":"","text":"","category":"section"},{"location":"legacyUserGuide/#Overview-of-OWENS-Analysis-Framework","page":"Legacy User Guide","title":"Overview of OWENS Analysis Framework","text":"","category":"section"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"The Offshore Wind Energy Numerical Simulation (OWENS) allows for a convenient coupling of the aeroelastic/structural dynamics finite element analysis to aerodynamic, hydrodynamic, and generator modules. Figure 2 shows an illustration for the framework of OWENS indicating data flow among the analysis tool and various modules. In this figure analysis components surrounded in the purple boxes are independent modules that will interface with the VAWT simulation tool. OWENS will provide and receive data to and from these modules. The implementation of these modules, however, are \"as is\" and cannot be modified by the authors. Components outlined in the blue boxes are components of the analysis tool that are under direct development by the authors. Data flow is illustrated by various colored arrows. Orange arrows denote an internal data flow from one segment of the OWENS analysis routines to another. Red arrows denote flow of information from the core analysis tool to external modules. Green arrows represent flow of information from external modules to the core analysis tool components.","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"This analysis framework begins with startup procedures. These include creation of the VAWT configuration mesh using the mesh generator VAWTGen, and specification of initial conditions. VAWTGen produces a finite element mesh representative of a VAWT. Initial conditions such as the initial forces acting on the turbine/platform, initial rotor angular velocity/acceleration, and initial platform angular velocity/acceleration must be provided. With these specifications complete, the coupled aeroelastic/hydrodynamic analysis begins, involving the components outlined in the black box.","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"The mesh and initial conditions are provided to the OWENS toolkit. By performing a transient analysis via the aforementioned time integration procedures, turbine and platform motions are calculated. The turbine motions along with aerodynamic properties of the turbine are provided to an aerodynamics module. Future versions will actively link OWENS with aerodynamic modules and wind field data while considering turbine motions to calculate aerodynamic loads on the turbine. The aerodynamic loads are provided back to the OWENS toolkit as boundary conditions for the next time step or iteration.","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"The motion of the turbine shaft is provided to a generator/drivetrain model, which considers the relative motions of the shaft and generator to calculate a resistance torque provided by the generator. By considering the resistance torque along with the shaft torque and rotor inertia, an updated rotor angular velocity/acceleration may be calculated. The generator module is similar to that of NREL's FAST analysis tool [3].","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"OWENS is interfaced with the WavEC platform dynamics module[2]. The hydrodynamics/mooring module accepts wave data as external forcing on the platform and a reaction force from the attached turbine structure. This module returns rigid body motions (translational and rotational) of the platform due to platform accelerations. These rigid body motions are then applied to the structure as body forces. The resistance torque of the generator may also be applied to the platform.","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"The above description fully outlines the proposed analysis framework and interface of the core analysis tool with various modules. In the development of this framework, a loose coupling is inherent in that typically motions are provided to a module and loads are calculated and supplied back to the analysis tool. In reality such a clear flow of information does not exist, and the coupling is more complex with loads influencing motions in addition to the motions influencing loads. Therefore, at any given time step an iterative procedure is considered to reach a convergence among the actual two-way coupling between the turbine structural dynamics and aerodynamics, hydrodynamics, and generator dynamics.","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Future versions may consider a turbine controller algorithm that provides prescribed motions of the tower and blades or applied braking torque is also required. The prescribed motions or applied torques are imposed via boundary conditions on the finite element model. As illustrated in Figure 2, the turbine controller accepts turbine motions, rotor speed/torque, or wind data and provides prescribed motions or breaking torques. The finite element model provides a convenient interface for the turbine controller.","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"(Image: figs/userguide2.png){width=\"8.1578947944007in\" height=\"5.019896106736658in\"}","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Figure Analysis framework for the OWENS toolkit","category":"page"},{"location":"legacyUserGuide/#OWENS-Installation","page":"Legacy User Guide","title":"OWENS Installation","text":"","category":"section"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"The OWENS analysis software should be installed by adding the following directories to the MATLAB path:","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"OWENS\\source\nOWENS\\source\\commonSource\nOWENS\\source\\modalSource\nOWENS\\source\\transientSource\nOWENS\\source\\utilitySource\nOWENS\\serverFiles","category":"page"},{"location":"legacyUserGuide/#Platform-dynamics-software-interface","page":"Legacy User Guide","title":"Platform dynamics software interface","text":"","category":"section"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"If a floating turbine is to be considered, the WavEC platform dynamics software[2] should be installed and the file \"waveECStartUp.m\" should be modified in the \"OWENS/source/transientSource/\" directory. An appropriate system call must be specified to launch a MATLAB instance of WavEC that accepts a network socket connection from OWENS. The string variable \"sysCallString\" in the following code snippet must be modified appropriately depending on whether a Unix or PC system is being used.","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"%sets system commands to launch wavEC software","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"hydroLaunchScript = \\'/home/bcowens/work/OWENSsingle/launchPlatformCode\\';","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"%sysCallString = [matlabPath,\\' -sd \\',hydroCodeDirectory,\\' -r \\',hydroCodeExec,\\' &\\'];","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"sysCallString = [\\'bash \\',hydroLaunchScript,\\' &\\'];","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"disp(\\'launching WAVEC\\'); %launch wavEC depending on pc or unix environment","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"if(ispc());","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"system(sysCallString);","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"end","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"if(isunix())","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"unix(sysCallString);\nend","category":"page"},{"location":"legacyUserGuide/#OWENS-Command-Line-Execution","page":"Legacy User Guide","title":"OWENS Command Line Execution","text":"","category":"section"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"The beta version of OWENS is written using the MATLAB programming language. The OWENS source code directory (and subdirectories) should be added to the MATLAB path, and OWENS should be executed from a job directory containing the associated input files described in the following section. Three types of analysis capabilities exist: static, modal and, transient analysis. These will be described in the following subsections.","category":"page"},{"location":"legacyUserGuide/#Static-Analysis-Execution","page":"Legacy User Guide","title":"Static Analysis Execution","text":"","category":"section"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"The static analysis capability of OWENS is executed as follows:","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"owens(inputFile,'S',rotorSpeed,nonlinearBool,dispGuess);","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"For example:","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"owens('vawt.owens','S',0.5,true);","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Performs a modal analysis using the main OWENS input file \"vawt.owens\". The input character 'S' denotes a static analysis is to be performed. Rotor speed input is the specified angular velocity of the rotor in Hz. The Boolean input of \"true\" geometric nonlinearities. Setting this Boolean to false performs a linear static analysis. The input \"dispGuess\" is an array of the initial guess for displacements to be used in nonlinear static analysis and should be a vector of the total number of degrees of freedom in the structural model (number of nodes x 6). It is not used if nonlinearBool is set to false. If not specified, the initial guess is a vector of zeros by default.","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"By default, body forces from gravity and rotational effects are included in static analysis. Arbitrary static loading may be specified by modifying the \"externalForcingStatic.m\" file in the OWENS source directory. The Fexternal array may be modified to include loads for a corresponding degree of freedom in the Fdof array. See this function for usage instructions.","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"For nonlinear static analysis, load stepping procedures are implemented within OWENS. The parameters governing load stepping and nonlinear iteration may be adjusted if desired by the user and the process is described in Appendix B.","category":"page"},{"location":"legacyUserGuide/#Modal-Analysis-Execution","page":"Legacy User Guide","title":"Modal Analysis Execution","text":"","category":"section"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"The modal analysis capability of OWENS is executed as follows:","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"owens(inputFile,'M',rotorSpeed,spinUpBool,numModesOutput,dispGuess);","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"For example:","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"owens('vawt.owens','M',0.0,true,40);","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Performs a modal analysis using the main OWENS input file \"vawt.owens\". The input character 'M' denotes a modal analysis is to be performed. Rotor speed input is the specified angular velocity of the rotor in Hz. The Boolean input of \"true\" activates a spin up procedures which performs a nonlinear static analysis on the structure to arrive at a \"stiffened\" stiffness matrix to be used in the modal analysis. Setting this Boolean to false skips the spin up procedure and uses an unmodified stiffness matrix in modal analysis. The last argument is the number of modes extracted and output for the model. If no value is specified, the default number is 20. The input \"dispGuess\" is an array of the initial guess for displacements to be used in nonlinear static analysis and should be a vector of the total number of degrees of freedom in the structural model (number of nodes x 6). It is not used if spinUpBool is set to false. If not specified, the initial guess is a vector of zeros by default.","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"By default, body forces from gravity and rotational effects are included in static analysis used in pre-stressed modal analysis. Arbitrary static loading may be specified by modifying the \"externalForcingStatic.m\" file in the OWENS source directory. The Fexternal array may be modified to include loads for a corresponding degree of freedom in the Fdof array. See this function for usage instructions.","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"For pre-stressed modal analysis (which employs nonlinear static analysis), load stepping procedures are implemented within OWENS. The parameters governing load stepping and nonlinear iteration may be adjusted if desired by the user and the process is described in Appendix B.","category":"page"},{"location":"legacyUserGuide/#Creating-Campbell-Diagrams-of-a-VAWT-Configuration","page":"Legacy User Guide","title":"Creating Campbell Diagrams of a VAWT Configuration","text":"","category":"section"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Automated functionality exists for creating Campbell diagrams of a land based VAWT configuration. A Campbell diagram examines how modal frequencies vary with respect to the rotor speed of a turbine. It is also helpful for identifying critical per-rev excitations that may cause resonance in a VAWT configuration.","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"The function \"campDiagramGen.m\" located in \"OWENS/source/utilitySource/\" performs modal analysis at user specified rotor speeds. Command line execution is performed with the following call:","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"[freq] = campDiagramGen(inputFileName,outputFileName,rotorSpeedArray,spinUpOn,numModes)","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Such that \"inputFileName\" is a string specifying the main .owens file corresponding to the VAWT configuration. The \"outputFileName\" is a string specifying the prefix that will be given to a MATLAB .mat array containing the results. The rotor speed array and corresponding frequencies are saved to this .mat file. The \"rotorSpeedArray\" variable is an array containing the rotor speeds (Hz) of interest. The Boolean flag \"spinUpOn\" includes nonlinear stress stiffening effects in modal analysis if set to true, if set to false these effects are excluded from the analysis. The integer \"numModes\" specifies the number of lower system modes to extract during modal analysis.","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"The previous functionality performed the analysis for creating a Campbell diagram, and \"campDiagPlotter.m\" in \"OWENS/source/utilitySource\" plots the Campbell diagram. Command line execution of Campbell diagram plotting is performed with the following call:","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"campDiagPlotter(resultsFileName,numModesToPlot,numPerRevLines,minRPMplot,maxRPMplot)","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Such that \"resultsFileName\" is a string specifying the .mat file generated using campDiagramGen.m. The integer \"NumModesToPlot\" specifies the number of modes to be plotted on the Campbell diagram. The integer \"numPerRevLines\" specifies how many per-rev lines to include on the Campbell diagram. The values \"minRPMplot\" and \"maxRPMplot\" specify the RPM values at which the per-rev lines will begin and end. Figure 3 shows an example of a Campbell digram generated using the aforementioned procedures.","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"(Image: figs/userguide3.png){width=\"5.829861111111111in\" height=\"4.254861111111111in\"}","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Figure 3 Example of a Campbell diagram","category":"page"},{"location":"legacyUserGuide/#Transient-Analysis-Execution","page":"Legacy User Guide","title":"Transient Analysis Execution","text":"","category":"section"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"The transient analysis capability of OWENS is executed as follows:","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"owens(inputFile,'TNB',timeStep,numTimeSteps,nlBool,turbineOperationParams...);","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"By default, body forces from gravity and rotational effects are included in trasient analysis. Arbitrary transient external loading may be specified by modifying the \"externalForcing.m\" file in the OWENS source directory. The Fexternal array may be modified to include loads for a corresponding degree of freedom in the Fdof array. See this function for usage instructions.","category":"page"},{"location":"legacyUserGuide/#Specified-rotor-speed-profile","page":"Legacy User Guide","title":"Specified rotor speed profile","text":"","category":"section"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"An arbitrary VAWT configuration may be subjected to an arbitrary, specified rotor speed profile using the following command line execution.","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"owens('vawt.owens','TNB',1.0e-3,40000,true,0,[0.0 5.0 30.0],[0.0 0.5 0.5]);","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"This performs a transient analysis using the main OWENS input file 'vawt.owens'. The input character 'TNB' denotes a transient analysis is to be performed. A time step of 1.0e-3 seconds is utilized and 40000 time steps are performed for a simulation time of 40 seconds. The flag of true activates nonlinear strain calculation in the transient analysis. The turbine operation flag of \"0\" denotes a specified omega profile is utilized. The 7^th^ argument is an array of times for the specified rotor speed profile. The 8^th^ argument is an array of specified rotor speeds at the aforementioned times.","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Alternatively, the 7^th^ and 8^th^ arguments may be omitted and the file \"OWENS\\source\\userDefinedRotorSpeedProfile.m\" may be modified to specify an arbitrary time varying rotor speed profile. See the comments within this function for appropriate usage.","category":"page"},{"location":"legacyUserGuide/#Forced-start-up-mode-using-generator","page":"Legacy User Guide","title":"Forced start-up mode using generator","text":"","category":"section"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"An arbitrary VAWT configuration may be subjected to a forced start-up mode using the generator to provide a motoring torque using the following command line execution.","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"owens('vawt.owens','T',1.0e-3,40000,true,1,0.0);","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"This performs a transient analysis using the main OWENS input file 'vawt.owens'. The input character 'TNB' denotes a transient analysis is to be performed. A time step of 1.0e-3 seconds is utilized and 40000 time steps are performed for a simulation time of 40 seconds. The flag of true activates nonlinear strain calculation in the transient analysis. The turbine operation flag of \"1\" denotes a forced start up using the generator as a motor. Accordingly, generator properties must be specified by providing a .gen file. The 7^th^ argument is the initial rotor speed at t=0 in Hz.","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Alternatively, the .gen file in the main .owens input file may be replaced with the integer \"1\" and a user defined generator function may be employed. The file \"OWENS\\source\\userDefinedGenerator.m\" may be modified to specify an arbitrary time varying rotor speed profile. See the comments within this function for appropriate usage.","category":"page"},{"location":"legacyUserGuide/#Self-starting-turbine-mode","page":"Legacy User Guide","title":"Self-starting turbine mode","text":"","category":"section"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"An arbitrary VAWT configuration may be considered in a self-starting mode in which external forces provide a torque to increase the rotor speed of the turbine using the following command line execution.","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"owens('vawt.owens','T',1.0e-3,40000,true 2,0.0,1.05);","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"This performs a transient analysis using the main OWENS input file 'vawt.owens'. The input character 'TNB' denotes a transient analysis is to be performed. A time step of 1.0e-3 seconds is utilized and 40000 time steps are performed for a simulation time of 40 seconds. The turbine operation flag of \"2\" denotes a self-starting turbine with the generator disconnected from the grid initially. The 7^th^ argument is the initial rotor speed at t=0 in Hz. The 8^th^ argument is the rotor speed at which the generator will activate. Accordingly, generator properties must be specified by providing a .gen file. The history of nodal displacements, generator torque, generator power, rotor speed, rotor position, and reaction at the turbine base at each time step are saved in the MATLAB file \\<root\\>.mat such as \"vawt.mat\". Table 1 provides a listing with output description, variable name, and size of the output.","category":"page"},{"location":"legacyUserGuide/#Transient-Analysis-Execution-Using-Reduced-Order-Model","page":"Legacy User Guide","title":"Transient Analysis Execution Using Reduced Order Model","text":"","category":"section"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"The transient analysis capability with a reduced order model of OWENS is executed as follows:","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"owens(inputFile,'ROM',timeStep,numTimeSteps,numModesForROM,nlBool,turbineOperationParams...);","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"This option performs a transient analysis as before, but using a reduced order model which contains a subset of system modes as specified by \"numModesForROM\". The reduced order model contains the first \"numModesForROM\" lowest frequency modes. A modal analysis should be constructed to determine how many modes a user is interested in including in a reduced order model. The various operation modes (specified rotor speed, force start-up, self-starting) are specified as in the previous section.","category":"page"},{"location":"legacyUserGuide/#OWENS-Input-Files","page":"Legacy User Guide","title":"OWENS Input Files","text":"","category":"section"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"This section presents input file formats for OWENS, including the main input file and sub-input files. The input files discussed in this section include:","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"OWENS main input file (.owens)\nBeam mesh file (.mesh)\nElement property file (.el)\nElement orientation file (.ort)\nJoint file (.jnt)\nConcentrated nodal term file (.ndl)\nBoundary conditions file (.bc)\nPlatform simulation file (.plat)\nInitial conditions file (.ic)\nBlade data file (.bld)\nAerodynamic loads file\nDriveshaft file (.ds)\nGenerator properties file (.gen)","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Note that while these files may be created manually, many are created automatically by the mesh generator/pre-processor VAWTGen. VAWTGen is described in a separate user guide[1] and is not discussed here.","category":"page"},{"location":"legacyUserGuide/#OWENS-Main-Input-File-(.owens)","page":"Legacy User Guide","title":"OWENS Main Input File (.owens)","text":"","category":"section"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"The OWENS main input file is generated by VAWTGen with the following format:","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"vawt.mesh\nvawt.el\nvawt.ort\nvawt.jnt\n[concentrated nodal terms file]\nvawt.bc\n0 vawt.plat\n[initial conditions file]\n0 vawt.bld [aero loads file]\n0 [drivetrain property file]\n[generator property file]\n0.0 0.0","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"The mesh, element, orientation, joint, and boundary conditions files for analysis are listed. The bracketed file comments serve as place holders and are not essential for all OWENS analysis types. The 5^th^ line specifies a concentrated nodal term file that can be used to specify concentrated masses, stiffness, and loads at nodal locations. The 6^th^ line specifies a boundary condition file. The integer on the 7^th^ line is a flag for activating the floating platform (1 – active, 0 – inactive) and the following platform file contain information governing a platform dynamics analysis. The 8^th^ line specified initial conditions for a transient analysis. The flag on the 9^th^ line governs activation of aerodynamic loads, a blade file provides information for mapping aerodynamic loads to the structural mesh, and an aerodynamic loads file provide loading data. The flag on the 10^th^ line governs activation of a simple drivetrain model and the drive train property file contains drive train model properties. The 11^th^ line specifies properties for a simple induction generator, which is not required for all analysis types. The 12^th^ line specifies Rayleigh damping parameters. These are the 𝛼 and 𝛽 parameters respectively in the following expression for the damping matrix:","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"lbrack Crbrack =  alphalbrack Mrbrack + betalbrack Krbrack","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Such that [M], [C], and [K] are the system mass, damping, and stiffness matrices respectively. 𝛼 and 𝛽 should be positive numbers. 𝛼 serves to damp higher frequency modes while 𝛽 serves to damp lower frequency modes.","category":"page"},{"location":"legacyUserGuide/#Mesh-File-(.mesh)","page":"Legacy User Guide","title":"Mesh File (.mesh)","text":"","category":"section"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"The mesh file generated by VAWTGen simply lists nodal coordinates and element connectivity. The number of structural components (tower, blades, and struts) and number of elements per component are also listed in this file. The file format is described below:","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"numNodes numElements\nnodeNum xCoord yCoord zCoord\nnodeNum xCoord yCoord zCoord\nnodeNum xCoord yCoord zCoord\n...\nelementNum numNodesPerElement localNodeNum1 localNodeNum2\nelementNum numNodesPerElement localNodeNum1 localNodeNum2\nelementNum numNodesPerElement localNodeNum1 localNodeNum2\n...\nnumberOfStructuralComponents numElementsComponent1 .... numElementsComponentN","category":"page"},{"location":"legacyUserGuide/#Element-Property-File-(.el)","page":"Legacy User Guide","title":"Element Property File (.el)","text":"","category":"section"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"The element property file generated by VAWTGen contains element mechanical and some aerodynamic properties. The properties specified in this file are those defined in the NREL file formats [1], but sorted into a form that is more usable by the OWENS analysis tool. It should be noted that the mass offsets have been corrected to be the distance from the offset from the elastic axis of section. Edgewise offsets are positive towards the trailing edge, flapwise offsets are positive outward from the machine center. The alpha coupling factor is not currently employed in analysis. The file has the following format:","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Element1, Node 1: [blade fraction] [aeroCenter] [structuralTwist] [MassPerLength] [FlapwiseStiffness] [EdgewiseStiffness] [TorsionalStiffness] [AxialStiffness] [alphaCouplingFactor] [FlapwiseInertia] [EdgewiseInertia] [Precurve] [PreSweep] [FlapwiseCGoffset] [EdgewiseCGOffset] [FlapwiseEAOffset] [EdgewiseEAOffset] ...\nElement1, Node 2: [blade fraction] [aeroCenter] [structuralTwist] [MassPerLength] [FlapwiseStiffness] [EdgewiseStiffness] [TorsionalStiffness] [AxialStiffness] [alphaCouplingFactor] [FlapwiseInertia] [EdgewiseInertia] [Precurve] [PreSweep] [FlapwiseCGoffset] [EdgewiseCGOffset] [FlapwiseEAOffset] [EdgewiseEAOffset] ...","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"...","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"...\nElement n, Node 1: [blade fraction] [aeroCenter] [structuralTwist] [MassPerLength] [FlapwiseStiffness] [EdgewiseStiffness] [TorsionalStiffness] [AxialStiffness] [alphaCouplingFactor] [FlapwiseInertia] [EdgewiseInertia] [Precurve] [PreSweep] [FlapwiseCGoffset] [EdgewiseCGOffset] [FlapwiseEAOffset] [EdgewiseEAOffset] ...","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Element n, Node 2: [blade fraction] [aeroCenter] [structuralTwist] [MassPerLength] [FlapwiseStiffness] [EdgewiseStiffness] [TorsionalStiffness] [AxialStiffness] [alphaCouplingFactor] [FlapwiseInertia] [EdgewiseInertia] [Precurve] [PreSweep] [FlapwiseCGoffset] [EdgewiseCGOffset] [FlapwiseEAOffset] [EdgewiseEAOffset] ...","category":"page"},{"location":"legacyUserGuide/#Element-Orientation-File-(.ort)","page":"Legacy User Guide","title":"Element Orientation File (.ort)","text":"","category":"section"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"The element orientation file generated by VAWTGen lists Euler angles for a 3-2 rotation sequence and some other miscellaneous element information. The file format is described below:","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"elNum theta3 theta2 theta1 length xOffset yOffset zOffset","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Such that elNum is the element number. Theta3, theta2, and theta1 are the orientation angles (degrees) about a 3, 2, and 1 axes respectively for a 3-2-1 Euler rotation sequence. Length is the element length, and x/y/zOffsets are the offsets of the first node of the element from the coordinate frame origin.","category":"page"},{"location":"legacyUserGuide/#Joint-File-(.jnt)","page":"Legacy User Guide","title":"Joint File (.jnt)","text":"","category":"section"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"The joint file generated by VAWTgen specifies joint conditions at coincident nodes between structural components. The file format for the joint file is shown below:","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"jointNumber masterNode slaveNode jointType jointMass 0.0 ... jointPsi jointTheta","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"A master and slave node is defined at a joint from which constraints will be developed. The joint type is also specified (0 = weld(fixed), 1=pinned, 2 = hinge joint with axis about slave node element's e~2~ axis, 3 = hinge joint axis about slave node element's e~1~ axis, 4 = hinge joint axis about slave node element's e~3~ axis). The mass of the joint may be specified in this file. If this option is not sufficient for modeling purposes concentrated mass can be imposed on degrees of freedom using the .ndl file. [A place-holder double of zero after jointMass is also in this file, but not currently used in analysis.]{.mark} The orientation associated with the joint is also described by the jointPsi and jointTheta angles (degrees). These angles are used to transform from the global coordinate frame to the local element/joint frame via a 3-2 Euler rotation sequence. Psi denotes rotation about 3, theta denotes rotation about 2.","category":"page"},{"location":"legacyUserGuide/#Concentrated-Nodal-Terms-File","page":"Legacy User Guide","title":"Concentrated Nodal Terms File","text":"","category":"section"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"The concentrated nodal terms file applies concentrated mass, stiffness, or forces to nodes of the finite element mesh. This files requires a node number, concentrated term type, local degree of freedom number, and value for the concentrated term. Concentrated term types include \"M\" for mass, \"K\" for stiffness, and \"F\" for force. The degree of freedom specification is not used when the concentrated term is for mass. The mass value specified is applied to all translational degrees of freedom associated with the specified node. See Appendix A for an explanation of local degree of freedom numbering at a particular node. A sample concentrated nodal terms file is shown below:","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"74 M 1 254.0\n81 K 3 1.0e6\n92 F 2 2000.0","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"nodeNum termType localDOFNum value","category":"page"},{"location":"legacyUserGuide/#Boundary-Conditions-File-(.bc)","page":"Legacy User Guide","title":"Boundary Conditions File (.bc)","text":"","category":"section"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"The boundary conditions file generated by VAWTGen specifies a fixed boundary condition at the tower base (node 1). This file specifies the number of boundary conditions, the node number, local degree of freedom, and specified displacement value for the boundary condition. This file attempts to provide a likely boundary condition for a VAWT structure, but may need to be modified by the analyst depending on the specific configuration of interest. See Appendix A for an explanation of local degree of freedom numbering at a particular node. The boundary condition file generated by VAWTGen is shown below:","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"6\n1 1 0.000000\n1 2 0.000000\n1 3 0.000000\n1 4 0.000000\n1 5 0.000000\n1 6 0.000000","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"nodeNum localDOFNum value","category":"page"},{"location":"legacyUserGuide/#Platform-Simulation-File-(.plat)","page":"Legacy User Guide","title":"Platform Simulation File (.plat)","text":"","category":"section"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"The platform simulation file specifies parameters required for an external platform dynamics simulation. An example, annotated platform file is shown below.","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"1 0 0 0 0 0 :active platform DOFs (surge, sway, heave, roll, pitch, yaw)","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"0.0 0.0 0.0 0.0 0.0 :initial conditions for platform DOFs","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"0 :drag damping flag (1 = on, 0 = off)","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"1 :mooring flag (1 = on, 0 = off)","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"0 :gravity flag (1 = on, 0 = off)","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"0 :plot flag (1 = on, 0 = off)","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"0 :radiation damping flag (1 = on, 0 = off)","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"1 :node number for platform turbine connection","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"1 :platform turbine yaw interaction (0 = free spinning tower, 1 = fixed tower, 2 = generator reaction torque applied to platform)","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"3500 :platform server port","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"4500 :platform client port","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"The first line activates platform degrees of freedom (DOFs) the ordering of degrees of freedom is surge, sway, have, roll, pitch, and yaw. The second line specifies initial conditions for the platform degrees of freedom, the DOF ordering is the same as the previous line. Lines 5-7 activate/deactivate various aspects of the hydrodynamic/platform dynamics simulation (drag, mooring, gravity, plotting, and radiation damping). Line 8 specifies the node number at the connection of the turbine to the platform. This is used in calculating the reaction force the turbine imparts on the platform. Line 9 is a flag to specify the platform turbine yaw interaction. For a flag of 0 there is no interaction, for a flag of 1 the tower is considered fully constrained to the platform, for a flag of 2, the generator reaction torque is applied to the turbine. The last two lines specify the server port and client port numbers for the network socket interface between the OWENS analysis tool and the platform dynamics module.","category":"page"},{"location":"legacyUserGuide/#Initial-Conditions-File","page":"Legacy User Guide","title":"Initial Conditions File","text":"","category":"section"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"The initial conditions file is used for transient analysis to specify an initial displacement of the structure at t =0. This file requires a node number, local degree of freedom number, and displacement value. See Appendix A for an explanation of local degree of freedom numbering at a particular node. The file format is described below:","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"60 1 0.1\n51 2 -0.4\nnodeNum localDOFNum value","category":"page"},{"location":"legacyUserGuide/#Blade-Data-File-(.bld)","page":"Legacy User Guide","title":"Blade Data File (.bld)","text":"","category":"section"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"A blade data file is generated by VAWTGen to aid in mapping aerodynamic loads to the structural mesh generated by VAWTGen. This information includes the blade number, node locations of blade sections in terms of spanwise distance from the blade root, and node number and element numbers associated with these locations. The file also contains the quarter chord coordinate of the blade section, the normal and tangential vector components of the blade section, and the chord of the section. Coordinate and vector components are represented in the rotating, rotor-fixed hub frame. An integer number representing the airfoil as specified in the .ipt file for the blade component and section lift curve slope are also specified. The last column is a place holder not used in the release version of OWENS. The file format for the blade file is described below:","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"bladeNum nodeDistance nodeNum elementNum quarterChordCoord1 quarterChordCoord2 quarterChordCoord3 sectionNormalVec1 sectionNormalVec2 sectionNormalVec3 sectionTangentVec1 sectionTangentVec2 sectionTangentVec3 sectionChord sectionAirfoilNumber [place holder not used]","category":"page"},{"location":"legacyUserGuide/#Aerodynamic-Loads-File","page":"Legacy User Guide","title":"Aerodynamic Loads File","text":"","category":"section"},{"location":"legacyUserGuide/#Drivetrain-Properties-File","page":"Legacy User Guide","title":"Drivetrain Properties File","text":"","category":"section"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"The drive train properties file is read for cases where the drive train flag is set to true in the main OWENS analysis file. This file contains an effective torsional spring and damping constant for the drivetrain, along with a moment of inertia for the drive train. These values are cast on the low speed shaft (LSS) side of the drivetrain. The file also contains gear ratio and gear box efficiency parameters. A sample drivetrain file is shown below:","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"1.0e8 1e6 1000.0 :drivetrain spring constant, damping constant, MOI\n1.0 1.0 :gear ratio, gear box efficiency","category":"page"},{"location":"legacyUserGuide/#Generator-Properties-File","page":"Legacy User Guide","title":"Generator Properties File","text":"","category":"section"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"The generator properties file is read where the turbine operation mode requires generator interaction. This file includes the generator rated torque, zero torque generator speed, pull out ratio, and rated slip percentage. A sample generator properties file is shown below:","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"2.09e4 :generator rated torque\n1.0 :zero torque generator speed (in Hz)\n2.0 :pull out ratio\n5.0 :generator rated slip percentage","category":"page"},{"location":"legacyUserGuide/#OWENS-Output-Files","page":"Legacy User Guide","title":"OWENS Output Files","text":"","category":"section"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"This section describes the output files generated by the OWENS analysis software. Output is different for the static, modal, and transient analysis types.","category":"page"},{"location":"legacyUserGuide/#Static-Analysis-Output","page":"Legacy User Guide","title":"Static Analysis Output","text":"","category":"section"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Output from this analysis is written to the root filename with \"_static.mat\" suffix, such as \"vawt_static.mat\". This MATLAB database contains a solution vector for each degree of freedom of the model. The deformed configuration may be visualized using VAWTGen visualization capabilities[1]. See Appendix A for an explanation of mapping between a global degree of freedom list to local degree of freedom numbering at a particular node.","category":"page"},{"location":"legacyUserGuide/#Modal-Analysis-Output","page":"Legacy User Guide","title":"Modal Analysis Output","text":"","category":"section"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"For modal analysis the output file lists the frequency, damping ratio, and nodal values for mode shapes of the 0 degree (real) and 90 degree out of phase (imaginary) mode shapes. The generated file has the same root name as the .owens input file, but with a suffix of .out. The various mode shapes may be visualized using VAWTGen visualization capabilities[1]. The file format for the modal analysis output is shown below:","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"MODE # 1","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Frequency: 9.941364e-001:","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Damping 3.576857e-014:","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"0 deg Mode Shape:","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Ux Uy Uz thetax thetay thetaz","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"-0.000000 -0.000000 -0.000000 -0.000000 0.000833 -0.000000","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"0.000627 0.000000 0.000000 -0.000000 0.000819 0.000000","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"0.001235 0.000000 0.000000 -0.000000 0.000780 0.000000","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"0.001819 0.000000 0.000000 -0.000000 0.000713 0.000000","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"0.002353 0.000000 0.000000 -0.000000 0.000620 0.000000","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"0.002669 0.000000 0.000000 -0.000000 0.000557 0.000000","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"0.002948 0.000000 0.000000 -0.000000 0.000497 0.000000","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"0.003196 0.000000 0.000000 -0.000000 0.000437 0.000000\n...\n90 deg Mode Shape:","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Ux Uy Uz thetax thetay thetaz","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"-0.000000 -0.000000 -0.000000 -0.000000 -0.000000 -0.000000","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"-0.000000 -0.000000 -0.000000 -0.000000 -0.000000 -0.000000","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"-0.000000 -0.000000 -0.000000 -0.000000 -0.000000 -0.000000","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"-0.000000 -0.000000 -0.000000 0.000000 -0.000000 -0.000000","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"-0.000000 -0.000000 -0.000000 -0.000000 -0.000000 -0.000000","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"-0.000000 -0.000000 -0.000000 -0.000000 -0.000000 -0.000000","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"-0.000000 -0.000000 -0.000000 -0.000000 -0.000000 -0.000000","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"-0.000000 -0.000000 -0.000000 -0.000000 -0.000000 -0.000000","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"-0.000000 -0.000000 -0.000000 -0.000000 -0.000000 -0.000000","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"...","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Mode #2","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"...","category":"page"},{"location":"legacyUserGuide/#-3","page":"Legacy User Guide","title":"","text":"","category":"section"},{"location":"legacyUserGuide/#Transient-Analysis-Output","page":"Legacy User Guide","title":"Transient Analysis Output","text":"","category":"section"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Transient analysis output has a great deal of data associated with it due to having both spatial and temporal information and OWENS transient analysis output is saved in a MATLAB workspace as \\<root\\>.mat. Table 1 lists the following information saved in the transient analysis output file with the variable name and associated array size. The units specified in this file assume that the mesh and associated element properties are in SI units. See Appendix A for an explanation of mapping between a global degree of freedom list to local degree of freedom numbering at a particular node.","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Transient analysis output may be visualized using VAWTGen visualization capabilities[1].","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Table 1. OWENS Transient Output","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Output                  Variable Name (units)   Size   –––––––––––- –––––––––––- –––––––––––-   Time                    t (s)                   1 x numTimeSteps","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Nodal displacements     uHist (m or rad)        numDOF x numTimeSteps","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Generator torque        genTorque (N-m)         1 x numTimeSteps","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Generator power         genPower (W)            1 x numTimeSteps","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Rotor position          aziHist (rad)           1 x numTimeSteps","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Rotor speed             OmegaHist (Hz)          1 x numTimeSteps","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Rotor acceleration      OmegaDotHist (Hz/s)     1x numTimetSteps","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Gearbox position        gbHist (rad)            1 x numTimeSteps","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Gearbox speed           gbDotHist (Hz)          1 x numTimeSteps","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Gearbox acceleration    gbDotDotHist (Hz/s)     1 x numTimeSteps","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Driveshaft torque       torqueDriveShaft (N-m)  1 x numTimeSteps","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Platform degrees of     rigidDof (m or rad)     6 x numTimeSteps   freedom                                         ","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Turbine base reaction   FReactionHist (N or     6 x numTimeSteps   force                   N-m)                       –––––––––––––––––––––––––––––––––––-","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":": Default static nonlinear analysis parameters","category":"page"},{"location":"legacyUserGuide/#References","page":"Legacy User Guide","title":"References","text":"","category":"section"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"VAWTGen Manual\nWavEC manual\nJonkman, J.M., and Buhl, M. L., 2005, FAST User's Guide, National  Renewable Energy Laboratory, NREL/EL-500-38230.","category":"page"},{"location":"legacyUserGuide/#Appendix-A:-Mapping-from-local-nodal-DOF-numbering-to-global-DOF-numbering","page":"Legacy User Guide","title":"Appendix A: Mapping from local nodal DOF numbering to global DOF numbering","text":"","category":"section"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"Structural nodes in the finite element formulation of the OWENS toolkit each have 6 degrees of freedom. That is 3 translational and 3 rotational. The finite element mesh is represented in a Cartesian frame with \"x\", \"y\", and \"z\" axes. The z axis is typically located along the tower axis of the turbine. Local degree of freedom numberings 1, 2, and 3 correspond to displacements along the x, y, and z axes respectively. Local degree of freedom numberings 4, 5, and 6 correspond to rotations of 4, 5, and 6 about the x, y, and z axes respectively.","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"For a particular node number \"nodeNum\" and an associated local degree of freedom \"localDOFNum\" the following relation exists to the global degree of freedom number \"globalDOFNum\".","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"globalDOFNum = (nodeNum-1)*6 + localDOFNum","category":"page"},{"location":"legacyUserGuide/#Appendix-B:-Nonlinear-Static-Analysis-Parameters","page":"Legacy User Guide","title":"Appendix B: Nonlinear Static Analysis Parameters","text":"","category":"section"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"If desired, the user may modify the default parameters for nonlinear static analysis. This is done by creating a file with the same prefix as the main (.owens) analysis file, but with the suffix \".nl\". For example, if the main file for an analysis is \"vawt.owens\", the nonlinear parameter file should be named \"vawt.nl\". If no \".nl\" file exists in the job directory default nonlinear static parameters will be used.","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"The nonlinear parameter file has the following format for adaptive load stepping in nonlinear iteration:","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"NR :iteration type, NR = Newton Raphson, DI = Direct Iteration","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"1.0e-6 :tolerance for nonlinear iteration convergence","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"5 :maximum number of iterations per load step","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"0 :integer denoting load steps (0 for adaptive), otherwise, number of load steps followed by values","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"20 :maximum number of load steps","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"0.3 :minimum load step","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"0.1 :minimum delta load step","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"The adaptive load stepping algorithm attempts to reach a converged solution by adjusting load steps as necessary within the specified or default nonlinear analysis parameters.","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"If desired, the user may specify a prescribed loadstepping profile for nonlinear iteration with the following file format:","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"NR :iteration type, NR = Newton Raphson, DI = Direct Iteration","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"1.0e-6 :tolerance for nonlinear iteration convergence","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"20 :maximum number of iterations per load step","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"5 0.2 0.4 0.6 0.8 1.0 :integer denoting load steps (0 for adaptive), otherwise, number of load steps followed by values","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"The prescribed load stepping algorithm attempts to reach a converged solution within the maximum number of iterations per load step and terminates analysis if unsuccessful.","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"By default, the nonlinear iteration parameters are those listed in Table","category":"page"},{"location":"legacyUserGuide/","page":"Legacy User Guide","title":"Legacy User Guide","text":"\nParameter                           Value –––––––––––––––––- –––––––––––––––––- Nonlinear Iteration Tolerance       1.0e-6\nIteration Type                      Newton Raphson\nLoads Stepping Algorithm            Adaptive\nMax Iterations Per Load Step        50\nMax Number of Load Steps            20\nMinimum Load Step                   0.05\nMinimum Load Step Delta             0.05","category":"page"},{"location":"reference/referenceFEA/#OWENSFEA","page":"OWENSFEA","title":"OWENSFEA","text":"","category":"section"},{"location":"reference/referenceFEA/#Types-and-functions","page":"OWENSFEA","title":"Types and functions","text":"","category":"section"},{"location":"reference/referenceFEA/#OWENSFEA.BC_struct","page":"OWENSFEA","title":"OWENSFEA.BC_struct","text":"Internal, boundary condition data, see ?FEAModel for pBC\n\n\n\n\n\n","category":"type"},{"location":"reference/referenceFEA/#OWENSFEA.ConcNDL1D","page":"OWENSFEA","title":"OWENSFEA.ConcNDL1D","text":"Internal, NodalTerms node number, local dof (diagonal), and value\n\n\n\n\n\n","category":"type"},{"location":"reference/referenceFEA/#OWENSFEA.ConcNDL2D","page":"OWENSFEA","title":"OWENSFEA.ConcNDL2D","text":"Internal, NodalTerms node number, local dof1, local dof2, and value\n\n\n\n\n\n","category":"type"},{"location":"reference/referenceFEA/#OWENSFEA.DispData","page":"OWENSFEA","title":"OWENSFEA.DispData","text":"Internal, displacement, velocity, and acceleration for each element\n\n\n\n\n\n","category":"type"},{"location":"reference/referenceFEA/#OWENSFEA.DispOut","page":"OWENSFEA","title":"OWENSFEA.DispOut","text":"DispOut(elStrain,displ_sp1,displddot_sp1,displdot_sp1)\n\nInternal, displacement, velocity, and acceleration for each element\n\nInputs\n\nelStrain: Not used, should be removed from this struct\n`displ_sp1::Array{<:float}: displacement position for each dof\n`displddot_sp1::Array{<:float}: displacement acceleration for each dof\n`displdot_sp1::Array{<:float}: displacement velocity for each dof\n\n\n\n\n\n","category":"type"},{"location":"reference/referenceFEA/#OWENSFEA.El","page":"OWENSFEA","title":"OWENSFEA.El","text":"Internal, see ?Ort and ?SectionPropsArray\n\n\n\n\n\n","category":"type"},{"location":"reference/referenceFEA/#OWENSFEA.ElInput","page":"OWENSFEA","title":"OWENSFEA.ElInput","text":"Internal, inputs to Timoshenko element, inputs given by FEAModel struct and mesh\n\n\n\n\n\n","category":"type"},{"location":"reference/referenceFEA/#OWENSFEA.ElOutput","page":"OWENSFEA","title":"OWENSFEA.ElOutput","text":"Internal, timoshenko element output matrices\n\n\n\n\n\n","category":"type"},{"location":"reference/referenceFEA/#OWENSFEA.ElStorage","page":"OWENSFEA","title":"OWENSFEA.ElStorage","text":"Internal, Timoshenko element matrices\n\n\n\n\n\n","category":"type"},{"location":"reference/referenceFEA/#OWENSFEA.ElStrain","page":"OWENSFEA","title":"OWENSFEA.ElStrain","text":"ElStrain(eps_xx_0,eps_xx_z,eps_xx_y,gam_xz_0,gam_xz_y,gam_xy_0,gam_xy_z)\n\nStruct containing element straing\n\nInputs\n\nepsilon_x::float: epsilon_x strain in the x direction\nepsilon_y::float: epsilon_y strain in the y direction\nepsilon_z::float: epsilon_z strain in the z direction\nkappa_x::float: kappa_x curvature in the x direction\nkappa_y::float: kappa_y curvature in the y direction\nkappa_z::float: kappa_z curvature in the z direction\n\nOutputs:\n\nnone:\n\n\n\n\n\n","category":"type"},{"location":"reference/referenceFEA/#OWENSFEA.FEAModel-Tuple{}","page":"OWENSFEA","title":"OWENSFEA.FEAModel","text":"FEAModel(;analysisType = \"TNB\",\n    initCond = [],\n    aeroElasticOn = false,\n    guessFreq = 0.0,\n    airDensity=1.2041,\n    gravityOn = true,\n    nlOn = false,\n    spinUpOn = false,\n    dataOutputFilename = \"none\",\n    RayleighAlpha = 0.0,\n    RayleighBeta = 0.0,\n    elementOrder = 1,\n    joint = [0,0],\n    platformTurbineConnectionNodeNumber = 1,\n    jointTransform = 0.0,\n    reducedDOFList = zeros(Int,2),\n    numDOFPerNode = 6,\n    numNodes = 0,\n    numModes = 20,\n    nlParams = 0,\n    pBC = 0,\n    nodalTerms = 0.0,\n    iterationType = \"NR\",\n    adaptiveLoadSteppingFlag = true,\n    tolerance = 1.0000e-06,\n    maxIterations = 50,\n    maxNumLoadSteps = 20,\n    minLoadStepDelta = 0.0500,\n    minLoadStep = 0.0500,\n    prescribedLoadStep = 0.0,\n    AddedMass_Coeff_Ca = 0.0)\n\nModel inputs for FEA analysis, struct\n\nInputs\n\nanalysisType::string: Newmark Beta time stepping \"TNB\", Dean time stepping \"TD\", modal \"M\", and stiff \"stiff\" (where the forces are just directly mapped, the displacements and strains set to 0 and the structures not run)\ninitCond::Array{<:float}: Initial conditions Nx3 matrix consisting of nodeNumber, local DOF (1-6), and displacement value\naeroElasticOn::Bool: Include simplified flutter calculataions in the timoshenko element matrices\nguessFreq::float: aeroelastic starting guess, only used if aeroElasticOn\nairDensity::float: working fluid density\ngravityOn::Bool orArray{<:float}: vector of 3 or flag to include distributed gravity acceleration (9.81m/s) in the negative z-direction\nnlOn::Bool: flag for solver to calculate deflection induced stiffness changes and associated convergance to the coupled solution\nspinUpOn::Bool: flag to perform a static analysis (warm start) prior to performing modal analysis\ndataOutputFilename::string: /path/to/desired/output/filename if it doesn't exist already it is created, if exists, is overwritten\nRayleighAlpha::float: Rayleigh alpha damping used in timoshenko beam damping matrix\nRayleighBeta::float: Rayleigh beta damping used in timoshenko beam damping matrix\nelementOrder::int: order of element: 1 linear, 2 quadratic\njoint::Array{<:float}: jointNumber masterNode slaveNode jointType (0 weld/fixed, 1 pinned, 2 hinge along local \"2\", 3 hinge about local \"1\", 4 hinge along \"3\", 5 rigid bar constraint)  jointMass 0.0 jointPsi jointTheta\nplatformTurbineConnectionNodeNumber::int: node at which reaction forces are calculated\njointTransform: not used as an input, is calculated, local transform between dependent and active DOFs for nodes associated with a particular joint\nreducedDOFList::Array{<:int}: not used as an input, is calculated, map of original DOF numbering to reduced DOF numbering\nnumDOFPerNode::int: number of degrees of freedom per node\nnumNodes::int: total number of nodes in the mesh\nnumModes::int: number of modes to calculate\nnlParams::NlParams: optional there in case the Nlparams struct is passed in, should be cleaned up since redundant\nalpha::float64: optional newmark beta alpha parameter,If TD, use 0.25\ngamma::float64: optional newmark beta gamma parameter, if static, use 0. If hydro, use 1.0\npBC::Array{<:float}: Nx3 array consisting of node, local dof, specified displacement value for the boundary condition\nnodalTerms: Concentrated nodal terms, should be replaced with the nodal input data array and the calc done internally\niterationType::string: FEA displacement update calculation, Newton Raphson \"NR\", Direct Iteration \"DI\"\nadaptiveLoadSteppingFlag: Unused, should be removed\ntolerance::float: FEA total mesh unsteady analysis convergence tolerance for a timestep\nmaxIterations: FEA total mesh unsteady analysis convergence max iterations for a timestep\nmaxNumLoadSteps: used in static (steady state) analysis\nminLoadStepDelta: used in static (steady state) analysis\nminLoadStep: used in static (steady state) analysis\nprescribedLoadStep: used in static (steady state) analysis\npredef::Bool: will update the elStorage array if passed into Unsteady() with the nonlinear strain stiffening, to be used for subsequent analyses\nAddedMass_Coeff_Ca::Float64: added mass coefficient, also used as a flag depending on if it is 0.0 or not\n\nOutputs:\n\nnone:\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceFEA/#OWENSFEA.Mesh","page":"OWENSFEA","title":"OWENSFEA.Mesh","text":"Mesh(nodeNum,numEl,numNodes,x,y,z,elNum,conn,type,meshSeg,structuralSpanLocNorm,structuralNodeNumbers,structuralElNumbers)\n\nStruct with mesh definition\n\nInputs\n\nnodeNum::Array{<:int}: Number mapping of nodes (typically 1:Nnodes)\nnumEl::int: total number of elements\nnumNodes::int: total number of nodes\nx::Array{<:float}: Nodal x position\ny::Array{<:float}: Nodal y position\nz::Array{<:float}: Nodal z position\nelNum::Array{<:int}: Number mapping of elements (typically 1:Nelements)\nconn::Array{<:int}: Nelemx2 connectivity between nodes, gaps between joints (which are defined in the joints)\ntype::Array{<:int}: 0-blade 1-tower 2-strut\nmeshSeg::Array{<:int}: number of nodes within each segment, with segments consisting of tower, blade 1 2 etc, struts\nstructuralSpanLocNorm::Array{<:float}: Should be named heigh loc norm - unitized position along the blade height, used for aeroload mapping\nstructuralNodeNumbers::Array{<:int}: Node numbers associated with blades for aero loads mapping\nstructuralElNumbers::Array{<:int}: Element numbers associated with blades for aero loads mapping\nnonRotating::Array{<:int}: size(Nsections,numNodes) where nsections are the number of sections of the mesh that are non-rotating, like if for some reason you had two towers, or if you had multiple guy wires\nhubNodeNum::int: Node number where the rotating part of the turbine starts, assumes meshing always starts with tower, then blades, etc.\n\nOutputs:\n\nnone:\n\n\n\n\n\n","category":"type"},{"location":"reference/referenceFEA/#OWENSFEA.NlParams","page":"OWENSFEA","title":"OWENSFEA.NlParams","text":"NlParams(iterationType,adaptiveLoadSteppingFlag,tolerance,maxIterations,maxNumLoadSteps,minLoadStepDelta,minLoadStep,prescribedLoadStep)\n\nSee ?FEAModel\n\n\n\n\n\n","category":"type"},{"location":"reference/referenceFEA/#OWENSFEA.NodalTerms","page":"OWENSFEA","title":"OWENSFEA.NodalTerms","text":"Internal, see ?FEAModel for NodalTerms\n\n\n\n\n\n","category":"type"},{"location":"reference/referenceFEA/#OWENSFEA.Ort","page":"OWENSFEA","title":"OWENSFEA.Ort","text":"Ort(Psi_d,Theta_d,Twist_d,Length,elNum,Offset)\n\nStruct with element orientation\n\nInputs\n\nPsi_d::Array{<:float}: length NumEl, element rotation about 3 in global FOR (deg) These angles are used to transform from the global coordinate frame to the local element/joint frame via a 3-2 Euler rotation sequence.\nTheta_d::Array{<:float}: length NumEl, element rotation about 2 (deg)\nTwist_d::Array{<:float}: length NumEl, element twist (deg)\nLength::Array{<:float}: length NumEl, element length (m)\nelNum::Array{<:float}: Element number the other arrays are associated with\nOffset::Array{<:float}: hub frame coordinate of node 1 of the element\n\nOutputs:\n\nnone:\n\n\n\n\n\n","category":"type"},{"location":"reference/referenceFEA/#OWENSFEA.ROM","page":"OWENSFEA","title":"OWENSFEA.ROM","text":"Internal, ROM data\n\n\n\n\n\n","category":"type"},{"location":"reference/referenceFEA/#OWENSFEA.SectionPropsArray","page":"OWENSFEA","title":"OWENSFEA.SectionPropsArray","text":"SectionPropsArray(ac,twist,rhoA,EIyy,EIzz,GJ,EA,rhoIyy,rhoIzz,rhoJ,zcm,ycm,a,EIyz,alpha1,alpha2,alpha3,alpha4,alpha5,alpha6,rhoIyz,b,a0,aeroCenterOffset,xaf,yaf)\n\nStruct with element sectional properties, each component is a 1x2 array with distributed properties\n\nInputs\n\nac::Array{<:float}: aerodynamic center, used in flutter approximation\ntwist::Array{<:float}: element twist (rad)\nrhoA::Array{<:float}: rho * A in standard SI units\nEIyy::Array{<:float}: E * Iyy\nEIzz::Array{<:float}: E * Izz\nGJ::Array{<:float}: G * J\nEA::Array{<:float}: E * A\nrhoIyy::Array{<:float}: rho * Iyy\nrhoIzz::Array{<:float}: rho * Izz\nrhoJ::Array{<:float}: rho * J\nzcm::Array{<:float}: z location of center of mass\nycm::Array{<:float}: y location of center of mass\na::Array{<:float}: possibly lift slope\nEIyz::Array{<:float}: E * Iyz\nalpha1::Array{<:float}: #This is always 0 in the element file, and it is unclear what it is used for since I can't find it being used in the code\nalpha2::Array{<:float}: doesn't appear to be used\nalpha3::Array{<:float}: doesn't appear to be used\nalpha4::Array{<:float}: doesn't appear to be used\nalpha5::Array{<:float}: doesn't appear to be used\nalpha6::Array{<:float}: doesn't appear to be used\nrhoIyz::Array{<:float}: rho * Iyz\nb::Array{<:float}: used in flutter approximation, possibly a chord or thickness value\na0::Array{<:float}: zero lift angle of attack, used in flutter approximation\naeroCenterOffset::Array{<:float}: doesn't appear to be used\nxaf::Array{<:float}: x airfoil coordinates (to scale)\nyaf::Array{<:float}: y airfoil coordinates (to scale)\n\nOutputs:\n\nnone:\n\n\n\n\n\n","category":"type"},{"location":"reference/referenceFEA/#OWENSFEA.TimeInt","page":"OWENSFEA","title":"OWENSFEA.TimeInt","text":"Internal, time integration terms\n\n\n\n\n\n","category":"type"},{"location":"reference/referenceFEA/#OWENSFEA.ConcMassAssociatedWithElement-NTuple{5, Any}","page":"OWENSFEA","title":"OWENSFEA.ConcMassAssociatedWithElement","text":"ConcMassAssociatedWithElement(conn,joint,nodalMassTerms,nodalStiffnessTerms,nodalLoads)\n\nCompiles concentrated mass, stiffness, and load associated with a node from both ndl and joint files. The mod* variables are passed back with these terms removed to prevent duplicate application of shared nodal terms between elements\n\n#Input\n\nconn                connectivity list for element\njoint               joint array for nodal terms\nnodalMassTerms      listing of concentrated nodal mass terms\nnodalStiffnessTerms listing of concentrated nodal stiffness terms\nnodalLoads          listing of concentrated nodal loads terms\n\n#Output\n\nmass                array of concentrated mass associated with element\nstiff               array of concentrated stiffness associated with element\nload                array of concentrated loads associated with element\nmodJoint            modified joint object removing nodal terms that have/will be applied to the element calculations\nmodNodalMassTerms   modified nodal mass object removing nodal terms that have/will be applied to the element calculations\nmodalStiffnessTerms modified nodal stiffness object removing nodal terms that have/will be applied to the element calculations\nmodNodalLoads       modified nodal loads object removing nodal terms that have/will be applied to the element calculations\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceFEA/#OWENSFEA.ModalOutput-NTuple{6, Any}","page":"OWENSFEA","title":"OWENSFEA.ModalOutput","text":"writeOutput(freq,damp,phase1,phase2,imagComponentSign,fid)\n\nInternal, writes an output file and or formats an output for modal analysis.\n\n#Input\n\nfreq:               array of modal frequencies\ndamp:               array of modal damping ratios\nphase1:             array of in phase mode shapes\nphase2:             array of out of phase mode shapes\nimagComponentSign:  array of sign of imaginary components\nfid:                file identifier for output\n\n#Output\n\nfreqSorted:         array of sorted(by frequency) modal frequencies\ndampSorted:         array of sorted(by frequency) modal damping ratios\nimagCompSignSorted: array of sorted(by frequency) of imaginarycomponentSign array\nU_x_0: see ?Modal outputs\nU_y_0: see ?Modal outputs\nU_z_0: see ?Modal outputs\ntheta_x_0: see ?Modal outputs\ntheta_y_0: see ?Modal outputs\ntheta_z_0: see ?Modal outputs\nU_x_90: see ?Modal outputs\nU_y_90: see ?Modal outputs\nU_z_90: see ?Modal outputs\ntheta_x_90: see ?Modal outputs\ntheta_y_90: see ?Modal outputs\ntheta_z_90: see ?Modal outputs\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceFEA/#OWENSFEA.adaptiveLoadStepping-NTuple{4, Any}","page":"OWENSFEA","title":"OWENSFEA.adaptiveLoadStepping","text":"Internal, performs updates a loadstep adaptively, see ?updateLoadStep\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceFEA/#OWENSFEA.applyBC-NTuple{4, Any}","page":"OWENSFEA","title":"OWENSFEA.applyBC","text":"applyBC(Kg,Fg,BC,u,iterationType,numDofPerNode)\n\nInternal, applies boundary conditions to the stiffness matrix and load vector for a static analysis.\n\n#Input\n\nKg            assembled global stiffness matrix\nFg            assembled global load vector\nBC            struct of boundary condition information\nu             global displacement vector\niterationType for nonlinear analysis, not used in BLAST\nnumDofPerNode number of degrees of freedom per node\n\n#Output\n\nKg            global stiffness matrix with boundary conditions\nFg            global load vector with boundary condition\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceFEA/#OWENSFEA.applyBCModal-Tuple{Any, Any, Any}","page":"OWENSFEA","title":"OWENSFEA.applyBCModal","text":"applyBCModal(K,BC,numDofPerNode)\n\nInternal, applies boundary conditions to a system matrix for modal analysis\n\nInputs\n\nK:             assembled global system matrix\nBC:            struct of boundary condition information\nnumDofPerNode: number of degrees of freedom per node\n\nOutputs:\n\nKnew global system matrix with boundary conditions\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceFEA/#OWENSFEA.applyConcentratedTerms-Tuple{Any, Any}","page":"OWENSFEA","title":"OWENSFEA.applyConcentratedTerms","text":"applyConcentratedTerms(numNodes, numDOFPerNode; filename=\"none\",data=[1 \"M6\" 1 1 0.0], jointData=[])\n\nInternal, applies 6x6 concentrated nodal terms from user input.\n\n#Input\n\nfilename:   string containing nodal terms filename\ndata:       Nx5 or Nx4 array matching general [1 \"M6\" 1 1 0.0] or diagonal only [1 \"M\" 1 0.0] aligning with node, Type, dof, value, where type is M,C,K, or F\n\n#Output\n\nnodalTerms::NodalTerms: see ?NodalTerms object containing concentrated nodal data\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceFEA/#OWENSFEA.applyConstraints-Tuple{Any, Any}","page":"OWENSFEA","title":"OWENSFEA.applyConstraints","text":"Internal, this function transforms a matrix by the transformation matrix to enforce joint constraints\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceFEA/#OWENSFEA.applyConstraintsVec-Tuple{Any, Any}","page":"OWENSFEA","title":"OWENSFEA.applyConstraintsVec","text":"Internal, this function transforms a vector by the transformation matrix to enforce joint constraints\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceFEA/#OWENSFEA.assembly!-NTuple{7, Any}","page":"OWENSFEA","title":"OWENSFEA.assembly!","text":"assembly(Ke,Fe,conn,numNodesPerEl,numDOFPerNode,Kg,Fg)\n\nInternal, assembles the element matrix and load vector into the global system of equations\n\n#Input\n\nKe:            element matrix\nFe:            element vector\nconn:          element connectivity\nnumNodesPerEl: number of nodes per element\nnumDofPerNode: number of degrees of freedom per node\nKg:            global system matrix\nFg:            global load vector\n\n#Output\n\nKg:            global system matrix with assembled element\nFg:            global load vector with assembled element\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceFEA/#OWENSFEA.assemblyMatrixOnly-NTuple{5, Any}","page":"OWENSFEA","title":"OWENSFEA.assemblyMatrixOnly","text":"assemblyMatrixOnly(Ke,conn,numNodesPerEl,numDOFPerNode,Kg)\n\nInternal, assembles the element matrix into the global system of equations\n\nInputs\n\nKe:             element matrix\nconn:           element connectivity\nnumNodesPerEl:  number of nodes per element\nnumDofPerNode:  number of degrees of freedom per node\nKg:             global system matrix\n\nOutputs:\n\nKg:             global system matrix with assembled element\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceFEA/#OWENSFEA.autoCampbellDiagram-NTuple{6, Any}","page":"OWENSFEA","title":"OWENSFEA.autoCampbellDiagram","text":"frequencies = autoCampbellDiagram(FEAinputs,mymesh,myel,system,assembly,sections;     rotSpdArrayRPM = [0.0,40.0]     VTKsavename = nothing,     saveModes = [1,3,5], #must be int     saveRPM = [1,3,5], #must be int     mode_scaling = 500.0,     )\n\nAutomated Campbell Diagram Generator, this function runs the model with centrifugal stiffening for the specified RPM levels.   If FEAinputs.analysisType == \"GX\" and VTKsavename are specified, it will output paraview mode shape files at the specified save name. \n\n#Inputs\n\nFEAinputs::OWENSFEA.FEAModel: The FEA modeling options\nmymesh::OWENSFEA.Mesh: a previously generated turbine mesh\nmyel::OWENSFEA.El: the element properties associated with that mesh\nsystem::GXBeam.System: the converted GXBeam system from the mesh and el\nassembly::GXBeam.AssemblyState: the converted GXBeam assembly from the mesh and el\nsections::Array{Float64, 3}: the 3D point cloud to be converted to VTK format\nrotSpdArrayRPM::Array{Float64, 1: minimum to maximum RPM to be run, e.x. [0.0,5.0,15.0]\nVTKsavename::string: filename (with path if desired) of the VTK outputs if GX.  Set to \"nothing\" to not save.\nsaveModes::Array{Int64}: The modes to save in the VTK outputs e.x. [1,3,5] must be int\nsaveRPM::Array{Int64}: The RPMs to save in the VTK outputs e.x. [1,3,5] must be int\nmode_scaling::Float64: The mode scaling in the VTK outputs e.x. 500.0\n\n#Outputs\n\nfrequency::Array{Float64}: The output modal frequencies\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceFEA/#OWENSFEA.calcUnorm-Tuple{Any, Any}","page":"OWENSFEA","title":"OWENSFEA.calcUnorm","text":"This function calculates a relative norm between two vectors: unew and uold\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceFEA/#OWENSFEA.calculateBCMap-NTuple{4, Any}","page":"OWENSFEA","title":"OWENSFEA.calculateBCMap","text":"calculateBCMap(numpBC,pBC,numDofPerNode,reducedDofList)\n\nInternal, creates a boundary condition map between full and reduced dof listing as a result of constraints.\n\n#Input\n\nnumpBC            number of boundary conditions\npBC               array of boundary  condition data\nnumDofPerNode     number of degrees of freedom per node\nreducedDofList    array of reduced DOF numbering\n\n#Output\n\nelStorage         map for boundary conditions between full and reduced dof list\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceFEA/#OWENSFEA.calculateElement1!-NTuple{5, Any}","page":"OWENSFEA","title":"OWENSFEA.calculateElement1!","text":"Internal, general routine to calculate an element matrix\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceFEA/#OWENSFEA.calculateElementMass-NTuple{14, Any}","page":"OWENSFEA","title":"OWENSFEA.calculateElementMass","text":"Internal, calculates element mass properties.\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceFEA/#OWENSFEA.calculateLambda-Tuple{Any, Any, Any}","page":"OWENSFEA","title":"OWENSFEA.calculateLambda","text":"calculateLambda(theta1,theta2,theta3)\n\nThis function calculates a transformation matrix to transform the element degree of freedom vector (12 DOFs) from the hub frame to the element frame. The transformation matrix is constructed via the direction cosine matrices of a 3-2-1 Euler rotation sequence.\n\n#Input *theta1::float:   angle (rad) of rotation for 1st rotation of 3-2-1 sequence *theta2::float:   angle (rad) of rotation for 2nd rotation of 3-2-1 sequence *theta3::float:   angle (rad) of rotation for 3rd rotation of 3-2-1 sequence\n\n#Output *lambda::Array{<:float}:   12 x 12 transformation matrix\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceFEA/#OWENSFEA.calculateLoadVecFromDistForce-NTuple{10, Any}","page":"OWENSFEA","title":"OWENSFEA.calculateLoadVecFromDistForce","text":"calculateLoadVecFromDistForce(elementOrder,x,xloc,twist,sweepAngle,coneAngle,rollAngle,extDistF2Node,extDistF3Node,extDistF4Node)\n\nTakes in a global 6dof distributed force at two nodal points and returns the 6dof force in the element FOR\n\n#Input\n\nelementOrder:::\nx::Array{<:float}: mesh x-position\nxloc::Array{<:float}: local x-position [0 elLength]\ntwist::Array{<:float}: element twist angle (rad)\nsweepAngle::Array{<:float}: element sweep angle (rad)\nconeAngle::Array{<:float}: element cone angle (rad)\nrollAngle::Array{<:float}: element roll angle (rad)\nextDistF2Node::Array{<:float}: turbine Tangential force\nextDistF3Node::Array{<:float}: turbine Normal force\nextDistF4Node::Array{<:float}: turbine M25 moment\n\n#Output\n\nFe::Array{float}: 6x1 Force on element in element FOR\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceFEA/#OWENSFEA.calculateROM-NTuple{7, Any}","page":"OWENSFEA","title":"OWENSFEA.calculateROM","text":"calculateROM(model,mesh,el,displ,omegaVec,omegaDotVec,elStorage,countedNodes)\n\nThis function calculates a reduced order model for a conventional structural dynamics system (parked, non-rotating)\n\n#Input\n\nmodel        object containing model data\nmesh         object containing mesh data\nel           object containing elementdata\ndispl        displacement vector\nrbData:     vector containing rigid body displacement, velocity, and acceleration\nelStorage    object containing stored element data\ncountedNodes    prevents applied nodal terms from double counting\n\n#Output\n\nrom          object containing reduced order model data\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceFEA/#OWENSFEA.calculateROMGyric-NTuple{8, Any}","page":"OWENSFEA","title":"OWENSFEA.calculateROMGyric","text":"calculateROMGyric(feamodel,mesh,el,displ,omegaVec,omegaDotVec,elStorage,rom0,countedNodes)\n\nCalculates a reduced order feamodel with rotational/ rigid body motion effects\n\n#Input\n\nfeamodel:        object containing feamodel data\nmesh:         object containing mesh data\nel:           object containing elementdata\ndispl:        displacement vector\nrbData:     vector of hub frame accel (1-3), angular velocity components (4-6), and angular accleration (7-9)\nelStorage:    object containing stored element data\nrom0:         object containing parked/conventional reduced order feamodel\ncountedNodes:    prevents applied nodal terms from double counting\n\n#Output\n\nrom:          object containing reduced order feamodel data\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceFEA/#OWENSFEA.calculateReactionForceAtNode-NTuple{13, Any}","page":"OWENSFEA","title":"OWENSFEA.calculateReactionForceAtNode","text":"calculateReactionForceAtNode(nodeNum,model,mesh,el,elStorage,timeInt,dispData,displ_iter,rbData,Omega,OmegaDot,CN2H,countedNodes)\n\nInternal, calculates the reaction force at a node by post processing all element associated with a node through connectivity or joint constraints.\n\n#Input\n\nnodeNum:    node number joint constraints are desired at\nmodel:      object containing model data\nmesh:       object containing mesh data\nelStorage:  object containing stored element data\nel:         object containing element data\ntimeInt:    object containing time integration parameters\ndispData:   object containing displacement data\ndispl_iter: converged displacement solution\nrbData:     vector containing rigid body displacement, velocity, and acceleration\nOmega:      rotor speed (Hz)\nOmegaDot:   rotor acceleratin (Hz)\nCN2H:       transformation matrix from inertial frame to hub frame\ncountedNodes:  prevents nodal terms from being double counted\n\n#Output\n\ncummulativeForce:  vector containing reaction force at nodeNum\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceFEA/#OWENSFEA.calculateReducedDOFVector-Tuple{Any, Any, Any}","page":"OWENSFEA","title":"OWENSFEA.calculateReducedDOFVector","text":"Internal, searches over all DOFs in a structural model and determines and returns \"dofVector\" containing only unconstrained DOFs\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceFEA/#OWENSFEA.calculateShapeFunctions-Tuple{Any, Any, Any}","page":"OWENSFEA","title":"OWENSFEA.calculateShapeFunctions","text":"calculateShapeFunctions(elementOrder,xi,x)\n\nThis function calculates the Lagrange shape function, shape function derivative, and Jacobian to map between the local element domain and physical length of the element. The shape function derivative is defined with respect to the physical length domain. The shape functions may be linear or quadratic in order.\n\n#Input\n\nelementOrder order of element: 1 linear, 2 quadratic\nxi           guass point values to evaluate shape functions at\nx            nodal coordinates in physical length domain\n\n#Output\n\nN            shape function value at specified gauss points\np_N_x        shape function derivative w.r.t physical length domain at specified gauss points\nJac          Jacobian for mat between local element domain and physical length domain.\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceFEA/#OWENSFEA.calculateStrainForElements-NTuple{8, Any}","page":"OWENSFEA","title":"OWENSFEA.calculateStrainForElements","text":"Internal calculates element strains\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceFEA/#OWENSFEA.calculateStructureMassProps-Tuple{Any}","page":"OWENSFEA","title":"OWENSFEA.calculateStructureMassProps","text":"calculateStructureMassProps(elStorage)\n\nThis function caclulates structural mass properties of the finite element mesh (mass, moment of inertia, mass center) about the origin of the mesh coordinate system.\n\n#Input\n\nelStorage::ElStorage    see ?ElStorage, object containing arrays of stored element information\n\n#Output\n\nstructureMass::float       mass of structure\nstructureMOI::float        moment of inertia tensor of structgure\nstructureMassCenter::float center of mass of structure\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceFEA/#OWENSFEA.calculateTimoshenkoElementInitialRun-NTuple{14, Any}","page":"OWENSFEA","title":"OWENSFEA.calculateTimoshenkoElementInitialRun","text":"calculateTimoshenkoElementInitialRun(elementOrder,modalFlag,xloc,sectionProps,sweepAngle,coneAngle,rollAngle,aeroSweepAngle,x,y,z,concMassFlag,concMass,Omega)\n\nInternal, see ?initialElementCalculations, performs initial element calculations and stores them for later use and efficiency gains.\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceFEA/#OWENSFEA.calculateTimoshenkoElementNL-Tuple{Any, Any}","page":"OWENSFEA","title":"OWENSFEA.calculateTimoshenkoElementNL","text":"calculateTimoshenkoElementNL(input,elStorage;predef=nothing)\n\nInternal, performs nonlinear element calculations.\n\n#Inputs\n\ninput::ElInput: see ?ElInput\nelStorage::ElStorage: see ?ElStorage\npredef::Bool: optional, if true, mutates ElStorage to include the nonlinear strain stiffening\n\n#Outputs\n\nElOutput: see ?ElOutput\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceFEA/#OWENSFEA.calculateTimoshenkoElementNLSS-Tuple{Any}","page":"OWENSFEA","title":"OWENSFEA.calculateTimoshenkoElementNLSS","text":"calculateTimoshenkoElementNLSS(elinput)\n\nPerforms selective nonlinear element calculations. Only stiffness matrix contributions are evaluate. No other calculations are performed to facilitate efficiency gains.\n\n#Input\n\nelinput:     object containing element input\n\n#Output\n\neloutput:    object containing element data\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceFEA/#OWENSFEA.calculateTimoshenkoElementStrain-NTuple{9, Any}","page":"OWENSFEA","title":"OWENSFEA.calculateTimoshenkoElementStrain","text":"calculateTimoshenkoElementStrain(elementOrder,nlOn,xloc,sectionProps,sweepAngle,coneAngle,rollAngle,aeroSweepAngle,disp)\n\nInternal, calculates element strain for a Timoshenko element\n\n#Outputs\n\nElStrain: See ?ElStrain\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceFEA/#OWENSFEA.calculateVec1!-NTuple{4, Any}","page":"OWENSFEA","title":"OWENSFEA.calculateVec1!","text":"Internal, general routine to calculate an element vector\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceFEA/#OWENSFEA.constructReducedDispVecFromEigVec-Tuple{Any, Any, Any}","page":"OWENSFEA","title":"OWENSFEA.constructReducedDispVecFromEigVec","text":"constructReducedDispVecFromEigVec(vec1,reducedDOFList,BC)\n\nInternal, This function takes the original mode shape and modifies it to account for boundary conditions\n\nInputs\n\nvec1:\nreducedDOFList:\nBC:\n\nOutputs:\n\nvec1Red:\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceFEA/#OWENSFEA.constructReducedDispVectorMap-NTuple{6, Any}","page":"OWENSFEA","title":"OWENSFEA.constructReducedDispVectorMap","text":"Internal, creates a map of unconstrained DOFs between a full listing and reduced listing (after constraints have been applied)\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceFEA/#OWENSFEA.createJointTransform-Tuple{Any, Any, Any}","page":"OWENSFEA","title":"OWENSFEA.createJointTransform","text":"createJointTransform(joint,numNodes,numDofPerNode)\n\nInternal, calculates the JointTransform of a structural system.\n\n#Input\n\njoint:         object containing joint data\nnumModes:      number of nodes in mesh\nnumDofPerNode: number of degrees of freedom per node\n\n#Output\n\njointTransform: joint transformation matrix\nreducedDOF:     map of original DOF numbering to reduced DOF numbering\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceFEA/#OWENSFEA.createTda-NTuple{6, Any}","page":"OWENSFEA","title":"OWENSFEA.createTda","text":"Internal, creates a constraint transformation matrix for a single joint. Tda is this matrix, dDOF contains a listing of dependent global DOFs associated with this joint, and aDOF contains a listing of active global DOFs associated with this joint.\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceFEA/#OWENSFEA.determineActiveDofsFromSlaveNode-Tuple{Any, Any}","page":"OWENSFEA","title":"OWENSFEA.determineActiveDofsFromSlaveNode","text":"Internal, determines the local master DOF associated with a local slave DOF.\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceFEA/#OWENSFEA.extractFreqDamp-NTuple{7, Any}","page":"OWENSFEA","title":"OWENSFEA.extractFreqDamp","text":"extractFreqDamp(val,vec,numDOFPerNode,jointTransform,reducedDOFList,BC,analysisType)\n\nInternal, calculates the eigenvalues and vectors of a structural dynamic system\n\nInputs\n\nval:             eigenvalue\nvec:             eigenvector\nnumDOFPerNode:   number of degrees of freedom per node\njointTransform:  joint transformation matrix from reduced to full DOF list\nreducedDOFList:  listing of reduced DOFs\nBC:              boundary condition object containing boundary condition info\nanalysisType:    analysis type\n\nOutputs:\n\nfreq:        modal frequency\ndamp:        modal damping\nphase1:      in phase mode shape (real part of mode shape)\nphase2:      out of phase mode shape (imaginary part of mode shape)\nsortedModes: total, complex mode shape\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceFEA/#OWENSFEA.extractdaInfo-Tuple{Any, Any, Any}","page":"OWENSFEA","title":"OWENSFEA.extractdaInfo","text":"Internal, gets the total number of DOFs in the model, active number of DOFs in the model, and a list of slave DOFs that will be eliminated by joint constraints.\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceFEA/#OWENSFEA.findElementsAssociatedWithNodeNumber-Tuple{Any, Any, Any}","page":"OWENSFEA","title":"OWENSFEA.findElementsAssociatedWithNodeNumber","text":"findElementsAssociatedWithNodeNumber(nodeNum,conn,jointData)\n\nInternal, finds elements associated with a node number through mesh connectivity or joint constraints\n\n#Input\n\nnodeNum    node number joint constraints are desired at\nconn       object containing mesh connectivity\njointData  object containing joint information\n\n#Output\n\nelList     array containing a list of element numbers associated with nodeNum\nlocalNode  array containing the local node number that correspond to nodeNum in the list of associated elements\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceFEA/#OWENSFEA.getElementConcTerms!-NTuple{7, Any}","page":"OWENSFEA","title":"OWENSFEA.getElementConcTerms!","text":"Internal, gets the concentrated terms without double counting\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceFEA/#OWENSFEA.getGP-Tuple{Any}","page":"OWENSFEA","title":"OWENSFEA.getGP","text":"getGP(numGP)\n\nInternal, defines gauss point coordinates in a local element frame and the associated weights for Gaussian quadrature numerical integration.\n\n#Input\n\nnumGP:  number of quad points used for integration\n\n#Output\n\nxi:     list of quad point coordinates in local element frame\nweight: associated weights for quad point coordinate\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceFEA/#OWENSFEA.getNodeMaps-NTuple{7, Any}","page":"OWENSFEA","title":"OWENSFEA.getNodeMaps","text":"Internal, gets node mapping\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceFEA/#OWENSFEA.initialElementCalculations-Tuple{Any, Any, Any}","page":"OWENSFEA","title":"OWENSFEA.initialElementCalculations","text":"initialElementCalculations(feamodel,el,mesh)\n\nperforms initial element calculation for use later in analysis for efficiency gains.\n\nInputs\n\nfeamodel::FEAmodel: see ?Feamodel\nel::El: see ?El\nmesh::Mesh: see ?Mesh\n\nOutputs:\n\nelStorage:ElStorage: see ?ElStorage\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceFEA/#OWENSFEA.interpolateVal-Tuple{Any, Any}","page":"OWENSFEA","title":"OWENSFEA.interpolateVal","text":"Internal, linear interpolation\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceFEA/#OWENSFEA.linearAnalysisModal-NTuple{6, Any}","page":"OWENSFEA","title":"OWENSFEA.linearAnalysisModal","text":"Internal, see ?modal\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceFEA/#OWENSFEA.makeBCdata-NTuple{5, Any}","page":"OWENSFEA","title":"OWENSFEA.makeBCdata","text":"makeBCdata(pBC,numNodes,numDofPerNode,reducedDOFList,jointTransform)\n\nInternal, usese the pBC matrix and calculates/stores boundary condition data\n\n#Input\n\npBC      See ?FEAModel.pBC\nnumNodes        number of nodes in structural model\nnumDofPerNode   number of degrees of freedom per node\nreducedDOFList  joint transformation matrix from reduced to full DOF list\njointTransform  listing of reduced DOFs\n\n#Output\n\nBC:BC_struct see ?BC_struct\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceFEA/#OWENSFEA.mapMatrixNonSym-Tuple{Any}","page":"OWENSFEA","title":"OWENSFEA.mapMatrixNonSym","text":"Internal, function to form total stifness matrix and transform to desired DOF mapping\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceFEA/#OWENSFEA.mapMatrixNonSym2-NTuple{36, Any}","page":"OWENSFEA","title":"OWENSFEA.mapMatrixNonSym2","text":"Internal, function to form total stifness matrix and transform to desired DOF mapping\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceFEA/#OWENSFEA.mapVector-Tuple{Any}","page":"OWENSFEA","title":"OWENSFEA.mapVector","text":"Internal, forms total force vector and transform to desired DOF mapping\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceFEA/#OWENSFEA.modal-Tuple{Any, Any, Any}","page":"OWENSFEA","title":"OWENSFEA.modal","text":"modal(feamodel,mesh,el;Omega=0.0,displ=zeros(mesh.numNodes*6),OmegaStart=0.0,returnDynMatrices=false)\n\nModal analysis\n\nInputs\n\nfeamodel::FEAModel: see ?FEAModel\nmesh::Mesh: see ?Mesh\nel::El: see ?El\nOmega::float: Rotational rate in Hz\ndispl::Array{<:float}: zeros(mesh.numNodes*6) initial (warm start) displacements for each dof\nOmegaStart::float: rotor speed (Hz) from previous analysis if stepping through various rotor speeds, may be useful in load stepping\nreturnDynMatrices::Bool: Flag to save linearized K/C/M matrices for the design\n\nOutputs:\n\nfreq::Array{<:float}: sorted modal frequencies (Hz)\ndamp::Array{<:float}: sorted modal damping\nimagCompSign::Array{<:float}: sign of imaginary component of eigenvalues\nU_x_0::Array{<:float}: NnodesxNmodes in-phase mode shape x\nU_y_0::Array{<:float}: NnodesxNmodes in-phase mode shape y\nU_z_0::Array{<:float}: NnodesxNmodes in-phase mode shape z\ntheta_x_0::Array{<:float}: NnodesxNmodes in-phase mode shape rotation about x\ntheta_y_0::Array{<:float}: NnodesxNmodes in-phase mode shape rotation about y\ntheta_z_0::Array{<:float}: NnodesxNmodes in-phase mode shape rotation about z\nU_x_90::Array{<:float}: NnodesxNmodes out-of-phase mode shape x\nU_y_90::Array{<:float}: NnodesxNmodes out-of-phase mode shape y\nU_z_90::Array{<:float}: NnodesxNmodes out-of-phase mode shape z\ntheta_x_90::Array{<:float}: NnodesxNmodes out-of-phase mode shape rotation about x\ntheta_y_90::Array{<:float}: NnodesxNmodes out-of-phase mode shape rotation about y\ntheta_z_90::Array{<:float}: NnodesxNmodes out-of-phase mode shape rotation about z\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceFEA/#OWENSFEA.reducedOrderModel-NTuple{5, Any}","page":"OWENSFEA","title":"OWENSFEA.reducedOrderModel","text":"reducedOrderModel(elStorage,feamodel,mesh,el,displ)\n\nThis function executes a reduced order model analysis.\n\n#Input\n\nelStorage      object containing stored element matrices\nfeamodel          object containing feamodel information\nmesh           object containing mesh information\nel             object containing element information\ndispl          displacement vector for use in pre-stressed analysis\n\n#Output\n\nrom            object containing a reduced order feamodel\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceFEA/#OWENSFEA.setInitialConditions-Tuple{Any, Any, Any}","page":"OWENSFEA","title":"OWENSFEA.setInitialConditions","text":"setInitialConditions(initCond,u,numDOFPerNode)\n\nsets initial conditions\n\n#Input\n\ninitCond: array containing initial conditions                initCond(i,1) node number for init cond i                initCond(i,2) local DOF number for init cond i                initCond(i,3) value for init cond i\nu: displacement vector for each dof\nnumDOFPerNode: number of degrees of freedom per node\n\n#Output\n\nu: displacement vector modified for initial conditions\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceFEA/#OWENSFEA.setPrescribedConditions-Tuple{Any}","page":"OWENSFEA","title":"OWENSFEA.setPrescribedConditions","text":"prescribed_conditions = setPrescribedConditions(mesh;pBC=zeros(2,2),Fexternal=[],ForceDof=[])\n\nInternal, maps OWENS boundary conditions and applied forces to the GXBeam PrescribedConditions input\n\n#Input\n\nmesh::FEAModel.mesh: Input turbine mesh\npBC::FEAModel.BC.pBC: Boundary conditions\nFexternal::Array{Float64}: Applied forces to the mesh, 1D array ordered node 1 Dof 1-6, node 2 Dof 1-2, etc.\nForceDof::Array{Float64}: Degrees of freedom aligned with Fexternal, currently is unused, assumes Fexternal uses the full DOF array.\n\n#Output\n\nprescribed_conditions::GXBeam.PrescribedConditions: the boundary conditions/applied forces used by GXBeam see ?GXBeam.PrescribedConditions\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceFEA/#OWENSFEA.staticAnalysis-NTuple{7, Any}","page":"OWENSFEA","title":"OWENSFEA.staticAnalysis","text":"staticAnalysis(feamodel,mesh,el,displ,Omega,OmegaStart,elStorage;     reactionNodeNumber=1, OmegaDot=0.0, Fdof=[1], Fexternal=[0.0])\n\nThis function performs a static analysis and returns displacement values and a flag denoting successful/unsuccessful analysis\n\n#Inputs\n\nfeamodel:          object containing feamodel information\nmesh:           object containing mesh information\nel:             object containing element information\ndispl:          displacement vector for use in pre-stressed analysis\nOmega:          rotor speed (Hz)\nOmegaStart:     rotor speed (Hz) from previous analysis if stepping through various rotor speeds, may be useful in load stepping\nelStorage:      previously calculated element system matrices\nreactionNodeNumber::Int: optional, node at which to calculate reaction force\nOmegaDot::Float: Steady State Rotational Acceleration\nFdof::Array{<:Int}: Global Dofs where Fexternal is acting, where max dof = nelem*ndof\nFexternal{<:Float}: Forces or moments associated with the Fdofs specified\n\n#Outputs\n\ndispl:                    vector of displacemetns\nstaticAnalysisSuccessful: boolean flag denoting successful static analysis\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceFEA/#OWENSFEA.structuralDynamicsTransient-NTuple{13, Any}","page":"OWENSFEA","title":"OWENSFEA.structuralDynamicsTransient","text":"structuralDynamicsTransient(feamodel,mesh,el,dispData,Omega,OmegaDot,time,delta_t,elStorage,Fexternal,Fdof,CN2H,rbData)\n\nperforms unsteady structural dynamics analysis\n\nInputs\n\nfeamodel::: object containing feamodel data\nmesh::: object containing mesh data\nel::: object containing element data\ndispData::: object containing displacement data\nOmega::: rotor speed (Hz)\nOmegaDot::: rotor acceleratin (Hz)\ntime::: current simulation time\ndelta_t::: time step size\nelStorage::: object containing stored element data\nFexternal::: vector containing external force values\nFdof::: vector containing global DOF numbering associated with external force values\nCN2H::: transformation matrix from inertial frame to hub frame\nrbData::: vector containing rigid body displacement, velocity, and acceleration\n\nOutputs:\n\nelStrain::ElStrain: see ?ElStrain strain for element at end of time step\ndispOut::DispOut: see ?DispOut displacement data at end of time step\nFReaction_sp1::: vector containing reaction force at turbine base at end of time step\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceFEA/#OWENSFEA.structuralDynamicsTransientROM-NTuple{14, Any}","page":"OWENSFEA","title":"OWENSFEA.structuralDynamicsTransientROM","text":"structuralDynamicsTransientROM(feamodel,mesh,el,dispData,Omega,OmegaDot,time,delta_t,elStorage,rom,Fexternal,Fdof,CN2H,rbData)\n\nPerforms transient structural dynamics analysis using a reduced order feamodel (ROM).\n\n#Input\n\nfeamodel:      object containing feamodel data\nmesh:       object containing mesh data\nel:         object containing element data\ndispData:   object containing displacement data\nOmega:      rotor speed (Hz)\nOmegaDot:   rotor acceleratin (Hz)\ntime:       current simulation time\ndelta_t:    time step size\nelStorage:  object containing stored element data\nrom:        object containing reduced order feamodel represnetation\nFexternal:  vector containing external force values\nFdof:       vector containing global DOF numbering associated with external force values\nCN2H:       transformation matrix from inertial frame to hub frame\nrbData:     vector containing rigid body displacement, velocity, and acceleration\n\n#Output\n\ndispOut:       object containing displacement data at end of time step\nFReaction_sp1: vector containing reaction force at turbine base at end of time step\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceFEA/#OWENSFEA.timeIntegrateSubSystemEff-NTuple{8, Any}","page":"OWENSFEA","title":"OWENSFEA.timeIntegrateSubSystemEff","text":"timeIntegrateSubSystemEff(M,K,C,F,timeInt,u,udot,uddot)\n\nPerforms integration of a system using the Newmark-Beta method(constant-average acceleration sceheme). The integration parameters are calculated before hand and store in the timeInt object.\n\n#Input\n\nM        system mass matrix\nK        system sttiffness matrix\nC        system damping matrix\nF        system force vector\ntimeInt  object containing time integraton parameters\nu        displacement at beginning of time step\nudot     velocity at beginning of time step\nuddot    acceleration at beginning of time step\n\n#Output\n\nunp1:        displacement at end of time step\nudotnp1:     velocity at end of time step\nuddotnp1:    acceleration at end of time step\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceFEA/#OWENSFEA.updateLoadStep-NTuple{7, Any}","page":"OWENSFEA","title":"OWENSFEA.updateLoadStep","text":"updateLoadStep(iterationCount,loadStepParams,loadStep,loadStepPrev,loadStepCount,displCopy,displ)\n\nUpdates the load stepping parameter whether through means of adaptive loadstepping or a specified load step profile.\n\n#Input\n\niterationCount      number of iterations for current load step\nloadStepParams      struct containing load step parameters\nloadStep            load step value for current load step\nloadStepPrev        load step value for previous load st ep\nloadStepCount       number of load steps performed up to this point\ndisplPrev           converged displacement vector form previous load step\ndispl               displacement vector at current load step\n\n#Output\n\nloadStep            new load step value\nloadStepPrev        load step value for previous load step\ndispl               most up to date displacement vector in load stepping procedure\ndisplPrev           displacement vector at end of previous load step\nstaticAnalysisSuccessful boolean flag, true if load step was completed successfully\nstaticAnalysisComplete   boolean flag, true if analysis is complete\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceOpenFASTWrappers/#OWENSOpenFASTWrappers","page":"OWENSOpenFASTWrappers","title":"OWENSOpenFASTWrappers","text":"","category":"section"},{"location":"reference/referenceOpenFASTWrappers/#Types-and-functions","page":"OWENSOpenFASTWrappers","title":"Types and functions","text":"","category":"section"},{"location":"reference/referenceOpenFASTWrappers/#OWENSOpenFASTWrappers.Environment","page":"OWENSOpenFASTWrappers","title":"OWENSOpenFASTWrappers.Environment","text":"Environment(rho::TF1, dt::TF2, steplast::TAI) Environment(rho) = Environment(rho)\n\nContains specications for turbine environment/operating conditions as well as some backend memory\n\nInputs\n\nrho::TF1: Working fluid density (kg/m^3)\ndt::TF2: timestep for ADI\nnum_channels::TI1: number of output channels from AD15\nsteplast::TAI: prior simulation step index, used for unsteady wake propogation\n\nOutputs:\n\nnone:\n\n\n\n\n\n","category":"type"},{"location":"reference/referenceOpenFASTWrappers/#OWENSOpenFASTWrappers.Structure","page":"OWENSOpenFASTWrappers","title":"OWENSOpenFASTWrappers.Structure","text":"Structure\n\nContains the position and orientation info passed to AD15.  These positions are all in global and include the turbine RefPos.\n\nInputs:\n\nhubPos::TAF1:\nhubOrient::TAF2:\nhubVel::TAF3:\nhubAcc::TAF4:\nnacPos::TAF5:\nnacOrient::TAF6:\nnacVel::TAF7:\nnacAcc::TAF8:\nrootPos::TAF9:\nrootOrient::TAF10:\nrootVel::TAF11:\nrootAcc::TAF12:\nmeshPos::TAF13:\nmeshOrient::TAF14:\nmeshVel::TAF15:\nmeshAcc::TAF16:\n\nOutputs:\n\nnone:\n\n\n\n\n\n","category":"type"},{"location":"reference/referenceOpenFASTWrappers/#OWENSOpenFASTWrappers.adiCalcOutput-Tuple{Any, Any}","page":"OWENSOpenFASTWrappers","title":"OWENSOpenFASTWrappers.adiCalcOutput","text":"adiCalcOutput( )\n\ncalls AeroDynInflowC_CalcOutput to calculate resulting loads.  Call this only after SetRotorMotion on all rotors/turbines.\n\nInputs:\n\ntime::c_double: current timestep\n\nnum_channels::int: number of output channels\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceOpenFASTWrappers/#OWENSOpenFASTWrappers.adiGetRotorLoads-Tuple{Any}","page":"OWENSOpenFASTWrappers","title":"OWENSOpenFASTWrappers.adiGetRotorLoads","text":"adiGetRotorLoads(iturb; )\n\nGets the loads for a single turbine rotor\n\nInputs:\n\niturb::int:         required, current turbine number\n\nOutputs:\n\nmeshFrcMom::Array(float): loads from ADI at mesh nodes\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceOpenFASTWrappers/#OWENSOpenFASTWrappers.adiInit-Tuple{Any}","page":"OWENSOpenFASTWrappers","title":"OWENSOpenFASTWrappers.adiInit","text":"adiInit( output_root_name ; )\n\ncalls aerodyninflowinit to initialize AeroDyn and InflowWind together\n\nInputs:\n\nad_input_file_passed::int: flag to indicate the AD15 input file is passed as a string 0=false, 1=true (set to false if passing input file name instead, NOT SUPPORTED YET)\nad_input_file::string: name of input file for AD15 – this is read by julia and passed to AD15\nifw_input_file_passed::int: flag to indicate the InflowWind input file is passed as a string 0=false, 1=true (set to false if passing input file name instead, NOT SUPPORTED YET)\nifw_input_file::string: name of input file for InflowWind – this is read by julia and passed to InflowWind\ngravity::float:     optional, gravity value (default: 9.80665 m/s^2)\ndefFldDens::float:  optional, air density (default: 1.225 kg/m^3)\ndefKinVisc::float:  optional, kinematic viscosity of working fluid (default: 1.464E-05 m^2/s)\ndefSpdSound::float: optional, speed of sound in working fluid (default: 335.0 m/s)\ndefPatm::float:     optional, atmospheric pressure (default:  103500.0 Pa) [used only for an MHK turbine cavitation check]\ndefPvap::float:     optional, vapour pressure of working fluid (default: 1700.0 Pa) [used only for an MHK turbine cavitation check]\nWtrDpth::float:     optional, water depth (default: 0.0 m) [used only for an MHK turbine]\nMSL2SWL::float:     optional, offset between still-water level and mean sea level (default: 0.0 m) [positive upward, used only for an MHK turbine]\nstoreHHVel::int:   optional, internal parameter for adi_library.  Exposed for convenience, but not needed. [0=false, 1=true]\nWrVTK::int:         optional, write VTK output files at all timesteps to visualize AeroDyn 15 meshes [0 none (default), 1 ref, 2 motion]\nWrVTK_Type::int:    optional, write VTK output files as [1 surfaces (default), 2 lines, 3 both]\nVTKNacDim::Array(float*6)   optional, Nacelle Dimension for VTK visualization x0,y0,z0,Lx,Ly,Lz (m)\nVTKHubRad::float:   optional, HubRadius for VTK visualization (m)\nwrOuts::int:        optional, file format for writing outputs [0 none (default), 1 txt, 2 binary, 3 both]\nDT_Outs::float64:   optional, timestep for outputs to file [0.0 (default) for every timestep]\ninterp_order::int: optional, interpolation order used internally [1 first order (default), 2 second order]\ndt::float64:        required, timestep for AD15 (needed for setting internal constants)\nt_max::float:       required, total expected simulation time – used only for setting VTK counter width\n\nOutputs:\n\nnum_channels::int: number of output channels\nchannel_names::string: string of output channel names from ADI\nchannel_units::string: string of output channel units from ADI\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceOpenFASTWrappers/#OWENSOpenFASTWrappers.adiPreInit-Tuple{Any, Any, Any}","page":"OWENSOpenFASTWrappers","title":"OWENSOpenFASTWrappers.adiPreInit","text":"adiPreInit(adilib_filename numTurbines transposeDCM)\n\nDoes some pre-initializing of the ADI library to setup arrays for each turbine\n\nInputs:\n\nadilib_filename::string: path and name of AeroDyn-Inflow dynamic library\nnumTurbines::int: required, number of turbines to setup ADI to handle\ntransposeDCM::int: required, transpose DCM internally in ADI to match calling code convention for direction cosine matrices (default: 1==true)\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceOpenFASTWrappers/#OWENSOpenFASTWrappers.adiSetRotorMotion-NTuple{18, Any}","page":"OWENSOpenFASTWrappers","title":"OWENSOpenFASTWrappers.adiSetRotorMotion","text":"adiSetRotorMotion(iturb; )\n\nSets the motions for a single turbine rotor\n\nInputs:\n\niturb::int:         required, current turbine number\nHubPos::Array(float): required, (x,y,z) position of hub\nHubOrient::Array(float): required, orientation of hub as 9 element vector of flattened DCM\nHubVel::Array(float): required, (TVx,TVy,TVz,RVx,RVy,RVz) velocity of hub, does not include rotational velocity, so this is extra like from a platform\nHubAcc::Array(float): required, (TAx,TAy,TAz,RAx,RAy,RAz) acceleration of hub, does not include rotational accel, so this is extra like from a platform\nNacPos::Array(float): required, (x,y,z) position of nacelle\nNacOrient::Array(float): required, orientation of nacelle as 9 element vector of flattened DCM\nNacVel::Array(float): required, (TVx,TVy,TVz,RVx,RVy,RVz) velocity of nacelle\nNacAcc::Array(float): required, (TAx,TAy,TAz,RAx,RAy,RAz) acceleration of nacelle\nRootPos::Array(float): required, size (numBlades,3) position vectors of roots\nRootOrient::Array(float): required, size (numBlades,9) orientation DCMs flattened to array of 9 element vectors\nRootVel::Array(float): required, size (numBlades,6) velocity vectors of roots\nRootAcc::Array(float): required, size (numBlades,6) acceleration vectors of roots\nnumMeshNodes::Array(int): required, number of structural mesh points (total across all blades)\nMeshPos::Array(float): required, size (sum(numMeshNodes),3) position vectors of mesh points\nMeshOrient::Array(float): required, size (sum(numMeshNodes),9) orientation DCMs flattened to array of 9 element vectors\nMeshVel::Array(float): required, size (sum(numMeshNodes),6) velocity vectors of mesh points\nMeshAcc::Array(float): required, size (sum(numMeshNodes),6) acceleration vectors of mesh points\n\nOutputs:\n\nnone:\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceOpenFASTWrappers/#OWENSOpenFASTWrappers.adiSetupRotor-Tuple{Any}","page":"OWENSOpenFASTWrappers","title":"OWENSOpenFASTWrappers.adiSetupRotor","text":"adiSetupRotor(iturb; )\n\nSets the initial locations of a single rotor (root orientations/positions etc)\n\nInputs:\n\niturb::int: required, current turbine number\nisHAWT::bool: required, false: VAWT or cross-flow turbine, true: HAWT\nintTurbPos::Array(float): required, (x,y,z) position of turbine\ninitHubPos::Array(float): required, (x,y,z) position of hub\ninitHubOrient::Array(float): required, orientation of hub as 9 element vector of flattened DCM\ninitNacellePos::Array(float): required, (x,y,z) position of nacelle\ninitNacelleOrient::Array(float): required, orientation of nacelle as 9 element vector of flattened DCM\nnumBlades::int: required, number of blades\ninitRootPos::Array(float): required, size (numBlades,3) position vectors of roots\ninitRootOrient::Array(float): required, size (numBlades,9) orientation DCMs flattened to array of 9 element vectors\nnumMeshNodes::Array(int): required, number of structural mesh points (total across all blades)\ninitMeshPos::Array(float): required, size (sum(numMeshNodes),3) position vectors of mesh points\ninitMeshOrient::Array(float): required, size (sum(numMeshNodes),9) orientation DCMs flattened to array of 9 element vectors\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceOpenFASTWrappers/#OWENSOpenFASTWrappers.adiUpdateStates-Tuple{Any, Any}","page":"OWENSOpenFASTWrappers","title":"OWENSOpenFASTWrappers.adiUpdateStates","text":"adiUpdateStates( )\n\ncalls AeroDynInflowC_UpdateStates to step ADI forward to the next timestep  Call this only after SetRotorMotion on all rotors/turbines.\n\nInputs:\n\ntime::c_double: current timestep\n\ntime_next::c_double: next timestep\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceOpenFASTWrappers/#OWENSOpenFASTWrappers.advanceAD15-Tuple{Any, Any, Any}","page":"OWENSOpenFASTWrappers","title":"OWENSOpenFASTWrappers.advanceAD15","text":"advanceAD15(t_new;ts=2*pi/(turbine.omega[1]*turbine.ntheta))\n\nRuns a previously initialized aero model (see ?setupTurb) in the unsteady mode (can be repeateadly called, or called for a specific time, or repeatedly called for sections of time)\n\nInputs\n\nt_new::float: new time (s); will run from last time specified from the last call, to the current time specified, or from t=ts if the first time called\nmesh:::     OWENSFEA mesh for the turbine structure\nazi:::      hub azimuth (radians)\ndt::float:  optional timestep\n\nOutputs:\n\nn_steps: number timesteps taken\nFx: Array(sum(numMeshNodes),ntheta) Turbine Fx (N)\nFy: Array(sum(numMeshNodes),ntheta) Turbine Fy (N)\nFz: Array(sum(numMeshNodes),ntheta) Turbine Fz (N)\nMx: Array(sum(numMeshNodes),ntheta) Turbine Mx (N-m)\nMy: Array(sum(numMeshNodes),ntheta) Turbine My (N-m)\nMz: Array(sum(numMeshNodes),ntheta) Turbine Mz (N-m)\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceOpenFASTWrappers/#OWENSOpenFASTWrappers.createGeneralTransformationMatrix-Tuple{Any, Any}","page":"OWENSOpenFASTWrappers","title":"OWENSOpenFASTWrappers.createGeneralTransformationMatrix","text":"createGeneralTransformationMatrix(angleArray,axisArray)\n\nCalculates the transformation matrix assocaited with a general Euler rotation sequence.\n\n#Input\n\nangleArray:      = array of angles for Euler rotation sequence\naxisArray:       = array of axis of rotations for Euler rotation\n\n#Output\n\ndcmTotal:        = transformation matrix of specified euler rotation sequence\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceOpenFASTWrappers/#OWENSOpenFASTWrappers.createSingleRotationDCM-Tuple{Any, Any}","page":"OWENSOpenFASTWrappers","title":"OWENSOpenFASTWrappers.createSingleRotationDCM","text":"createSingleRotationDCM(angleDeg,axisNum)\n\nCreates a direction cosine matrix (dcm) associated with a rotation of angleDeg about axisNum.\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceOpenFASTWrappers/#OWENSOpenFASTWrappers.deformAD15-NTuple{10, Any}","page":"OWENSOpenFASTWrappers","title":"OWENSOpenFASTWrappers.deformAD15","text":"deformAD15(u_j,udot_j,uddot_j,azi,Omega_rad,OmegaDot_rad,hubPos,hubAngle,hubVel,hubAcc)\n\nSets the inputs for AD15.\n\nInputs\n\nu_j:            mesh displacements – in hub coordinates, (m,rad)\nudot_j:         mesh velocity      – in hub coordinates, (m/s,rad/s)\nuddot_j:        mesh velocity      – in hub coordinates, (m/s,rad/s)\nazi:            current azimuth (rad)\nOmega_rad:      angular velocity of hub about hub axis (rad/s)\nOmegaDot_rad:   angular acceleration of hub about hub axis (rad/s^2)\nhubPos:         current global hubPos (x,y,z) vector (m)\nhubAngle:       3 angle set for hub orientation (rad), no rotation from spinning\nhubVel:         hub velocity in global coords, 6-vector (m/s,rad/s), does not include rotational velocity, so this is extra like from a platform\nhubAcc:         hub acceleration in global coords, 6-vector (m/s^2,rad/s^2), does not include rotational accel, so this is extra like from a platform\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceOpenFASTWrappers/#OWENSOpenFASTWrappers.endTurb-Tuple{}","page":"OWENSOpenFASTWrappers","title":"OWENSOpenFASTWrappers.endTurb","text":"End ADI and clear data\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceOpenFASTWrappers/#OWENSOpenFASTWrappers.frame_convert-Tuple{Any, Any}","page":"OWENSOpenFASTWrappers","title":"OWENSOpenFASTWrappers.frame_convert","text":"frameconvert(initframevals, transmat)\n\nInternal, transfers 6 DOFs element-wise to a new reference frame\n\nInput\n\ninit_frame_vals::Vector{<:float}: Values in 6 degrees of freedom in the initial reference frame\ntrans_mat::Array{<:float}: Transformation matrix to the output reference frame\n\nOutput\n\nout_frame_vals: Values in 6 degrees of freedom in the output reference frame\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceOpenFASTWrappers/#OWENSOpenFASTWrappers.getAD15MeshDCM-NTuple{4, Any}","page":"OWENSOpenFASTWrappers","title":"OWENSOpenFASTWrappers.getAD15MeshDCM","text":"getAD15MeshDCM(turbine,u_j,azi,hubAngle)\n\nExtract the mesh points orientations for all the AD15 blades   ordering here is important       1. root to tip of blades,        in blade order       2. root to tip of bottom struts, in blade order       3. root to tip of top    struts, in blade order\n\nInputs\n\nturbine:    turbine data storage\nu_j:        mesh displacements – in hub coordinates, (m,rad)\nazi:        current azimuth (rad)\nhubAngle:   3 angle set for hub orientation (rad), no rotation from spinning\n\n#FIXME: add averaging of orientations to get nodes within blade/strut\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceOpenFASTWrappers/#OWENSOpenFASTWrappers.getAD15MeshPos-NTuple{6, Any}","page":"OWENSOpenFASTWrappers","title":"OWENSOpenFASTWrappers.getAD15MeshPos","text":"getAD15MeshPos(turbine,u_j,azi,nacPos,hubPos,hubAngle)\n\nExtract the mesh points for all the AD15 blades   ordering here is important       1. root to tip of blades,        in blade order       2. root to tip of bottom struts, in blade order       3. root to tip of top    struts, in blade order\n\nInputs\n\nturbine:    turbine data storage\nu_j:        mesh displacements – in hub coordinates, (m,rad)\nazi:        current azimuth (rad)\nhubPos:     current global hubPos (x,y,z) vector (m)\nnacPos:     current global nacPos (x,y,z) vector (m)\nhubAngle:   3 angle set for hub orientation (rad) , no rotation from spinning\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceOpenFASTWrappers/#OWENSOpenFASTWrappers.getAD15MeshVelAcc-NTuple{12, Any}","page":"OWENSOpenFASTWrappers","title":"OWENSOpenFASTWrappers.getAD15MeshVelAcc","text":"getAD15MeshVelAcc(turbine,meshPos,udotj,uddotj,azi,Omegarad,OmegaDotrad,nacPos,hubPos,hubAngle,hubVel,hubAcc)\n\nExtract the mesh velocities and accelerations for all the AD15 blades   ordering here is important       1. root to tip of blades,        in blade order       2. root to tip of bottom struts, in blade order       3. root to tip of top    struts, in blade order\n\nInputs\n\nturbine:        turbine data storage\nrootPos:        root positions from call to getAD15MeshPos\nu_j:            mesh displacements – in hub coordinates, (m,rad)\nudot_j:         mesh velocity      – in hub coordinates, (m/s,rad/s)\nuddot_j:        mesh velocity      – in hub coordinates, (m/s,rad/s)\nazi:            current azimuth (rad)\nOmega_rad:      angular velocity of hub about hub axis (rad/s)\nOmegaDot_rad:   angular acceleration of hub about hub axis (rad/s^2)\nhubPos:         current global hubPos (x,y,z) vector (m)\nnacPos:         current global nacPos (x,y,z) vector (m)\nhubAngle:       3 angle set for hub orientation (rad), no rotation from spinning\nhubVel:         hub velocity in global coords (m/s,rad/s), does not include rotational velocity, so this is extra like from a platform\nhubAcc:         hub acceleration in global coords (m/s^2,rad/s^2), does not include rotational accel, so this is extra like from a platform\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceOpenFASTWrappers/#OWENSOpenFASTWrappers.getAD15numMeshNodes-Tuple{Any}","page":"OWENSOpenFASTWrappers","title":"OWENSOpenFASTWrappers.getAD15numMeshNodes","text":"getAD15numMeshNodes(bladeIdx)\n\nFind the number of mesh points we will pass\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceOpenFASTWrappers/#OWENSOpenFASTWrappers.getRootDCM-NTuple{4, Any}","page":"OWENSOpenFASTWrappers","title":"OWENSOpenFASTWrappers.getRootDCM","text":"getRootDCM(turbine,u_j,azi,hubAngle)\n\nNote on angles     The OWENSFEA mesh in OWENS uses +X as the blade/strut long axis.  In AeroDyn, the blade axis is +Z.  So for transforming the     blades from OWENSFEA mesh coordinates, first rotate by -90 degrees about Y, then do the 3,2,1 coordinate transforms with     (Twist,Theta,Psi) = (Rz,Ry,Rx) = (Yaw,Pitch,Roll)         Psid   – rotation about Z axis    – Yaw (Rz)     – degrees         Thetad – rotation about Y axis    – Pitch (Ry)   – degrees         Twist_d – rotation about X axis    – Roll (Rx)    – degrees     The rotation sequence is Roll –> Pitch –> Yaw.  In rotation matrix form, it is R = RzRyRx (a [3,2,1] matrix order).\n\nInputs\n\nturbine:    turbine data storage\nu_j:        mesh displacements – in hub coordinates, (m,rad)\nazi:        current azimuth (rad)\nhubAngle:   3 angle set for hub orientation (rad), no rotation from spinning\n\n#FIXME: add averaging of orientations to get nodes within blade/strut\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceOpenFASTWrappers/#OWENSOpenFASTWrappers.getRootPos-NTuple{6, Any}","page":"OWENSOpenFASTWrappers","title":"OWENSOpenFASTWrappers.getRootPos","text":"getRootPos(turbine,u_j,azi,nacPos,hubPos,hubAngle)\n\nExtract the root positions for all ADI blades\n\nInputs\n\nturbine:    turbine data storage\nu_j:        mesh displacements – in hub coordinates, (m,rad)\nazi:        current azimuth (rad)\nnacPos:     current global nacPos (x,y,z) vector (m)\nhubPos:     current global hubPos (x,y,z) vector (m)\nhubAngle:   3 angle set for hub orientation (rad), no rotation from spinning\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceOpenFASTWrappers/#OWENSOpenFASTWrappers.getRootVelAcc-NTuple{12, Any}","page":"OWENSOpenFASTWrappers","title":"OWENSOpenFASTWrappers.getRootVelAcc","text":"getRootVelAcc(turbine,rootPos,udotj,uddotj,azi,Omegarad,OmegaDotrad,nacPos,hubPos,hubAngle,hubVel,hubAcc)\n\nExtract the root velocities and accelerations for all ADI blades\n\nInputs\n\nturbine:        turbine data storage\nrootPos:        root positions from call to getRootPos\nazi:            current azimuth (rad)\nOmega_rad:      angular velocity of hub about hub axis (rad/s)\nOmegaDot_rad:   angular acceleration of hub about hub axis (rad/s^2)\nnacPos:         current global nacPos (x,y,z) vector (m)\nhubPos:         current global hubPos (x,y,z) vector (m)\nhubAngle:       3 angle set for hub orientation (rad) , no rotation from spinning\nhubVel:         hub velocity in global coords, 6-vector (m/s,rad/s), does not include rotational velocity, so this is extra like from a platform\nhubAcc:         hub acceleration in global coords, 6-vector (m/s^2,rad/s^2), does not include rotational accel, so this is extra like from a platform\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceOpenFASTWrappers/#OWENSOpenFASTWrappers.ifwcalcoutput-Tuple{Any, Any}","page":"OWENSOpenFASTWrappers","title":"OWENSOpenFASTWrappers.ifwcalcoutput","text":"ifwcalcoutput(position,time)\n\ncalls inflow wind clacoutput\n\nInputs\n\nposition::Array(float): x, y, z sample position (m)\ntime::float: sample time (s)\n\nOutputs:\n\nvelocities: x, y, z velocity at sample position\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceOpenFASTWrappers/#OWENSOpenFASTWrappers.ifwend-Tuple{}","page":"OWENSOpenFASTWrappers","title":"OWENSOpenFASTWrappers.ifwend","text":"ifwend()\n\ncalls inflow wind end function and cleanup\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceOpenFASTWrappers/#OWENSOpenFASTWrappers.ifwinit-Tuple{}","page":"OWENSOpenFASTWrappers","title":"OWENSOpenFASTWrappers.ifwinit","text":"ifwinit(inflowlib_filename ;HWindSpeed=6.87,turbsim_filename=\"path/test.bts\")\n\ncalls inflow wind init\n\nInputs\n\ninflowlib_filename::string: path and name of inflow-wind dynamic library\nHWindSpeed::float: optional, backup steady windspeed (m/s)\nturbsim_filename::string: path and name of turbsim data e.g. \"path/test.bts\"\n\nOutputs:\n\nnone:\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceOpenFASTWrappers/#OWENSOpenFASTWrappers.setRotorMotion-Tuple{Any}","page":"OWENSOpenFASTWrappers","title":"OWENSOpenFASTWrappers.setRotorMotion","text":"setRotorMotion(iturb,turbstruct\n\nSet the rotor motion for one turbine\n\nInputs\n\niturb::int:         required, current turbine number\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceOpenFASTWrappers/#OWENSOpenFASTWrappers.setupTurb-NTuple{12, Any}","page":"OWENSOpenFASTWrappers","title":"OWENSOpenFASTWrappers.setupTurb","text":"setupTurb(adilib,adinputfile,ifwinputfile,adirootname,bldx,bldz,B;     rho = 1.225,     gravity     =   9.80665,     defKinVisc  = 1.464E-05,     defSpdSound =     335.0,     defPatm     =  103500.0,     defPvap     =    1700.0,     WtrDpth     =       0.0,     MSL2SWL     =       0.0,     storeHHVel  = 0,    #false     transposeDCM= 1,    #true     WrVTK       = 2,     WrVTKType  = 3,     VTKNacDim   = [-.10 ,-.10 ,-.10 ,.2 ,.2 ,.2],     VTKHubRad   = 1.0,     adinstrut  = 2,     adidt      = 0.05,     aditmax    = 10,     adiwrOuts  = 0,     adiDT_Outs = 0.0,     isHAWT      = false,                          # false: VAWT or cross-flow turbine, true: HAWT     numTurbines = 1)\n\nInitializes aerodynamic models and sets up backend persistent memory to simplify intermittent calling within coupled solver loops\n\nInputs\n\nadi_lib: path to adi library (.so, .dylib, .dll)\nad_input_file: input file for aerodyn15\nifw_input_file: input file for inflow wind\nadi_rootname: rootname for vtk outputs\nbld_x: Blade x shape\nbld_z: Blade z shape\nB: Number of blades\nrho: working fluid density (kg/m^3)\ngravity: Gravitational acceleration (m/s^2)\ndefKinVisc: Kinematic viscosity of working fluid (m^2/s)\ndefSpdSound: Speed of sound in working fluid (m/s)\ndefPatm: Atmospheric pressure (Pa) [used only for an MHK turbine cavitation check]\ndefPvap: Vapour pressure of working fluid (Pa) [used only for an MHK turbine cavitation check]\nWtrDpth: Water depth (m)\nMSL2SWL: Offset between still-water level and mean sea level (m) [positive upward]\nstoreHHVel: unused here\ntransposeDCM: 0=false, 1=true transpose DCM internally for calculations\nWrVTK: write VTK files from adi to directory adi-vtk [0 none, 1 ref, 2 motion]\nWrVTK_Type: write VTK files from adi to directory adi-vtk [1 surface, 2 lines, 3 both]\nVTKNacDim: Nacelle Dimension for VTK visualization x0,y0,z0,Lx,Ly,Lz (m)\nVTKHubRad: HubRadius for VTK visualization (m)\nadi_wrOuts: file format to write to\nadi_DT_Outs: output timestep to write at\nadi_nstrut: createmeshstruts is hard coded for 2 struts per blade\nadi_dt: timestep\nadi_tmax: maximum time\nhubPos: hub position in global coordinates, 3-vector (m). NOTE: AD15 assumes a different hub location than OWENS\nhubAngle: hub axis angle, 3-vector (deg), no rotation from spinning\nnacPos: nacelle position in global coordinates, 3-vector (m). NOTE: AD15 assumes a different hub location than OWENS\nnacAngle: nacelle axis angle, 3-vector (deg)\nnumTurbines: number of turbines\nisHAWT: # false: VAWT or cross-flow turbine, true: HAWT\n\nOutputs:\n\nnone:\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceOpenFASTWrappers/#OWENSOpenFASTWrappers.transMat-Tuple{Any, Any, Any}","page":"OWENSOpenFASTWrappers","title":"OWENSOpenFASTWrappers.transMat","text":"transMat(theta1, theta2, theta3)\n\nInternal, computes the 3x3 transformation matrix for given input rotations. The generated matrix is the closest orthonormal matrix to the Bernoulli-Euler transformation matrix from beam theory, which assumes small rotations. A full description of this matrix is found in the \"FASTCoordinateSystems.doc\" document by Jason Jonkman.\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#OWENS","page":"OWENS","title":"OWENS","text":"","category":"section"},{"location":"reference/reference/#Index","page":"OWENS","title":"Index","text":"","category":"section"},{"location":"reference/reference/","page":"OWENS","title":"OWENS","text":"","category":"page"},{"location":"reference/reference/#Types-and-functions","page":"OWENS","title":"Types and functions","text":"","category":"section"},{"location":"reference/reference/#OWENS.AeroSetupOptions","page":"OWENS","title":"OWENS.AeroSetupOptions","text":"AeroSetupOptions\n\nContains the configuration for the aerodynamic model.\n\nFields\n\nrho::Float64: The density of the air.\nmu::Float64: The dynamic viscosity of the air.\nRPM::Float64: The rotational speed of the blades.\nVinf::Float64: The free stream velocity.\neta::Float64: The tip speed ratio.\ndelta_t::Float64: The time step for the aerodynamic model.\nAD15hubR::Float64: The hub radius for the AD15 model.\nWindType::Int: The type of wind model.\nAeroModel::String: The type of aerodynamic model.\nDynamicStallModel::String: The type of dynamic stall model.\nnumTS::Int: The number of time steps for the aerodynamic model.\nadi_lib::Union{Nothing,String}: The path to the AeroDyn library.\nadi_rootname::Union{Nothing,String}: The root name for the AeroDyn files.\nwindINPfilename::Union{Nothing,String}: The path to the wind input file.\nifw_libfile::Union{Nothing,String}: The path to the inflow wind library.\nifw::Bool: Whether to use the inflow wind model.\nRPI::Bool: Whether to use the RPI model.\nAero_AddedMass_Active::Bool: Whether to use the added mass model.\nAero_RotAccel_Active::Bool: Whether to use the rotational acceleration model.\nAero_Buoyancy_Active::Bool: Whether to use the buoyancy model.\ncentrifugal_force_flag::Bool: Whether to use the centrifugal force model.\n\n\n\n\n\n","category":"type"},{"location":"reference/reference/#OWENS.Bin","page":"OWENS","title":"OWENS.Bin","text":"Inputs pointing to the file paths of compiled binaries of external libraries\n\n\n\n\n\n","category":"type"},{"location":"reference/reference/#OWENS.Blade","page":"OWENS","title":"OWENS.Blade","text":"Internal, struct containing the CACTUS geometry file data for a blade\n\n\n\n\n\n","category":"type"},{"location":"reference/reference/#OWENS.BladeData","page":"OWENS","title":"OWENS.BladeData","text":"Internal, struct containing blade specific data and location within the mesh\n\n\n\n\n\n","category":"type"},{"location":"reference/reference/#OWENS.BladeSetupOptions","page":"OWENS","title":"OWENS.BladeSetupOptions","text":"BladeSetupOptions\n\nContains the configuration for the blades.\n\nFields\n\nB::Int: The number of blades.\nH::Float64: The height of the blades.\nR::Float64: The radius of the blades.\nshapeZ::Vector{Float64}: The z-coordinates of the blade.\nshapeX::Vector{Float64}: The x-coordinates of the blade.\nshapeY::Vector{Float64}: The y-coordinates of the blade.\nNuMad_geom_xlscsv_file_bld::Any: The path to the blade geometry file. Can be nothing, String, or Vector{String}.\nNuMad_mat_xlscsv_file_bld::Any: The path to the blade material file. Can be nothing, String, or Vector{String}.\nstrut_blade_joint_type::Int: The type of joint between the struts and blades.\nblade_joint_angle_Degrees::Float64: The angle of the blade joint in degrees.\n\n\n\n\n\n","category":"type"},{"location":"reference/reference/#OWENS.Component","page":"OWENS","title":"OWENS.Component","text":"Component\n\nStructure storing critical information for preprocessing and postprocessing of structural components.\n\nFields\n\nname::String: Component identifier\nnodeNumbers::Array{Int}: Array of node numbers associated with the component\nelNumbers::Array{Int}: Array of element numbers associated with the component\ne_x::Array{Float64}: x-direction unit vectors at each element (m)\ne_y::Array{Float64}: y-direction unit vectors at each element (m)\ne_z::Array{Float64}: z-direction unit vectors at each element (m)\nk_x::Array{Float64}: Curvature in x direction (1/m)\nk_y::Array{Float64}: Curvature in y direction (1/m)\nk_z::Array{Float64}: Curvature in z direction (1/m)\nlam_U::Array{Float64}: Upper surface laminate properties (stiffness matrix)\nlam_L::Array{Float64}: Lower surface laminate properties (stiffness matrix)\nlam_W::Array{Float64}: Web laminate properties (stiffness matrix)\ninput_layup::Array: Input layup configuration\ninput_materials::Array: Input material properties\npreCompInput::Array: PreComp input data\npreCompOutput::Array: PreComp output data\nplyProps::Array: Ply properties including material data and fatigue parameters\nnuMadIn::Array: NuMad input data for composite analysis\nstiff_matrix::Array{Float64}: Component stiffness matrix (N/m)\nmass_matrix::Array{Float64}: Component mass matrix (kg)\nsectionProps::Array: Section properties including area, moments of inertia, etc.\nstress_U::Array{Float64}: Upper surface stress (Pa)\nstress_L::Array{Float64}: Lower surface stress (Pa)\nstrain_U::Array{Float64}: Upper surface strain (dimensionless)\nstrain_L::Array{Float64}: Lower surface strain (dimensionless)\nultsafetyfactor_U::Array{Float64}: Upper surface ultimate safety factor\nultsafetyfactor_L::Array{Float64}: Lower surface ultimate safety factor\nbucksafetyfactor_U::Array{Float64}: Upper surface buckling safety factor\nbucksafetyfactor_L::Array{Float64}: Lower surface buckling safety factor\ndamage_U::Array{Float64}: Upper surface fatigue damage (dimensionless)\ndamage_L::Array{Float64}: Lower surface fatigue damage (dimensionless)\nmass::Float64: Component mass (kg)\ncost::Float64: Component cost (currency units)\n\nNotes\n\nThis structure is used to store both preprocessing and postprocessing data for structural components\nArrays of components are typically generated during the mesh stage\nThe structure supports both linear and nonlinear analysis\nSafety factors are calculated based on material properties and loading conditions\nDamage values represent accumulated fatigue damage based on S-N curves\n\n\n\n\n\n","category":"type"},{"location":"reference/reference/#OWENS.Component-Tuple{}","page":"OWENS","title":"OWENS.Component","text":"component = Component(;     name=\"nothing\",     nodeNumbers=nothing,     elNumbers=nothing,     ex=nothing,     ey=nothing,     ez=nothing,     kx=nothing,     ky=nothing,     kz=nothing,     lamU=nothing,     lamL=nothing,     lamW=nothing,     inputlayup=nothing,     inputmaterials=nothing,     preCompInput=nothing,     preCompOutput=nothing,     plyProps=nothing,     nuMadIn=nothing,     stiffmatrix=nothing,     massmatrix=nothing,     sectionProps=nothing,     stressU=nothing,     stressL=nothing,     strainU=nothing,     strainL=nothing,     ultsafetyfactorU=nothing,     ultsafetyfactorL=nothing,     bucksafetyfactorU=nothing,     bucksafetyfactorL=nothing,     damageU=nothing,     damage_L=nothing,     mass=nothing,     cost=nothing)\n\nThis function stores the critical information associated with preprocessing and post processing to enable generalization.  It is intended that an array of components will be generated by appending each subsequent component to the array at the mesh stage.\n\n#Inputs\n\nname::: \nnodeNumbers:::\nelNumbers:::\ne_x::: \ne_y::: \ne_z::: \nk_x::: \nk_y::: \nk_z::: \nlam_U::: \nlam_L::: \nlam_W::: \ninput_layup:::\ninput_materials:::\npreCompInput::: \npreCompOutput::: \nplyProps::: \nnuMadIn::: \nstiff_matrix:::\nmass_matrix:::\nsectionProps:::\nstress_U:::\nstress_L:::\nstrain_U:::\nstrain_L:::\nultsafetyfactor_U:::\nultsafetyfactor_L:::\nbucksafetyfactor_U:::\nbucksafetyfactor_L:::\ndamage_U:::\ndamage_L:::\nmass:::\ncost:::\n\n#Outputs\n\ncomponent::OWENS.Component: Component struct with the same information as the input, some elements may be initialize as nothing and filled in later\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#OWENS.DLC_Options","page":"OWENS","title":"OWENS.DLC_Options","text":"DLCOptions(dictin::OrderedCollections.OrderedDict{Symbol,Any})\n\n# Input\n* `DLCs`: default [\"none\"], name of DLC\n* `Vinf_range`: default inRange(5,20,16), inflow Cutin to cutout and discretization\n* `IEC_std`: default \"\"1-ED3\"\", turbsim input file IEC standard\n* `WindChar`: default \"\"A\"\", turbsim wind charasteric \n* `WindClass`: default , DLC turbsim wind class\n* `turbsimsavepath`: default \"./turbsimfiles\", path where the turbsim files are saved\n* `pathtoturbsim`: default othing, path to the turbsim executable\n* `NumGrid_Z`: default 8, turbsim vertical discretizations \n* `NumGrid_Y`: default 6, turbsim horizontal discretizations\n* `Vref`: default 0.0, reference/nominal wind speed m/s for turbsim or other inflow wind input file (depending on which DLC is selected)\n* `Vdesign`: default 1.0, Design or rated speed of turbine, used for certain DLC cases\n* `grid_oversize`: default .1, amount that the turbsim inflow is oversized compared to the turbine to allow for deflection\n* `regenWindFiles`: default false, force regeneration of turbsim files even if they already exist\n* `delta_t_turbsim`: default .05, turbsim timestep\n* `simtime_turbsim`: default 00.0, turbsim total time, which loops if simtime exceeds turbsim time\n* `RandSeed1`: default 0071, turbsim random seed number\n* `DLCParams`: see ?OWENS.DLCParams, the current DLC parameters for the run, used as internal state information\n\n\n# Output\n* `DLC_Options`:\n\n\n\n\n\n","category":"type"},{"location":"reference/reference/#OWENS.DLC_internal","page":"OWENS","title":"OWENS.DLC_internal","text":"DLC_internal\n\nInternal structure for Design Load Case (DLC) analysis parameters and results.\n\nFields\n\nVinf_range_used::Array{Float64}: Range of wind speeds used in the analysis\nanalysis_type::String: Type of analysis (\"U\"=unsteady, \"F\"=fatigue, \"UF\"=unsteady fatigue)\ncontrolStrategy::String: Control strategy type\nRandSeed1::Int: Random seed for turbulent wind generation\nNumGrid_Z::Int: Number of vertical grid points\nNumGrid_Y::Int: Number of horizontal grid points\nTimeStep::Float64: Time step size in seconds\nHubHt::Float64: Hub height in meters\nAnalysisTime::Float64: Total analysis time in seconds\nGridHeight::Float64: Grid height in meters\nGridWidth::Float64: Grid width in meters\nVFlowAng::Float64: Vertical mean flow angle in degrees\nHFlowAng::Float64: Horizontal mean flow angle in degrees\nTurbModel::String: Turbulence model specification\nIECstandard::String: IEC standard reference (e.g., \"1-ED3\")\nIECturbc::String: IEC turbulence characteristic (\"A\", \"B\", \"C\" or TI%)\nIEC_WindType::String: IEC turbulence type (\"NTM\", \"xETM\", \"xEWM1\", \"xEWM50\")\nRefHt::Float64: Reference height for wind speed in meters\nURef::Float64: Reference wind speed in m/s\ntime::Array{Float64}: Time series array\nwindvel::Array{Float64}: Wind velocity time series\nwinddir::Array{Float64}: Wind direction time series\nwindvertvel::Array{Float64}: Vertical wind velocity time series\nhorizshear::Array{Float64}: Horizontal wind shear profile\npwrLawVertShear::Float64: Power law vertical shear coefficient\nLinVertShear::Float64: Linear vertical shear coefficient\ngustvel::Array{Float64}: Gust velocity time series\nUpflowAngle::Float64: Upflow angle in degrees\n\n\n\n\n\n","category":"type"},{"location":"reference/reference/#OWENS.DriveShaftProps","page":"OWENS","title":"OWENS.DriveShaftProps","text":"Internal, driveshaft stiffness k and damping c\n\n\n\n\n\n","category":"type"},{"location":"reference/reference/#OWENS.Drivetrain_Options","page":"OWENS","title":"OWENS.Drivetrain_Options","text":"DrivetrainOptions(dictin::OrderedCollections.OrderedDict{Symbol,Any})\n\n# Input\n* `turbineStartup`: default 0, TODO: clean up since it should be derived from control strategy\n* `usingRotorSpeedFunction`: default false, TODO: clean up the speed function since the omegaocp RPM gets splined already\n* `driveTrainOn`: default false, flag to turn on the drivetrain model TODO: clean this up to make it always use the drivetrain model, with default 100% efficiency and ratio of 1 so it outputs the values\n* `JgearBox`: default 0.0, torsional stiffness of the gearbox TODO: resolve units\n* `gearRatio`: default 1.0, ratio between the turbine driveshaft and generator shaft\n* `gearBoxEfficiency`: default 1.0, efficiency of the gearbox, just decreases the torque that the generator model sees\n* `generatorOn`: default false, TODO: clean up the generator options\n* `useGeneratorFunction`: default false, TODO: clean up the generator options\n* `generatorProps`: default 0.0, TODO: clean up the generator options\n* `ratedTorque`: default 0.0, TODO: clean up the generator options\n* `zeroTorqueGenSpeed`: default 0.0, TODO: clean up the generator options\n* `pulloutRatio`: default 0.0, TODO: clean up the generator options\n* `ratedGenSlipPerc`: default 0.0, TODO: clean up the generator options\n* `OmegaGenStart`: default 0.0, TODO: clean up the generator options\n* `driveShaftProps_K`: default 0.0, TODO: break this out, driveshaft stiffness and damping\n* `driveShaftProps_C`: default 0.0, TODO: break this out, driveshaft stiffness and damping\n\n# Output\n* `Drivetrain_Options`:\n\n\n\n\n\n","category":"type"},{"location":"reference/reference/#OWENS.Inputs-Tuple{}","page":"OWENS","title":"OWENS.Inputs","text":"Inputs(;verbosity=2,     analysisType = \"TNB\",     turbineStartup = 0,     usingRotorSpeedFunction = false,     tocp = [0.0,1.1],     tocpVinf = [0.0,1.1],     numTS = 50.0,     deltat = 2e-3,     Omegaocp = [7.2,7.2] ./ 60,     Vinfocp = [12.0,12.0],     aeroLoadsOn = 1,     AD15On = false,     driveTrainOn = false,     generatorOn = false,     platformActive = false,     topsideOn = true,     interpOrder = 2,     hdinputfile = \"none\",     mdinputfile = \"none\",     JgearBox = 0.0,     gearRatio = 1.0,     gearBoxEfficiency = 1.0,     useGeneratorFunction = false,     generatorProps = 0.0,     ratedTorque = 0.0,     zeroTorqueGenSpeed = 0.0,     pulloutRatio = 0.0,     ratedGenSlipPerc = 0.0,     OmegaGenStart = 0.0,     omegaControl = false,     OmegaInit = 7.2/60, #TODO: simplify this in the code since it is redundant     rigid = false, #turn off structural dynamics     aeroloadfile = \"modulepath/../test/data/inputfilestest/DVAWT2BLCDTElementData.csv\",     owensfile = \"modulepath/../test/data/inputfilestest/15mTowertransientdvawtc2_lcdt.owens\",     dataOutputFilename = \"none\",     numDOFPerNode = 6,     bladeData = [],     driveShaftProps = DriveShaftProps(0.0,0.0)     TOL = 1e-4,     MAXITER = 300,     )\n\nModel inputs for OWENS coupled analysis, struct\n\nInputs\n\nverbosity::int: output verbosity where 0 is nothing, 1 is warnings, 2 is summary outputs, 3 is detailed outputs, and 4 is everything\nanalysisType::string: Newmark Beta time stepping \"TNB\", Dean time stepping \"TD\", modal \"M\"\nturbineStartup::int: 1 forced start-up using generator as motor, 2 self-starting mode, 0 specified rotor speed mode\")\nusingRotorSpeedFunction::bool: use user specified rotor speed profile function\ntocp::Array{<:float}: = time points for rotor speed profile (s)\ntocp_Vinf::Array{<:float}: = time points for specified Vinf profile (s)\nnumTS::int: total number of timesteps to run\ndelta_t::float: timestep interval (s)\nOmegaocp::Array{<:float}: = rotor speed points for rotor speed profile (Hz)\nVinfocp::Array{<:float}: = rotor speed points for specified Vinf profile (Hz)\naeroLoadsOn::bool: #0 off, 1 one way, 1.5 one way with deformation from last timestep, 2 two way\nAD15On::bool: flag to use AD15 for aero\ndriveTrainOn::bool: flag to include drivetrain effects\ngeneratorOn::bool: flag to include generator effects\nplatformActive::bool: flag to include platform coupling\ninterpOrder::int: order used for extrapolating inputs and states, 0 flat, 1 linear, 2 quadratic\nhd_input_file::string: file path to the HydroDyn .dat input file\nss_input_file::string: file path to the HydroDyn sea states input file\nmd_input_file::string: file path to the MoorDyn .dat input file\nJgearBox::float: gearbox intertia, standard SI units\ngearRatio::float: gearbox gear ratio\ngearBoxEfficiency::float: gearbox efficiency (typically 0-1)\nuseGeneratorFunction::bool: = flag to use user specified generator profile\ngeneratorProps::float: not used, should clean up\nratedTorque::float: Generator rated max torque\nzeroTorqueGenSpeed::float: rated generator speed (minus slippage)\npulloutRatio::float: Fraction of the min/max torque that the generator engages/disengages\nratedGenSlipPerc::float: extra speed from slipping?\nOmegaGenStart::float: speed (Hz) at which generator would kick in\nomegaControl::bool: false for fixed speed, true for dynamic\nOmegaInit::float: initial rotor speed (Hz)\naeroloadfile::string: string of the name and path for the cactus aeroloads if using the old serial owens call\nowensfile::string: string of the name and path for the owens input file if using the old serial owens call\npotflowfile::string: string of the prefix and path for the directory containing the potential flow files from WAMIT (required by HydroDyn)\ndataOutputFilename::string: path and name of output file, will be overwritten if already exists\nnumDOFPerNode::int: number of degrees of freedom per node\nbladeData::BladeData: see ?BladeData, only used if calling the old serial owens function\ndriveShaftProps::DriveShaftProps: see ?DriveShaftProps\nTOL::float: gauss-seidel iteration tolerance\nMAXITER::int: gauss-seidel maximum iterations\n\nOutputs:\n\nOWENS.Inputs:\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#OWENS.Iteration_Parameters","page":"OWENS","title":"OWENS.Iteration_Parameters","text":"Internal, gauss-seidel iteration parameters \n\n\n\n\n\n","category":"type"},{"location":"reference/reference/#OWENS.MasterInput","page":"OWENS","title":"OWENS.MasterInput","text":"MasterInput\n\nConfiguration structure containing all input parameters for OWENS analysis.\n\nFields\n\nanalysisType::String: Type of analysis to perform (\"unsteady\", \"steady\", \"modal\")\nturbineType::String: Type of turbine (\"Darrieus\", \"H-VAWT\", \"ARCUS\")\neta::Float64: Blade mount point ratio (0.5 = blade half chord perpendicular to axis of rotation)\nNbld::Int: Number of blades\ntowerHeight::Float64: Tower extension height below blades in meters\nrho::Float64: Air density in kg/m³\nVinf::Float64: Inflow wind speed in m/s\ncontrolStrategy::String: Control strategy type\nRPM::Float64: Rotor speed in RPM\nNslices::Int: Number of VAWTAero discretizations\nntheta::Int: Number of VAWTAero azimuthal discretizations\nstructuralModel::String: Structural model type (\"GX\", \"TNB\", \"ROM\")\nntelem::Int: Number of tower elements\nnbelem::Int: Number of blade elements\nncelem::Int: Number of central cable elements (for ARCUS)\nnselem::Int: Number of strut elements\nAeroModel::String: Aerodynamic model type\nifw::Bool: Inflow wind flag\nWindType::Int: Wind type specification\nwindINPfilename::String: Path to wind input file\nifw_libfile::String: Path to inflow wind library\nadi_lib::String: Path to aerodyn library\nadi_rootname::String: Root name for aerodyn files\nBlade_Height::Float64: Blade height in meters\nBlade_Radius::Float64: Blade radius in meters\nnumTS::Int: Number of timesteps\ndelta_t::Float64: Timestep size in seconds\nNuMad_geom_xlscsv_file_twr::String: Path to tower geometry file\nNuMad_mat_xlscsv_file_twr::String: Path to tower material file\nNuMad_geom_xlscsv_file_bld::String: Path to blade geometry file\nNuMad_mat_xlscsv_file_bld::String: Path to blade material file\nNuMad_geom_xlscsv_file_strut::String: Path to strut geometry file\nNuMad_mat_xlscsv_file_strut::String: Path to strut material file\n\nConstructor\n\nMasterInput(;\n    analysisType = \"unsteady\",\n    turbineType = \"Darrieus\",\n    eta = 0.5,\n    Nbld = 3,\n    towerHeight = 3.0,\n    rho = 1.225,\n    Vinf = 17.2,\n    controlStrategy = \"constantRPM\",\n    RPM = 17.2,\n    Nslices = 30,\n    ntheta = 30,\n    structuralModel = \"GX\",\n    ntelem = 10,\n    nbelem = 60,\n    ncelem = 10,\n    nselem = 5,\n    AeroModel = \"AD\",\n    ifw = false,\n    WindType = 1,\n    ifw_libfile = \"./../openfast/build/modules/inflowwind/libifw_c_binding\",\n    adi_lib = \"./../openfast/build/modules/aerodyn/libaerodyn_inflow_c_binding\",\n    adi_rootname = \"./Example\",\n    numTS = 100,\n    delta_t = 0.01,\n    windINPfilename = \"path/to/wind/file.bts\",\n    NuMad_geom_xlscsv_file_twr = \"none\",\n    NuMad_mat_xlscsv_file_twr = \"none\",\n    NuMad_geom_xlscsv_file_bld = \"none\",\n    NuMad_mat_xlscsv_file_bld = \"none\",\n    NuMad_geom_xlscsv_file_strut = \"none\",\n    NuMad_mat_xlscsv_file_strut = \"none\"\n)\n\n\n\n\n\n","category":"type"},{"location":"reference/reference/#OWENS.MaterialSetupOptions","page":"OWENS","title":"OWENS.MaterialSetupOptions","text":"MaterialSetupOptions\n\nContains the material properties for the blades, struts, and tower.\n\nFields\n\nstack_layers_bld::Union{Nothing,Matrix{Float64}}: The stack layers for the blades.\nstack_layers_scale::Vector{Float64}: The scale factors for the stack layers.\nchord_scale::Vector{Float64}: The scale factors for the chord.\nthickness_scale::Vector{Float64}: The scale factors for the thickness.\nAddedMass_Coeff_Ca::Float64: The added mass coefficient.\n\n\n\n\n\n","category":"type"},{"location":"reference/reference/#OWENS.MeshSetupOptions","page":"OWENS","title":"OWENS.MeshSetupOptions","text":"MeshSetupOptions\n\nContains the configuration for the mesh.\n\nFields\n\nNslices::Int: The number of slices.\nntheta::Int: The number of theta points.\nntelem::Int: The number of elements.\nnbelem::Int: The number of blade elements.\nncelem::Int: The number of chord elements.\nnselem::Int: The number of span elements.\nmeshtype::String: The type of mesh.\ncustommesh::Union{Nothing,Function}: The custom mesh function.\nconnectBldTips2Twr::Bool: Whether to connect the blade tips to the tower.\nAD15_ccw::Bool: Whether to use the AD15 convention of VAWT counter-clockwise with blade root at top (blade points down).\n\n\n\n\n\n","category":"type"},{"location":"reference/reference/#OWENS.Mesh_Options","page":"OWENS","title":"OWENS.Mesh_Options","text":"MeshOptions(dictin::OrderedCollections.OrderedDict{Symbol,Any})\n\n# Input\n* `ntelem`: default 20, number of tower elements in each blade, plus nodes wherever there is a component overlap\n* `nbelem`: default 30, number of blade elements in each blade, plus nodes wherever there is a component overlap\n* `ncelem`: default 30, number of cable elements in each cable if ARCUS\n* `nselem`: default 10, number of elements in each strut\n* `angularOffset`: default 0.0, moves the structure to align with the aero model\n* `joint_type`: default 0, optionally can specify the strut to blade joints to be pinned about different axes, or 0 for welded\n* `c_mount_ratio`: default 0.05, for ARCUS, where the cable mounts on the lower side of the blade\n* `AD15hubR`: default 0.1, parameter, used in aerodyn coupling for the hub radius so that the vortex sheets don't go within the hub\n* `cables_connected_to_blade_base`: default true, for ARCUS, for the two part simulation of the blade bending\n* `turbineType`: default \"Darrieus\", mesh Darrieus, H-VAWT, controls if the tips of the blades are joined to the tower in the mesh or not. \n        \n# Output\n* `Mesh_Options`:\n\n\n\n\n\n","category":"type"},{"location":"reference/reference/#OWENS.NuMad","page":"OWENS","title":"OWENS.NuMad","text":"NuMad(nweb,nstack,nsegments,span,airfoil,tetype,twistd,chord,xoffset,aerocenter,stackmattypes,stacklayers,segments,DPtypes,skin,webstack,webdp)\n\nParameters defining the blade composite layup. See NuMad user guide SAND2012_7028 appendix B for more details\n\nArguments\n\nn_web::Int64: number of shear webs\nn_stack::Int64: number of predefined composite stacks\nn_segments::Int64: number of segments around the airfoil\nspan::Vector{Float64}: span-wise position\nairfoil::Vector{String}: airfoil name\nte_type::Vector{String}: trailing edge type\ntwist_d::Vector{Float64}: twist_d in degrees\nchord::Vector{Float64}: chord length\nxoffset::Vector{Float64}: The distance from the \"nose\" of a station to the blade reference axis.\naerocenter::Vector{Float64}: This is an aerodynamic parameter that is an output from aerodynamic performance analysis of a two-dimensional airfoil section. The aerodynamic center is the point along the chord where the aerodynamic pitching moment does not vary with changes in angle of attack.\nstack_mat_types::Vector{Int64}: Material numbers used that correspond to each stack number\nstack_layers::Array{Int64,2}: number of layers at each span used corresponding to each material type (first index corresponds to spanwise position, second index corresponds to the stack number)\nsegments::Array{Float64,2}: normalized starting and stopping points of each section (i.e. leading edge, sparcap, etc).  First index corresponds to  spanwise position, second index corresponds to the section, except there is an extra first column starting at -1 for the trailing edge. There must be a leading edge position at 0, and the last column must be 1 corresponding to the trailing edge again.  Positions are fractions of the chord, lower (HP) is negative, upper (LP) is positive\nDPtypes::Array{Int64,2}: division point types (NOTE THAT THIS ISN'T IMPLEMENTED AND DOES NOTHING CURRENTLY, i.e. only SINGLE is being used). First index corresponds to  spanwise position, second corresponds to section number\nskin_seq::Array{Seq,2}: stack sequence, is an array of structures, each containing a Vector{Int64} of the sequence (i.e. skin[2,5].seq). First index corresponds to spanwise positoin, second index the section\nweb_seq::Array{Seq,2}: same format and meaning as skin sequence, but for the webs with the second index corresponding to the web number\nweb_dp::Array{Seq,2}: same format as skin sequence, but this corresponds to the section numbers the web connects to at the top and bottom at both edges. There are always four entries in the CSV list and the order goes as follows: inboard LP, inboard HP, outboard HP, outboard LP.\n\n\n\n\n\n","category":"type"},{"location":"reference/reference/#OWENS.OWENSAero_Options","page":"OWENS","title":"OWENS.OWENSAero_Options","text":"OWENSAeroOptions(dictin::OrderedCollections.OrderedDict{Symbol,Any})\n\n# Input\n* `Nslices`: default 20, number of 3-D slices for the strip method to go from 2D to 3D considering curved deforming blades\n* `ntheta`: default 30, number of azimuthal discretizations\n* `ifw`: default false, use the inflow wind coupling to get inflow velocities TODO: change ifw to inflowwind inflowwind_active etc everywhere\n* `DynamicStallModel`: defaultBV\", dynamic stall model, should be under an OWENSAero options\n* `RPI`: default true, rotating point iterative method (i.e. it just calculates at the blade positions and is much faster)\n* `Aero_Buoyancy_Active`: default false, flag to turn buoyancy on for the blades.  This is likely to be replaced by a different model\n* `Aero_AddedMass_Active`: default false, flag to turn added mass forces on, don't turn on if the added mass in the structures are on\n* `Aero_RotAccel_Active`: default false, flag to turn added mass forces on, don't turn on if the added mass in the structures are on\n\n\n# Output\n* `OWENSAero_Options`:\n\n\n\n\n\n","category":"type"},{"location":"reference/reference/#OWENS.OWENSFEA_Options","page":"OWENS","title":"OWENS.OWENSFEA_Options","text":"OWENSFEAOptions(dictin::OrderedCollections.OrderedDict{Symbol,Any})\n\n# Input\n* `nlOn`: default true, nonlinear effects\n* `RayleighAlpha`: default 0.05, damping coefficient scalar on the stiffness matrix\n* `RayleighBeta`: default 0.05, damping coefficient scalar on the mass matrix\n* `iterationType`: default \"DI\", internal iteration type DI direct iteration, NR newton rhapson (which is less stable than DI)\n* `guessFreq`: default 0.0, for the built in flutter model frequency guessed for the flutter frequency \n* `numModes`: default 20, ROM model, number of modes used in the analysis type.  Less is faster but less accurate\n* `adaptiveLoadSteppingFlag`: default true, for steady analysis if convergence fails, it will reduce the load and retry then increase the load\n* `minLoadStepDelta`: default 0.0500, minimum change in load step\n* `minLoadStep`: default 0.0500, minimum value of reduced load\n* `prescribedLoadStep`: default 0.0, optional prescribed load fraction\n* `maxNumLoadSteps`: default 20, used in static (steady state) analysis, max load steps for adaptive load stepping\n* `tolerance`: default 1.0000e-06, total mesh unsteady analysis convergence tolerance for a timestep within the structural model\n* `maxIterations`: default 50, total mesh unsteady analysis convergence max iterations for a timestep\n* `elementOrder`: default 1, Element order, 1st order, 2nd order etc; determines the number of nodes per element (order +1).  Orders above 1 have not been tested in a long time  \n* `alpha`: default 0.5, newmark time integration alpha parameter\n* `gamma`: default 0.5, newmark time integration gamma parameter\n* `AddedMass_Coeff_Ca`: default 0.0, added mass coefficient, scaling factor (typically 0-1) on the cones of water mass applied to each structural element in the 22 and 33 diagonal terms. 0 turns this off\n* `platformTurbineConnectionNodeNumber`: default 1, TODO: reconnect this\n* `aeroElasticOn`: default false, OWENSFEA for the built in flutter model\n* `spinUpOn`: default true, TODO: remove this since it should always be true since that is how its used. To turn it off, just set RPM and gravity to 0.  OWENSFEA modal analysis, calculates steady centrifugal strain stiffening and then passes that model to the modal analysis\n* `predef`: default false, Predeformation flag for two state analysis where a portion of the blade is deformed and the nonlinear strain stiffening terms are \"update\"-d, then \"use\"-d in two different analysis\n\n# Output\n* `OWENSFEA_Options`:\n\n\n\n\n\n","category":"type"},{"location":"reference/reference/#OWENS.OWENSOpenFASTWrappers_Options","page":"OWENS","title":"OWENS.OWENSOpenFASTWrappers_Options","text":"OWENSOpenFASTWrappersOptions(dictin::OrderedCollections.OrderedDict{Symbol,Any})\n\n# Input\n* `windINPfilename`: default nothing, If ifw or AeroDyn is being used, gets overwritten if using the DLC analysis type, the moordyn file location, like in the unit test\n* `ifw_libfile`: default nothing, location of the respective OpenFAST library, if nothing it will use the internal OWENS installation\n* `hd_lib`: default nothing, location of the respective OpenFAST library, if nothing it will use the internal OWENS installation\n* `md_lib`: default nothing, location of the respective OpenFAST library, if nothing it will use the internal OWENS installation\n* `adi_lib`: default nothing, location of the respective OpenFAST library, if nothing it will use the internal OWENS installation\n* `adi_rootname`: default \"/aerodyn\", location of the respective OpenFAST library, if nothing it will use the internal OWENS installation\n* `hd_input_file`: default \"none\", If platformActive, the hydrodyn file location, like in the unit test\n* `ss_input_file`: default \"none\", If platformActive, the sea state file location, like in the unit test\n* `md_input_file`: default \"none\", If platformActive, the moordyn file location, like in the unit test\n* `potflowfile`: default nothing, If platformActive, the potential flow files location, like in the unit test\n* `WindType`: default 3, Derived parameter, inflowwind wind file type when DLC generator is active, matches inflowwind WindType \n        \n# Output\n* `OWENSOpenFASTWrappers_Options`:\n\n\n\n\n\n","category":"type"},{"location":"reference/reference/#OWENS.OWENS_Options","page":"OWENS","title":"OWENS.OWENS_Options","text":"OWENSOptions(dictin::OrderedCollections.OrderedDict{Symbol,Any})\n\n# Input\n* `analysisType`: default \"Unsteady\",  Unsteady, DLC, Campbell, todo: steady, flutter may be re-activated in the future.\n* `AeroModel`: default \"DMS\",  OWENSAero model \"DMS\" for double multiple streamtube or \"AC\" for actuator cylinder, or \"AD\" for aerodyn\n* `structuralModel`: default \"TNB\",  Structural models available: TNB full timoshenko beam elements with time newmark beta time stepping, ROM reduced order modal model of the timoshenko elements, GX with GXBeam's methods for geometrically exact beam theory and more efficient methods and time stepping\n* `controlStrategy`: default \"normal\",  should be in WindIO?- yes, \n* `numTS`: default 10,  number of time steps TODO: change to sim time and make this derived\n* `delta_t`: default 0.05,  time step in seconds\n* `platformActive`: default false,  flag to indicate if the floating platform model is active.  \n* `topsideOn`: default true,  flat to be able to turn off the rotor and just run the floating portions\n* `interpOrder`: default 2,  if platformActive, order used for extrapolating inputs and states, 0 flat, 1 linear, 2 quadratic\n* `dataOutputFilename`: default nothing,  data output filename with path, set to nothing or don't specify to not output anything\n* `rigid`: default false,  this bypasses the structural solve and just mapps the applied loads as the reaction loads, and the deflections remain 0\n* `TOL`: default 1e-4,  gauss-seidel iteration tolerance - i.e. the two-way iteration tolerance\n* `MAXITER`: default 300,  gauss-seidel max iterations - i.e. the two-way iterations\n* `verbosity`: default 2,  verbosity where 0 is nothing, 1 is warnings, 2 is summary outputs, 3 is detailed outputs, and 4 is everything\n* `VTKsaveName`: default \"./vtk/windio\",  Path and name of the VTK outputs, recommended to put it in its own folder (which it will automatically create if needed)\n* `aeroLoadsOn`: default 2,  Level of aero coupling 0 structures only, 1 no deformation passed to the aero, 2 two-way coupling, 1.5 last time step's deformations passed to this timesteps aero and no internal iteration.\n* `Prescribed_RPM_time_controlpoints`: default [0.0,100000.1],  If controlStrategy is \"fixedRPM\", array of time control points for the internal spline\n* `Prescribed_RPM_RPM_controlpoints`: default [17.2,17.2],  If controlStrategy is \"fixedRPM\", array of RPM control points for the internal spline\n* `Prescribed_Vinf_time_controlpoints`: default [0.0,100000.1],  If AeroModel is \"DMS\" or \"AC, and ifw is false, array of time control points for the internal spline\n* `Prescribed_Vinf_Vinf_controlpoints`: default [17.2,17.2],  If AeroModel is \"DMS\" or \"AC, and ifw is false, array of Vinf control points for the internal spline \n\n\n# Output\n* `OWENS_Options`:\n\n\n\n\n\n","category":"type"},{"location":"reference/reference/#OWENS.PostProcessOptions","page":"OWENS","title":"OWENS.PostProcessOptions","text":"PostProcessOptions\n\nOptions structure for controlling post-processing behavior in the OWENS code.\n\nFields\n\nverbosity::Int: Controls the level of output verbosity (0=none, 1=warnings, 2=summary, 3=detailed)\nusestationBld::Int: Index of the blade station to use for detailed output (0=all stations)\nusestationStrut::Int: Index of the strut station to use for detailed output (0=all stations)\nthrowawayTimeSteps::Int: Number of initial time steps to discard from analysis\ncalculate_fatigue::Bool: Whether to calculate fatigue damage\n\nConstructor\n\nPostProcessOptions(;verbosity=2,\n    usestationBld=0,\n    usestationStrut=0,\n    throwawayTimeSteps=1,\n    calculate_fatigue=true)\n\n\n\n\n\n","category":"type"},{"location":"reference/reference/#OWENS.SectionalProperties","page":"OWENS","title":"OWENS.SectionalProperties","text":"Contains the sectional properties of the components.\n\nFields\n\nsectionPropsArray::Vector{Any}: The sectional properties of the components.\nstiff_array::Vector{Any}: The stiffness of the components.\nmass_array::Vector{Any}: The mass of the components.\nrotationalEffects::Vector{Float64}: The rotational effects of the components.\n\n\n\n\n\n","category":"type"},{"location":"reference/reference/#OWENS.Seq","page":"OWENS","title":"OWENS.Seq","text":"Seq\n\nStructure representing a sequence of indices, typically used for layup sequences in composite materials.\n\nFields\n\nseq::Vector{Int64}: Array of indices representing the sequence\n\nNotes\n\nUsed in composite layup definitions for both skin and web sequences\nFirst index corresponds to spanwise position\nSecond index corresponds to section or web number\n\n\n\n\n\n","category":"type"},{"location":"reference/reference/#OWENS.SetupOptions","page":"OWENS","title":"OWENS.SetupOptions","text":"SetupOptions\n\nContains all setup options for the OWENS turbine model.\n\nFields\n\nmesh::MeshSetupOptions: Mesh configuration options\ntower::TowerSetupOptions: Tower configuration options\nblade::BladeSetupOptions: Blade configuration options\nmaterial::MaterialSetupOptions: Material configuration options\naero::AeroSetupOptions: Aerodynamic configuration options\n\n\n\n\n\n","category":"type"},{"location":"reference/reference/#OWENS.Strut","page":"OWENS","title":"OWENS.Strut","text":"Internal, struct containing the CACTUS geometry file data for a strut\n\n\n\n\n\n","category":"type"},{"location":"reference/reference/#OWENS.TopData","page":"OWENS","title":"OWENS.TopData","text":"TopData\n\nStructure containing time history data and state variables for the top section of the wind turbine.\n\nFields\n\ndelta_t::Float64: Time step size (s)\nnumTS::Int: Number of time steps\nnumDOFPerNode::Int: Number of degrees of freedom per node\nCN2H::Array{Float64}: Coordinate transformation matrix\nt::Array{Float64}: Time array (s)\nintegrator::String: Integration method\nintegrator_j::String: Previous integration method\ntopDispOut::Array{Float64}: Top displacement output\nuHist::Array{Float64}: Displacement history\nudotHist::Array{Float64}: Velocity history\nuddotHist::Array{Float64}: Acceleration history\nepsilon_x_hist::Array{Float64}: Axial strain history\nepsilon_y_hist::Array{Float64}: Transverse strain history (y)\nepsilon_z_hist::Array{Float64}: Transverse strain history (z)\nkappa_x_hist::Array{Float64}: Torsional curvature history\nkappa_y_hist::Array{Float64}: Bending curvature history (y)\nkappa_z_hist::Array{Float64}: Bending curvature history (z)\nFReactionHist::Array{Float64}: Reaction force history\nFTwrBsHist::Array{Float64}: Tower base force history\naziHist::Array{Float64}: Azimuth angle history (rad)\nOmegaHist::Array{Float64}: Rotor speed history (rad/s)\nOmegaDotHist::Array{Float64}: Rotor acceleration history (rad/s²)\ngbHist::Array{Float64}: Gearbox position history\ngbDotHist::Array{Float64}: Gearbox velocity history\ngbDotDotHist::Array{Float64}: Gearbox acceleration history\ngenTorque::Array{Float64}: Generator torque (N⋅m)\ngenPower::Array{Float64}: Generator power (W)\ntorqueDriveShaft::Array{Float64}: Drive shaft torque (N⋅m)\nuHist_prp::Array{Float64}: Prescribed displacement history\nFPtfmHist::Array{Float64}: Platform force history\nFHydroHist::Array{Float64}: Hydrodynamic force history\nFMooringHist::Array{Float64}: Mooring force history\nrbData::Array{Float64}: Rigid body data\nrbDataHist::Array{Float64}: Rigid body data history\nu_s::Array{Float64}: Current displacement state\nudot_s::Array{Float64}: Current velocity state\nuddot_s::Array{Float64}: Current acceleration state\nu_sm1::Array{Float64}: Previous displacement state\ntopDispData1::Array{Float64}: Top displacement data set 1\ntopDispData2::Array{Float64}: Top displacement data set 2\ntopElStrain::Array{Float64}: Top element strain\ngb_s::Float64: Current gearbox position\ngbDot_s::Float64: Current gearbox velocity\ngbDotDot_s::Float64: Current gearbox acceleration\nazi_s::Float64: Current azimuth angle (rad)\nOmega_s::Float64: Current rotor speed (rad/s)\nOmegaDot_s::Float64: Current rotor acceleration (rad/s²)\ngenTorque_s::Float64: Current generator torque (N⋅m)\ntorqueDriveShaft_s::Float64: Current drive shaft torque (N⋅m)\ntopFexternal::Array{Float64}: Current external forces\ntopFexternal_hist::Array{Float64}: External force history\nrotorSpeedForGenStart::Float64: Rotor speed for generator start (rad/s)\ntop_rom::Array{Float64}: Reduced order model data\ntopJointTransformTrans::Array{Float64}: Joint transformation matrix\nu_sRed::Array{Float64}: Reduced displacement state\nudot_sRed::Array{Float64}: Reduced velocity state\nuddot_sRed::Array{Float64}: Reduced acceleration state\ntopBC::Array{Float64}: Top boundary conditions\nu_s2::Array{Float64}: Secondary displacement state\nudot_s2::Array{Float64}: Secondary velocity state\nuddot_s2::Array{Float64}: Secondary acceleration state\ntop_invPhi::Array{Float64}: Inverse modal matrix\neta_s::Array{Float64}: Current modal coordinates\netadot_s::Array{Float64}: Current modal velocities\netaddot_s::Array{Float64}: Current modal accelerations\ntopsideMass::Float64: Topside mass (kg)\ntopsideMOI::Array{Float64}: Topside moment of inertia (kg⋅m²)\ntopsideCG::Array{Float64}: Topside center of gravity (m)\nu_j::Array{Float64}: Previous displacement state\nudot_j::Array{Float64}: Previous velocity state\nuddot_j::Array{Float64}: Previous acceleration state\nazi_j::Float64: Previous azimuth angle (rad)\nOmega_j::Float64: Previous rotor speed (rad/s)\nOmegaDot_j::Float64: Previous rotor acceleration (rad/s²)\ngb_j::Float64: Previous gearbox position\ngbDot_j::Float64: Previous gearbox velocity\ngbDotDot_j::Float64: Previous gearbox acceleration\ngenTorque_j::Float64: Previous generator torque (N⋅m)\ntorqueDriveShaft_j::Float64: Previous drive shaft torque (N⋅m)\nFReactionsm1::Array{Float64}: Previous reaction forces\ntopFReaction_j::Array{Float64}: Previous top reaction forces\n\nNotes\n\nThis structure stores both time history data and current state variables\nUsed for time integration and state tracking in unsteady analysis\nContains data for structural, aerodynamic, and control system states\nSupports both full-order and reduced-order modeling\nIncludes platform and mooring system data when applicable\n\n\n\n\n\n","category":"type"},{"location":"reference/reference/#OWENS.TowerSetupOptions","page":"OWENS","title":"OWENS.TowerSetupOptions","text":"TowerSetupOptions\n\nContains the configuration for the tower.\n\nFields\n\nHtwr_base::Float64: The height of the tower base.\nHtwr_blds::Float64: The height of the tower blades.\nstrut_twr_mountpoint::Vector{Float64}: The mount points of the struts on the tower.\nstrut_bld_mountpoint::Vector{Float64}: The mount points of the struts on the blades.\njoint_type::Int: The type of joint between the struts and tower.\nc_mount_ratio::Float64: The mount point of the struts to the tower.\nangularOffset::Float64: The angular offset of the tower.\nNuMad_geom_xlscsv_file_twr::Any: The path to the tower geometry file. Can be nothing, String, or Vector{String}.\nNuMad_mat_xlscsv_file_twr::Any: The path to the tower material file. Can be nothing, String, or Vector{String}.\nNuMad_geom_xlscsv_file_strut::Any: The path to the strut geometry file. Can be nothing, String, or Vector{String}.\nNuMad_mat_xlscsv_file_strut::Any: The path to the strut material file. Can be nothing, String, or Vector{String}.\nstrut_tower_joint_type::Int: The type of joint between the struts and tower.\n\n\n\n\n\n","category":"type"},{"location":"reference/reference/#OWENS.Unified_Options","page":"OWENS","title":"OWENS.Unified_Options","text":"Unified_Options\n\n# Input\n* `OWENS_Options::OWENS_Options`:\n* `DLC_Options::DLC_Options`:\n* `OWENSAero_Options::OWENSAero_Options`:\n* `OWENSFEA_Options::OWENSFEA_Options`:\n* `OWENSOpenFASTWrappers_Options::OWENSOpenFASTWrappers_Options`:\n* `Mesh_Options::Mesh_Options`:\n* `Drivetrain_Options::Drivetrain_Options`:\n\n# Output\n* `Unified_Options`:\n\n\n\n\n\n","category":"type"},{"location":"reference/reference/#OWENS.plyproperties","page":"OWENS","title":"OWENS.plyproperties","text":"plyproperties\n\nStructure containing material properties and fatigue data for composite plies.\n\nFields\n\nnames::Array{String}: Names of the materials\nplies::Array{Composites.Material}: Material properties for each ply\ncosts::Array{Float64}: Cost per unit for each material\nSN_stressMpa::Array{Float64}: Control points for S-N curve stress values (matrix material × 6)\nLog_SN_cycles2Fail::Array{Float64}: Control points for S-N curve cycle values (matrix material × 6)\n\nConstructor\n\nplyproperties(names, plies)\nplyproperties(names, plies, costs, SN_stressMpa, Log_SN_cycles2Fail)\n\n\n\n\n\n","category":"type"},{"location":"reference/reference/#OWENS.plyproperties-Tuple{}","page":"OWENS","title":"OWENS.plyproperties","text":"Struct containing\n\nmaterial names\n\nComposites.Material structs for each material name - see ?Composites.Material\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#OWENS.ModelingOptions","page":"OWENS","title":"OWENS.ModelingOptions","text":"ModelingOptions(yamlInputfile)\n\n# Input\n* `yamlInputfile::string`: yaml file containing ordered inputs matching the default keys\n\n\n# Output\n* `Unified_Options::Unified_Options`: Struct of structs containing all of the OWENS Options\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#OWENS.OWENSVTK-NTuple{17, Any}","page":"OWENS","title":"OWENS.OWENSVTK","text":"OWENSVTK(savename,t,uHist,system,assembly,sections,aziHist,mymesh,myel,epsilon_x_hist,epsilon_y_hist,epsilon_z_hist,kappa_x_hist,kappa_y_hist,kappa_z_hist,FReactionHist)\n\nFormats and outputs OWENS data into VTK format\n\n#Intput\n\n#Output\n\nnone:\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#OWENS.OWENSVTK-NTuple{7, Any}","page":"OWENS","title":"OWENS.OWENSVTK","text":"OWENSVTK(VTKsaveName,rundata,system,assembly,sections,mymesh,myel;tsave_idx=1:length(rundata.t,))\n\nFormats and outputs OWENS data into VTK format\n\n#Intput\n\n#Output\n\nnone:\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#OWENS.Unsteady-Tuple{Any}","page":"OWENS","title":"OWENS.Unsteady","text":"Unsteady(model,topModel,mesh,el,aero;getLinearizedMatrices=false)\n\nExecutable function for transient analysis. Provides the interface of various     external module with transient structural dynamics analysis capability.\n\n# Input\n* `inputs::Inputs`: see ?Inputs\n* `topModel::FEAModel`: see ?OWENSFEA.FEAModel\n* `mesh::Mesh`: see ?OWENSFEA.Mesh\n* `el::El`: see ?OWENSFEA.El\n* `bin::Bin`: see ?Bin\n* `aero::function`: Fexternal, Fdof = aero(t) where Fexternal is the force on each affected mesh dof and Fdof is the corresponding DOFs affected\n* `getLinearizedMatrices::Bool`: Flag to save the linearized matrices\n* `elStorage::ElStorage.ElStorage`: Optional object containing stored element matrices\n* `u_s::Array{<:float}`: Optional warm start of top deflections, of length Nnodes x Ndof\n\n\n# Output\n* `t`: time array (s)\n* `aziHist`: azimuthal history array \n* `OmegaHist`: rotational speed array history (hz)\n* `OmegaDotHist`: rotational acceleration array history\n* `gbHist`: gearbox position history array\n* `gbDotHist`: gearbox velocity history array\n* `gbDotDotHist`: gearbox acceleration history array\n* `FReactionHist`: Nodal reaction 6dof forces history\n* `rigidDof`:\n* `genTorque`: generator torque history\n* `genPower`: generator power history\n* `torqueDriveShaft`: driveshaft torque history\n* `uHist`: mesh displacement history for each dof\n* `epsilon_x_hist`: strain history for eps_xx_0 for each dof\n* `epsilon_y_hist`: strain history for eps_xx_z for each dof\n* `epsilon_z_hist`: strain history for eps_xx_y for each dof\n* `kappa_x_hist`: strain history for gam_xz_0 for each dof\n* `kappa_y_hist`: strain history for gam_xz_y for each dof\n* `kappa_z_hist`: strain history for gam_xy_0 for each dof\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#OWENS.Unsteady_Land-Tuple{Any}","page":"OWENS","title":"OWENS.Unsteady_Land","text":"Unsteady(model,topModel,mesh,el,aero;getLinearizedMatrices=false)\n\nExecutable function for transient analysis. Provides the interface of various     external module with transient structural dynamics analysis capability.\n\n# Input\n* `inputs::Model`: see ?Model\n* `topModel::FEAModel`: see ?OWENSFEA.FEAModel\n* `mesh::Mesh`: see ?OWENSFEA.Mesh\n* `el::El`: see ?OWENSFEA.El\n* `bin::Bin`: see ?Bin\n* `aero::function`: Fexternal, Fdof = aero(t) where Fexternal is the force on each affected mesh dof and Fdof is the corresponding DOFs affected\n* `getLinearizedMatrices::Bool`: Flag to save the linearized matrices\n* `elStorage::ElStorage.ElStorage`: Optional object containing stored element matrices\n* `u_s::Array{<:float}`: Optional warm start of top deflections, of length Nnodes x Ndof\n\n\n# Output\n* `t`: time array\n* `aziHist`: azimuthal history array\n* `OmegaHist`: rotational speed array history\n* `OmegaDotHist`: rotational acceleration array history\n* `gbHist`: gearbox position history array\n* `gbDotHist`: gearbox velocity history array\n* `gbDotDotHist`: gearbox acceleration history array\n* `FReactionHist`: Nodal reaction 6dof forces history\n* `rigidDof`:\n* `genTorque`: generator torque history\n* `genPower`: generator power history\n* `torqueDriveShaft`: driveshaft torque history\n* `uHist`: mesh displacement history for each dof\n* `epsilon_x_hist`: strain history for eps_xx_0 for each dof\n* `epsilon_y_hist`: strain history for eps_xx_z for each dof\n* `epsilon_z_hist`: strain history for eps_xx_y for each dof\n* `kappa_x_hist`: strain history for gam_xz_0 for each dof\n* `kappa_y_hist`: strain history for gam_xz_y for each dof\n* `kappa_z_hist`: strain history for gam_xy_0 for each dof\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#OWENS.calcHydroResidual-NTuple{5, Any}","page":"OWENS","title":"OWENS.calcHydroResidual","text":"calc_hydro_residual(new_accels, new_hydro_frcs, md_frc, u, FMultiplier)\n\nInternal, finds the residual of the platform accelerations/forces when adding in new values from HydroDyn, MoorDyn, and OWENSFEA.\n\nInput\n\nnew_accels::Vector{<:float}: the new platform accelerations in the inertial reference frame from OWENSFEA  (m/s/s)\nnew_hydro_frcs::Vector{<:float}: the new platform hydro forces in the inertial reference frame from HydroDyn (N)\nmd_frc::Vector{<:float}: the mooring forces at the platform in the inertial reference frame from MoorDyn (N)\nu::Vector{<:float}: input vector containing platform loads and accelerations prior to the new additions\nFMultiplier::Number: scaling factor used to make the loads/accelerations in the same magnitude for the Jacobians\n\nOutput\n\nu_resid: vector containing residual between the input u and the new load/accelerations\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#OWENS.calculateDriveShaftReactionTorque-NTuple{5, Any}","page":"OWENS","title":"OWENS.calculateDriveShaftReactionTorque","text":"calculateDriveShaftReactionTorque(driveShaftProps,thetaRotor,thetaGB,thetaDotRotor,thetaDotGB)\n\nInternal, calculates reaction torque of driveshaft\n\n#Input\n\ndriveShaftProps:    object containing driveshaft properties\nthetaRotor:         azimuth position of rotor/rotor shaft (rad)\nthetaGB:            azimuth position of gearbox shaft (rad)\nthetaDotRotor:      angular velocity of rotor/rotor shaft (rad/s)\nthetaDotGB:         angular velocity of gearbox shaft (rad/s)\n\n#Output\n\ntorque: reaction torque of drive shaft\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#OWENS.calculateElementOrientation-Tuple{Any}","page":"OWENS","title":"OWENS.calculateElementOrientation","text":"calculateElementOrientation(mesh)\n\nCalculates the orientation of elements in a mesh.\n\n#Input\n\nmesh::OWENSFEA.Mesh  see ?OWENSFEA.Mesh object containing mesh data\n\n#Output\n\nelOr::OWENSFEA.Ort  see ?OWENSFEA.Ort object containing element orientation data\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#OWENS.calculatePsiTheta-Tuple{Any}","page":"OWENS","title":"OWENS.calculatePsiTheta","text":"calculatePsiTheta(v)\n\nCalculates the orientation of a single element. A local element frame is related to a hub frame through a transformation matrix CHtoE (transforming a vector from an element frame E to a global frame H) such that CHtoE = [M2(Theta)]*[M3(Psi)]. Here [M2( )] is a direction cosine matrix about a 2 axis and [M3( )] is a direction cosine matrix about a 3 axis.\n\n#Input\n\nv:      vector from node 1 to node 2 of an element\n\n#Output\n\nPsi:    \"3\" angle for element orientation (deg)\nTheta:  \"2\" angle for element orientation (deg)\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#OWENS.count_cycles-Union{Tuple{T}, Tuple{AbstractVector{T}, Vector{Float64}}} where T","page":"OWENS","title":"OWENS.count_cycles","text":"Count the cycles from the data \n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#OWENS.createGeneralTransformationMatrix-Tuple{Any, Any}","page":"OWENS","title":"OWENS.createGeneralTransformationMatrix","text":"createGeneralTransformationMatrix(angleArray,axisArray)\n\nCalculates the transformation matrix assocaited with a general Euler rotation sequence.\n\n#Input\n\nangleArray:      = array of angles for Euler rotation sequence\naxisArray:       = array of axis of rotatoins for Euler rotation\n\n#Output\n\ndcmTotal:        = transformation matrix of specified euler rotation sequence\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#OWENS.createInitCondArray-Tuple{Any, Any, Any}","page":"OWENS","title":"OWENS.createInitCondArray","text":"setInitConditions(initDisps, numNodes, numDOFPerNode)\n\nCreates the formatted initial conditions array needed by OWENSFEA\n\n#Input\n\ninitDisps: an array of length numDOFPerNode specifying the initial displacement of each DOF\nnumNodes: the number of nodes in the given mesh\nnumDOFPerNode: the number of unconstrained degrees of freedom calculated in each node\n\n#Output\n\ninitCond: array containing initial conditions.   initCond(i,1) node number for init cond i.   initCond(i,2) local DOF number for init cond i.   initCond(i,3) value for init cond i.\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#OWENS.createSingleRotationDCM-Union{Tuple{T}, Tuple{T, Any}} where T","page":"OWENS","title":"OWENS.createSingleRotationDCM","text":"Creates a direction cosine matrix (dcm) associated with a rotation of angleDeg about axisNum.\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#OWENS.create_arcus_mesh-Tuple{}","page":"OWENS","title":"OWENS.create_arcus_mesh","text":"createarcusmesh(;Htwrbase = 15.0,     Hbld = 147.148-15.0, #blade height     R = 54.014, # m bade radius     nblade = 3,     ntelem = 30, #tower elements     nbelem = 30, #blade elements     ncelem = 4,     strutmountpoint = 0.01, # This puts struts at top and bottom     bshapex = zeros(nbelem+1), #Blade shape, magnitude is irrelevant, scaled based on height and radius above     bshapez = zeros(nbelem+1),     jointtype = 0,     cablesconnectedtoblade_base = true,     angularOffset = 0.0)\n\nARCUS mesh configuration: no tower between blades, no struts, but cables from top center attaching to specified blade mount point at base\n\n#Inputs\n\nHtwr_base::float: height of tower before blades attach (m)\nHbld::float: blade height (m)\nR::float: bade radius (m)\nnblade::int: number of blades\nntelem::int: number of tower elements\nnbelem::int: number of blade elements\nncelem::int: number of strut elements\nc_mount_ratio::float: factor of blade height where the struts attach on both top and bottom\nbshapex::Array{<:float}: Blade shape, magnitude is irrelevant, scaled based on height and radius above\nbshapez::Array{<:float}: Blade shape, magnitude is irrelevant, scaled based on height and radius above\njoint_type::int: 0 is fixed, 1 is about x-axis, 2 is y-axis, etc\ncables_connected_to_blade_base::bool: = true,\nangularOffset::float: (rad) angular offset of mesh generation, typically used to match CACTUS input.  Value of 0 puts blade 1 at the \"north\" position and the others populate counterclockwise when looking down\n\n#Outputs\n\nmymesh::OWENSFEA.Mesh: see ?OWENSFEA.Mesh\nort::OWENSFEA.Ort: see ?OWENSFEA.Ort\nmyjoint:Array{<:float}: see ?OWENSFEA.FEAModel.joint\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#OWENS.create_hawt_biwing_mesh-Tuple{}","page":"OWENS","title":"OWENS.create_hawt_biwing_mesh","text":"createhawtbiwingmesh(;Ht = 15.0,     Hb = 147.148-15.0, #blade height     R = 54.014, # m bade radius     nblade = 3,     ntelem = 30, #tower elements     nbelem = 30, #blade elements     ncelem = 4,     strutmountpoint = 0.01, # This puts struts at top and bottom     bshapex = zeros(nbelem+1), #Blade shape, magnitude is irrelevant, scaled based on height and radius above     bshapez = zeros(nbelem+1),     jointtype = 0,     cablesconnectedtoblade_base = true,     angularOffset = 0.0)\n\n#Inputs\n\nHt::float: height of tower before blades attach (m)\nHb::float: blade height (m)\nR::float: bade radius (m)\nnblade::int: number of blades\nntelem::int: number of tower elements\nnbelem::int: number of blade elements\nncelem::int: number of strut elements\nc_mount_ratio::float: factor of blade height where the struts attach on both top and bottom\nbshapex::Array{<:float}: Blade shape, magnitude is irrelevant, scaled based on height and radius above\nbshapez::Array{<:float}: Blade shape, magnitude is irrelevant, scaled based on height and radius above\njoint_type::int: 0 is fixed, 1 is about x-axis, 2 is y-axis, etc\ncables_connected_to_blade_base::bool: = true,\nangularOffset::float: (rad) angular offset of mesh generation, typically used to match CACTUS input.  Value of 0 puts blade 1 at the \"north\" position and the others populate counterclockwise when looking down\n\n#Outputs\n\nmymesh::OWENSFEA.Mesh: see ?OWENSFEA.Mesh\nort::OWENSFEA.Ort: see ?OWENSFEA.Ort\nmyjoint:Array{<:float}: see ?OWENSFEA.FEAModel.joint\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#OWENS.create_hawt_mesh-Tuple{}","page":"OWENS","title":"OWENS.create_hawt_mesh","text":"createhawtmesh(;Ht = 15.0,     Hb = 147.148-15.0, #blade height     R = 54.014, # m bade radius     nblade = 3,     ntelem = 30, #tower elements     nbelem = 30, #blade elements     ncelem = 4,     strutmountpoint = 0.01, # This puts struts at top and bottom     bshapex = zeros(nbelem+1), #Blade shape, magnitude is irrelevant, scaled based on height and radius above     bshapez = zeros(nbelem+1),     jointtype = 0,     cablesconnectedtobladebase = true,     angularOffset = 0.0)\n\nARCUS mesh configuration: no tower between blades, no struts, but cables from top center attaching to specified blade mount point at base\n\n#Inputs\n\nHt::float: height of tower before blades attach (m)\nHb::float: blade height (m)\nR::float: bade radius (m)\nnblade::int: number of blades\nntelem::int: number of tower elements\nnbelem::int: number of blade elements\nncelem::int: number of strut elements\nc_mount_ratio::float: factor of blade height where the struts attach on both top and bottom\nbshapex::Array{<:float}: Blade shape, magnitude is irrelevant, scaled based on height and radius above\nbshapez::Array{<:float}: Blade shape, magnitude is irrelevant, scaled based on height and radius above\njoint_type::int: 0 is fixed, 1 is about x-axis, 2 is y-axis, etc\ncables_connected_to_blade_base::bool: = true,\nangularOffset::float: (rad) angular offset of mesh generation, typically used to match CACTUS input.  Value of 0 puts blade 1 at the \"north\" position and the others populate counterclockwise when looking down\n\n#Outputs\n\nmymesh::OWENSFEA.Mesh: see ?OWENSFEA.Mesh\nort::OWENSFEA.Ort: see ?OWENSFEA.Ort\nmyjoint:Array{<:float}: see ?OWENSFEA.FEAModel.joint\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#OWENS.create_mesh_struts-Tuple{}","page":"OWENS","title":"OWENS.create_mesh_struts","text":"return mymesh, myort, myjoint, AD15bldNdIdxRng, AD15bldElIdxRng = createmeshcomponents(;Htwrbase = 15.0, Htwrblds = 147.148-15.0,     Hbld = 147.148-15.0, #blade height     R = 54.014, # m bade radius     AD15hubR = 2.0,     nblade = 3,     ntelem = 30, #tower elements     nbelem = 30, #blade elements     nselem = 4,     struttwrmountpoint = [0.01,0.5,0.9],     strutbldmountpoint = [0.01,0.5,0.9],     bshapex = zeros(nbelem+1), #Blade shape, magnitude is irrelevant, scaled based on height and radius above     bshapez = zeros(nbelem+1),     bshapey = zeros(nbelem+1), # but magnitude for this is relevant     angularOffset = 0.0, #Blade shape, magnitude is irrelevant, scaled based on height and radius above     AD15_ccw = false,     verbosity=0, # 0 nothing, 1 basic, 2 lots: amount of printed information     connectBldTips2Twr =true)\n\n#Inputs\n\nHtwr_base::float: height of tower before blades attach (m)\nHtwr_blds::float: height of the tower once the blades attach (m)\nHbld::float: blade height (m)\nR::float: bade radius (m)\nnblade::int: number of blades\nntelem::int: number of tower elements\nnbelem::int: number of blade elements\nnselem::int: number of strut elements\nstrut_twr_mountpoint::float = [0.01,0.5,0.9], # factor of blade height where the bottom strut attaches on the tower # This puts struts at top and bottom, as a fraction of the blade position\nstrut_bld_mountpoint::float = [0.01,0.5,0.9], # factor of blade height where the bottom strut attaches on the blade # This puts struts at bottom 0, mid 0.5, and top 1.0 as a fraction of the blade position\nbshapex::Array{<:float}: Blade shape, magnitude is irrelevant, scaled based on height and radius above\nbshapez::Array{<:float}: Blade shape, magnitude is irrelevant, scaled based on height and radius above\nbshapey::Array{<:float}: Blade shape, magnitude IS relevant #TODO: resolve this\nangularOffset::float: (rad) angular offset of mesh generation, typically used to match CACTUS input.  Value of 0 puts blade 1 at the \"north\" position and the others populate counterclockwise when looking down\nAD15_ccw::boolean: Use AD15 convention of VAWT counter-clockwise with blade root at top (blade points down)\nAD15hubR::float: AD15 has a hub radius, so the struts do not go all the way to the center of the axis of rotation, while the structural mesh does.\n\nverbosity::int: 0 nothing, 1 basic, 2 lots: amount of printed information\n\nconnectBldTips2Twr::book: True for Darrieus style, false for H-VAWT, but the blade shapes should be appropriate\n\n#Outputs\n\nmymesh::OWENSFEA.Mesh: see ?OWENSFEA.Mesh\nmyort::OWENSFEA.Ort: see ?OWENSFEA.Ort\nmyjoint:Array{<:float}: see ?OWENSFEA.FEAModel.joint\nAD15bldNdIdxRng: indices for start and end of all blades for AD15 (includes struts).  Note that strut start nodes may be inside the strut (strut connects to tower, AD15 blade connects to hub wich is a few nodes away from tower)\nAD15bldElIdxRng: range of elements for start and end of all AD15 blades (includes struts)\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#OWENS.externalForcing-NTuple{4, Any}","page":"OWENS","title":"OWENS.externalForcing","text":"externalForcing(time,timeArray,ForceValHist,ForceDof)\n\nInternal, linear time interpolation on the input forces (ForceValHist) for each specified ForceDof\n\nThis function specifies external forcing for a transient analysis. Fexternal is a vector of loads and Fdof is a corresponding vector of degrees of freedom the concentrated loads in Fexternal correspond to. The input time allows for arbitrary time varying loads The global degree of freedom number corresponding with the local degree of freedom of a node may be calculated by: globalDOFNumber = (nodeNumber-1)*6 + localDOFnumber The localDOFnumber may range from 1 to 6 such that 1 corresponds to a force in \"x direction\" of the co-rotating hub frame. 2 and 3 corresponds to a force in the \"y\" and \"z directions\" respectively. 4, 5, and 6 correspond to a moment about the \"x\", \"y\", and \"z\" directions respectively.\n\n#Input\n\ntime: Current time\ntimeArray: time associated with ForceValHist\nForceValHist: Forces for each time for each Dof\nForceDof: Dofs within ForceValHist\n\n#Output\n\nFexternal: vector of external loads (forces/moments)\nFdof:      vector of corresponding DOF numbers to apply loads to\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#OWENS.extrap_pred_vals-NTuple{4, Any}","page":"OWENS","title":"OWENS.extrap_pred_vals","text":"extrap_pred_vals(curr_vals, ts, t_out, interp_order)\n\nInternal, calculates predicted values at t_out based on previous values at earlier times.\n\nInput\n\ncurr_vals::Vector{<:float}: input values\nts::Vector{<:float}: time values corresponding to curr_vals. Left to right, times go from earliest to most recent.\nt_out::float: time for values to be extrapolated tocp\ninterp_order::int: order of the spline fit for the extrapolation, 0 flat, 1 linear, 2 quadratic\n\nOutput\n\npred_vals: extrapolated values at t_out\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#OWENS.find_boundary_vals-Tuple{Vector{OWENS.Cycle}}","page":"OWENS","title":"OWENS.find_boundary_vals","text":"Find the minimum and maximum mean value and maximum range from a vector of cycles\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#OWENS.find_range-Union{Tuple{T}, Tuple{Vector{T}, Any}} where T<:Real","page":"OWENS","title":"OWENS.find_range","text":"Returns the range index where the value is found \n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#OWENS.frame_convert-Tuple{Any, Any}","page":"OWENS","title":"OWENS.frame_convert","text":"frame_convert(init_frame_vals, trans_mat)\n\nInternal, transfers 6 DOFs element-wise to a new reference frame\n\nInput\n\ninit_frame_vals::Vector{<:float}: Values in 6 degrees of freedom in the initial reference frame\ntrans_mat::Array{<:float}: Transformation matrix to the output reference frame\n\nOutput\n\nout_frame_vals: Values in 6 degrees of freedom in the output reference frame\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#OWENS.getGustVel-NTuple{6, Any}","page":"OWENS","title":"OWENS.getGustVel","text":"time::TF: in seconds\nnominalVinf::TF: Nominal velocity used to calculate the IEC gust size (m/s)\nR::TF: Turbine Radius (m)\nG_amp::TF: IEC gust amplitude (m/s)\ngustT::TF: IEC gust duration (s)\ngustDelayT::TF: IEC gust delay time\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#OWENS.getOWENSPreCompOutput-Tuple{Any}","page":"OWENS","title":"OWENS.getOWENSPreCompOutput","text":"getOWENSPreCompOutput(numadIn;yscale=1.0,plyprops = plyproperties())\n\nTakes numad formatted inputs for composite layup and material properties and runs them through OWENSPreComp\n\n#Inputs\n\nnumadIn::NuMad: see ?NuMad inputs\nyscale::float: airfoil thickness scaling\nplyprops::plyproperties(): see ?plyproperties for input material properties\n\n#Outputs\n\nprecompoutput::OWENSPreComp.Output: see ?OWENSPreComp.Input\nprecompinput::OWENSPreComp.Input: see ?OWENSPreComp.properties\nlam_U::Composites.Laminate: laminate stacks used for post processing, size (nstations, nupper chorwise stations), upper surface, see ?Composites.Laminate\nlam_L::Composites.Laminate: laminate stacks used for post processing, size (nstations, nlower chorwise stations), lower surface, see ?Composites.Laminate\nlam_W::Composites.Laminate: laminate stacks used for post processing, size (nstations, nwebs), shear webs, see ?Composites.Laminate\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#OWENS.getRotorPosSpeedAccelAtTime-NTuple{4, Any}","page":"OWENS","title":"OWENS.getRotorPosSpeedAccelAtTime","text":"getRotorPosSpeedAccelAtTime(t0,time,aziInit)\n\nUses the user defined function rotorSpeedProfile() to get the azimuth, speed, and acceleration of the rotor.\n\n#Input\n\nt0      time at which azimuth integration is beginning\ntime    current time that position, velocity, and acceleration are being requested\naziInit initial rotor azimuth angle integration will begin at\n\n#Output\n\nrotorAzimuth azimuth position of rotor (rad) at time\nrotorSpeed   rotor speed (Hz) at time\nrotorAcceleration rotor acceleration (Hz/s) at time\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#OWENS.getSectPropsFromOWENSPreComp-Tuple{Any, Any, Any}","page":"OWENS","title":"OWENS.getSectPropsFromOWENSPreComp","text":"getSectPropsFromOWENSPreComp(usedUnitSpan,numadIn,precompoutput;GX=false,precompinputs=nothing,fluid_density=0.0,AddedMass_Coeff_Ca=1.0,N_airfoil_coord=100))\n\nArranges the precomp output into the sectional properties required by OWENSFEA\n\n#Inputs\n\nusedUnitSpan::Array{<:float}: Array specifying the relative (0-1) mesh z locations where the sectional properties are actually called for (interpolation)\nnumadIn::NuMAD: see ?NuMAD\nprecompoutput::OWENSPreComp.properties: see ?OWENSPreComp.properties\nGX::bool: optional specifies if GX outputs should be output\nprecompinputs: optional\nfluid_density::Float64: fluid density, used if added mass is on (AddedMassCoeffCa>0.0)\nAddedMass_Coeff_Ca::Float64: if >0.0, then added mass is calculated off of the airfoil geometry and included in the structures\nN_airfoil_coord::Int: Number of upper/lower common airfoil x points to spline to to enable VTK output of airfoil surface\n\n#Outputs\n\nsectionPropsArray::SectionPropsArray: see ?OWENSFEA.SectionPropsArray, if !GX bool\nstiff: if GX bool\nmass: if GX bool\n\nstiff, mass\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#OWENS.handle_control_strategy-NTuple{5, Any}","page":"OWENS","title":"OWENS.handle_control_strategy","text":"handle_control_strategy(controlStrategy, normalRPM, slowRPM, prescribed_time, prescribed_RPM)\n\nHandles different control strategies and returns the appropriate control parameters.\n\nArguments\n\ncontrolStrategy: The control strategy to use\nnormalRPM: The normal operating RPM\nslowRPM: The slow RPM for startup/shutdown\nprescribed_time: Time control points for prescribed RPM\nprescribed_RPM: RPM control points for prescribed RPM\n\nReturns\n\ntocp: Time control points\nOmegaocp: Angular velocity control points\nturbineStartup: Turbine startup flag\ngeneratorOn: Generator on flag\nuseGeneratorFunction: Use generator function flag\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#OWENS.mapACDMS-NTuple{5, Any}","page":"OWENS","title":"OWENS.mapACDMS","text":"mapACDMS(t,mesh,el)\n\nmap OWENSAero forces to OWENS mesh dofs\n\nInputs\n\nt::float: time at which to get the loads (can be called repeatedly at the same time or for large time gaps, will infill run as needed)\nmesh::OWENSFEA.Mesh: see ?OWENSFEA.Mesh\nmesh::OWENSFEA.El: see ?OWENSFEA.El\n\nOutputs:\n\nForceValHist::Array(<:float): Force or moment (N, N-m) at the time corresponding to the time specified\nForceDof::Array(<:int): DOF numbers cooresponding to forces (i.e. mesh element 1 has dofs 1-6, 2 has dofs 7-12, etc)\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#OWENS.mapAD15-NTuple{4, Any}","page":"OWENS","title":"OWENS.mapAD15","text":"mapAD15(t,mesh)\n\nmap AD15 forces to OWENS mesh dofs\n\nInputs\n\nt::float: time at which to get the loads (can be called repeatedly at the same time or for large time gaps, will infill run as needed)\nmesh::OWENSFEA.Mesh: see ?OWENSFEA.Mesh\nmesh::OWENSFEA.El: see ?OWENSFEA.El\n\nOutputs:\n\nForceValHist::Array(<:float): Force or moment (N, N-m) at the time corresponding to the time specified\nForceDof::Array(<:int): DOF numbers cooresponding to forces (i.e. mesh element 1 has dofs 1-6, 2 has dofs 7-12, etc)\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#OWENS.my_getABD!","page":"OWENS","title":"OWENS.my_getABD!","text":"my_getABD(matid::AbstractArray{<:Integer,1}, nply::AbstractArray{<:Integer,1}, tply::AbstractArray{<:Real,1}, theta::AbstractArray{<:Real,1}, q::AbstractArray{<:AbstractArray{<:Real,2},1}), offset::Real\n\nmy_getABD(lam::Laminate, q::AbstractArray{<:AbstractArray{<:Real,2},1}), offset::Real\n\nReturns A, B, and D matrices\n\nArguments:\n\nmatid::AbstractArray{<:Integer,1}: material id of each lamina\nnply::AbstractArray{<:Integer,1}: number of plies in each lamina\ntply::AbstractArray{<:Real,1}: thickness of a ply (m) in each lamina\ntheta::AbstractArray{<:Real,1}: orientation (deg) of each lamina\nq::AbstractArray{<:AbstractArray{<:Real,2}}: Stiffness matrix of each lamina\noffset::Real: Optional, used if neutral axis is not centered on the ply. If used, specify distance from neutral axis to upper surface (m).\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#OWENS.my_getplystrain","page":"OWENS","title":"OWENS.my_getplystrain","text":"my_getplystrain(nply::AbstractArray{<:Integer,1}, tply::AbstractArray{<:Real,1}, theta::AbstractArray{<:Real,1}, resultantstrain::AbstractArray{<:Real,1}, offset::Real)\n\nmy_getplystrain(lam::Laminate, resultantstrain::AbstractArray{<:Real,1}, offset::Real)\n\nOptional Argument\n\noffset::Real: Optional, used if neutral axis is not centered on the ply. If used, specify distance from neutral axis to upper surface (m).\n\nCalculates strains in each ply aligned with principal material direction.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#OWENS.my_getz","page":"OWENS","title":"OWENS.my_getz","text":"getz(tply::AbstractArray{<:Real,1}, nply::AbstractArray{<:Integer,1}, offset::Real)\n\ngetz(lam::Laminate, offset::Real)\n\nReturns a laminate's z-coordinates (coordinates of top and bottom of laminas) given the thickness of plies in each lamina and the number of plies in each lamina. Offset is optional, defaults to 0.0, is the distance from the neutal axis to the upper ply if the laminate is not centered about the neutral axis of a beam.\n\n\n\n\n\n","category":"function"},{"location":"reference/reference/#OWENS.mywrite_vtk-NTuple{5, Any}","page":"OWENS","title":"OWENS.mywrite_vtk","text":"mywrite_vtk(name, assembly::Assembly, [state::AssemblyState, ]λ::Number,\n    eigenstate::AssemblyState; scaling=1.0, mode_scaling=1.0, cycles=1,\n    steps=100)\n\nWrite a series of files corresponding to the elastic motion of the assembly about the deformed state encoded in state defined by the eigenvalue λ and the eigenvector encoded in eigenstate over the time period specified by time.\n\nThe steady-state deflections can be scaled with scaling and the eigenmode deflections can be scaled using mode_scaling.\n\nThe current time is encoded in the metadata tag \"time\"\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#OWENS.mywrite_vtk-Tuple{Any, Any}","page":"OWENS","title":"OWENS.mywrite_vtk","text":"mywrite_vtk(name, assembly::Assembly; kwargs...)\nmywrite_vtk(name, assembly::Assembly, state::AssemblyState; kwargs...)\nmywrite_vtk(name, assembly::Assembly, history::Vector{<:AssemblyState}], dt;\n    kwargs...)\n\nWrite the deformed geometry (and associated data) to a VTK file for visualization using ParaView.\n\nThe state argument may be omitted to write the original geometry to a VTK file without any associated data.\n\nIf the solution time history is provided, the time step must also be provided\n\nKeyword Arguments\n\nsections = nothing: Cross section geometry corresponding to each point,  defined in a frame aligned with the body frame but centered around the  corresponding point. Defined as an array with shape (3, ncross, np) where ncross  is the number of points in each cross section and np is the number of points.\nscaling=1.0: Parameter to scale the deflections (only valid if state is provided)\nmetadata=Dict(): Dictionary of metadata for the file(s)\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#OWENS.omegaSpecCheck-NTuple{4, Any}","page":"OWENS","title":"OWENS.omegaSpecCheck","text":"Internal, gets specified rotor speed at time\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#OWENS.plotMesh-NTuple{7, Any}","page":"OWENS","title":"OWENS.plotMesh","text":"plotMesh plots a mesh with various orthographic and isometric views plotMesh(mesh,colorstring,meshSeg)\n\nThis function plots a mesh in a 3D with isometric view.\n\n#Input\n\nmesh:         object containing mesh data\ncolorstring:  string containing color for plotting\nmeshSeg:      array containing number of elements per mesh segment\nax1: handle to the 1 plot\nax2: handle to the 2 plot\nax3: handle to the 3 plot\nax4: handle to the 4 plot\n\n#Output NONE\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#OWENS.preprocess_windio_setup-Tuple{Any, Any, Any}","page":"OWENS","title":"OWENS.preprocess_windio_setup","text":"preprocess_windio_setup(modelopt, windio, path)\n\nCreates and populates a SetupOptions instance from the windio and modelopt inputs.\n\nArguments\n\nmodelopt: The modeling options containing configuration parameters\nwindio: The windio data containing turbine geometry and properties\npath: The base path for file operations\n\nReturns\n\nSetupOptions: A populated SetupOptions instance containing all configuration parameters\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#OWENS.rainflow-Tuple{Any}","page":"OWENS","title":"OWENS.rainflow","text":"rainflow(signal;nbins_range=10,nbins_mean=10)\n\nConvenience function that returns the binned cycles with the corresponding ranges and means\n\nInputs\n\nsignal::Array{<:Real,1}: data input\nnbins_range::Array{<:Int,1}: Number of bins for range\nnbins_mean::Array{<:Int,1}: Number of bins for mean\nm` :    Wohler exponent (default is 3)\nTeq` : The equivalent number of load cycles (default is 1, but normally the time duration in seconds is used)\n\nOutputs:\n\nNcycles::Array{<:Real,2}: Summed/binned cycles with columns corresponding to mean levels and rows corresponding to range levels\nmeanIntervals::Array{<:Real,1}: Mean levels corresponging with bins columns\nrangeIntervals::Array{<:Real,1}: Range levels corresponging with bins rows\nequivalentLoad::Array{<:Real,1}: Design equivalent load for each mean level\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#OWENS.readBCdata-Tuple{Any, Any, Any}","page":"OWENS","title":"OWENS.readBCdata","text":"readBCdata(bcfilename, numNodes, numDOFPerNode)\n\nReads boundary condition data from a file and creates a boundary condition structure.\n\nThe boundary condition file should have the following format:\n\nFirst line: Number of boundary conditions (numpBC)\nFollowing lines: Space-separated values for each boundary condition:\nNode number\nLocal DOF number\nBoundary condition value (typically zero)\n\nArguments\n\nbcfilename::String: Path to the boundary condition file\nnumNodes::Int: Number of nodes in the structural model\nnumDOFPerNode::Int: Number of degrees of freedom per node\n\nReturns\n\nBC::OWENSFEA.BC_struct: Boundary condition structure containing:\nnumpBC: Number of displacement boundary conditions\npBC: Array of boundary conditions (node number, DOF, value)\nnumsBC: Number of spring boundary conditions (not used)\nnummBC: Number of mass boundary conditions (not used)\nisConstrained: Vector indicating which DOFs are constrained (0=unconstrained, 1=constrained)\nsBC: Spring boundary conditions (empty)\nmBC: Mass boundary conditions (empty)\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#OWENS.readBladeData-Tuple{Any}","page":"OWENS","title":"OWENS.readBladeData","text":"readBladeData(filename)\n\nReads blade data from a tab-delimited file and creates a BladeData structure.\n\nThe blade data file should have the following format:\n\nTab-delimited values with columns:\nBlade number\nStructural span location (normalized)\nNode number\nElement number\n(Optional) Additional data\n\nArguments\n\nfilename::String: Path to the blade data file (e.g., \"path/to/bladedata.bld\")\n\nReturns\n\nbladeData::BladeData: Structure containing:\nnumBlades: Number of blades\nbladeNum: Array of blade numbers\nh: Array of structural span locations\nnodeNum: Array of node numbers\nelementNum: Array of element numbers\nremaining: Any additional data from the file\n\nNotes\n\nThe file is expected to be tab-delimited\nThe function handles both blade and strut data sections\nStructural span locations are normalized by the maximum span\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#OWENS.readElementData-NTuple{4, Any}","page":"OWENS","title":"OWENS.readElementData","text":"readElementData(numElements,elfile,ortfile,bldfile\n\nReads element data and stores data in the element data object.\n\n#Input\n\nnumElements::int:  number of elements in structural mesh\nelfile::string:       element data path/to/filename\nortfile::string:      element orientation path/to/filename\nbldfile::string:      blade data path/to/filename\n\n#Output\n\nel::OWENSFEA.El:       see OWENSFEA.El    element data object\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#OWENS.readGeneratorProps-Tuple{Any}","page":"OWENS","title":"OWENS.readGeneratorProps","text":"readGeneratorProps(generatorfilename)\n\nThis function reads generator properties from file.\n\n#Input\n\ngeneratorfilenanme::string:  = string containing path/to/generatorfile\n\n#Output\n\ngenprops:    = model object containing generator properties\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#OWENS.readMesh-Tuple{Any}","page":"OWENS","title":"OWENS.readMesh","text":"readMesh(filename)\n\nReads the mesh file and stores data in the mesh object.\n\ninput:\n\nfilename::string string containing mesh path/to/filename.mesh\n\noutput:\n\nmesh::OWENSFEA.Mesh see OWENSFEA.Mesh\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#OWENS.readNuMadGeomCSV-Tuple{OrderedCollections.OrderedDict{Symbol, Any}}","page":"OWENS","title":"OWENS.readNuMadGeomCSV","text":"readNuMadGeomCSV(WindIO_Dict)\n\nParameters defining the rotor (apply to all sections).\n\nArguments\n\nWindIO_Dict::String: name of the numad excel CSV file being read (!!! THE NUMAD TAB MUST BE SAVED AS A CSV FOR THIS TO WORK !!!)\nWindIO_Dict::OrderedCollections.OrderedDict{Symbol, Any}: Alternatively, the already loaded in dictionary of windio inputs\n\nReturns\n\nOutput::NuMad: numad structure as defined in the NuMad structure docstrings.\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#OWENS.readNuMadMaterialsCSV-Tuple{Any}","page":"OWENS","title":"OWENS.readNuMadMaterialsCSV","text":"readNuMadMaterialsCSV(NuMadmaterialsxlscsv_file)\n\nParameters defining the rotor materials.\n\nArguments\n\nNuMad_materials_xlscsv_file::String: name of the numad excel CSV file being read (!!! THE NUMAD TAB MUST BE SAVED AS A CSV FOR THIS TO WORK !!!)\n\nReturns\n\nOutput::plyproperties: plyproperties structure as defined in the plyproperties structure docstrings.\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#OWENS.readResultsModalOut-Tuple{Any, Any}","page":"OWENS","title":"OWENS.readResultsModalOut","text":"Internal, reads modal file and returns freq, damp, and modeshapes\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#OWENS.rigidBodyRotation-NTuple{5, Any}","page":"OWENS","title":"OWENS.rigidBodyRotation","text":"rigidBodyRotation(B1,B2,B3,AngleArray,AxisArray)\n\nPerforms a coordinate transformation from a local body \"B\"(element) frame to a common hub frame \"H\" via a 3-2-3 euler rotation sequence\n\n#Input\n\nB1:         array containing body frame 1 coordinates of points to be mapped to the hub frame\nB2:         array containing body frame 2 coordinates of points to be mapped to the hub frame\nB3:         array containing body frame 3 coordinates of points to be mapped to the hub frame\nAngleArray:  Array of angles for Euler rotation sequence\nAxisArray:   Array of axes for Euler rotation sequence\n\n#Output\n\nH1:         array containg hub frame 1 coordinates of points mapped to the hub frame from body frame\nH2:         array containg hub frame 2 coordinates of points mapped to the hub frame from body frame\nH3:         array containg hub frame 3 coordinates of points mapped to the hub frame from body frame\n\nThat is CHtoB = [M3(SweepAngle)][M2(Theta)][M3(Psi)];\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#OWENS.run34m-NTuple{6, Any}","page":"OWENS","title":"OWENS.run34m","text":"run34m(inputs,feamodel,mymesh,myel,aeroForces,deformAero;steady=true,system=nothing,assembly=nothing,VTKFilename=\"./outvtk\")\n\nhelper function that rearranges the outputs into the expected 34m output     # Input     * inputs::Model: see ?Model     * topModel::FEAModel: see ?OWENSFEA.FEAModel     * mesh::Mesh: see ?OWENSFEA.Mesh     * el::El: see ?OWENSFEA.El     * aeroForces::function: Fexternal, Fdof = aero(t) where Fexternal is the force on each affected mesh dof and Fdof is the corresponding DOFs affected     * deformAero::function: see deformTurb(azi;newOmega=-1,newVinf=-1,bldx=-1,bldz=-1,bld_twist=-1,steady=false)     * steady::bool: run steadystate with no aero or not     * system: see ?GXBeam.System     * assembly: see ?GXBeam.Assembly     * VTKFilename::string: Unused: path and name of VTK output\n\n# Output\n* `eps_x`: strain history for eps_xx_0 for (Nbld,N_ts,mymesh.meshSeg[2]+1)\n* `eps_y`: strain history for eps_xx_z like above\n* `eps_z`: strain history for eps_xx_y like above\n* `kappa_x`: strain history for gam_xz_0 like above\n* `kappa_y`: strain history for gam_xz_y like above\n* `kappa_z`: strain history for gam_xy_0 like above\n* `t`: time array\n* `FReactionHist`: Nodal reaction 6dof forces history\n* `OmegaHist`: rotational speed array history\n* `genTorque`: generator torque history\n* `torqueDriveShaft`: driveshaft torque history\n* `aziHist`: azimuthal history array\n* `uHist`: mesh displacement history for each dof\n* `epsilon_x_hist`: strain history for eps_xx_0 for each dof\n* `epsilon_y_hist`: strain history for eps_xx_z for each dof\n* `epsilon_z_hist`: strain history for eps_xx_y for each dof\n* `kappa_x_hist`: strain history for gam_xz_0 for each dof\n* `kappa_y_hist`: strain history for gam_xz_y for each dof\n* `kappa_z_hist`: strain history for gam_xy_0 for each dof\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#OWENS.runDLC-Tuple{Any, Any, Any}","page":"OWENS","title":"OWENS.runDLC","text":"runDLC(modelopt,designparams,path;runScript = OWENS.runOWENSWINDIO)\n\n# Input\n* `modelopt::OWENS.ModelingOptions`: see ?OWENS.ModelingOption\n* `designparams::OWENS.Design_Data`: see ?OWENS.Design_Data\n* `path`: desired path to run everything\n* `runScript`: function handle to run script, defaults to OWENS.runOWENSWINDIO\n\n\n# Output\n* `nothing`:\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#OWENS.setupOWENS-Tuple{String}","page":"OWENS","title":"OWENS.setupOWENS","text":"setupOWENS(path::String; setup_options = SetupOptions(), VTKmeshfilename = nothing, verbosity = 1, return_componentized = false)\n\nSet up and configure an OWENS turbine mesh.\n\nThis function handles the setup process for an OWENS turbine model, including mesh generation, sectional properties calculation, and aerodynamic model initialization. It processes various configuration parameters and returns the assembled system components for analysis.\n\nArguments\n\npath::String: Base path for file operations and data access\n\nKeyword Arguments\n\nsetup_options: Configuration options for the turbine setup (default: SetupOptions())\nVTKmeshfilename: Optional filename for VTK mesh output\nverbosity: Level of output verbosity (default: 1)\nreturn_componentized: Whether to return componentized model (default: false)\n\nReturns\n\nWhen return_componentized=true:\n\nmymesh: Mesh properties\nmyel: Element properties\nmyort: Orientation properties\nmyjoint: Joint properties\ncomponents: Component definitions\naeroForces: Aerodynamic forces\ndeformAero: Aerodynamic deformation\nsystem: System properties\nassembly: Assembly properties\nsections: Section properties\n\nWhen return_componentized=false: Returns an extended set of properties including mass matrices, stiffness matrices, and various component-specific properties.\n\nNotes\n\nThe function performs mesh setup, sectional properties calculation, and aerodynamic model initialization\nSupports both AD15 and ACDMS aerodynamic models\nHandles both componentized and non-componentized return formats\nCalculates total mass and material costs when verbosity > 1\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#OWENS.simpleGenerator-Tuple{Any, Any}","page":"OWENS","title":"OWENS.simpleGenerator","text":"simpleGenerator(generatorProps,genSpeed)\n\nCaclulates generator torque for simple induction generator\n\n#Input\n\ngeneratorProps object containing generator properties, see ?inputs\ngenSpeed::float       generator speed (Hz)\n\n#Output\n\ngenTorque::float      generator torque\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#OWENS.sort_peaks-Union{Tuple{AbstractVector{T}}, Tuple{T}, Tuple{AbstractVector{T}, Any}} where T","page":"OWENS","title":"OWENS.sort_peaks","text":"This function sorts out points where the slope changes sign\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#OWENS.sum_cycles-Union{Tuple{T}, Tuple{Vector{OWENS.Cycle}, Union{StepRangeLen{T}, Vector{T}}, Union{StepRangeLen{T}, Vector{T}}}} where T<:Real","page":"OWENS","title":"OWENS.sum_cycles","text":"Sums the cycle count given intervals of rangeintervals and meanintervals. The rangeintervals and meanintervals are given in fraction of range size\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#OWENS.timeIntegrateSubSystem-NTuple{8, Any}","page":"OWENS","title":"OWENS.timeIntegrateSubSystem","text":"timeIntegrateSubSystem(M,K,C,F,delta_t,u,udot,uddot)\n\nInternal, performs integration of a system using the Newmark-Beta method (constant-average acceleration sceheme).\n\n#Input\n\nM:       system mass matrix\nK:       system sttiffness matrix\nC:       system damping matrix\nF:       system force vector\ndelta_t: time step\nu:       displacement at beginning of time step\nudot:    velocity at beginning of time step\nuddot:   acceleration at beginning of time step\n\n#Output\n\nunp1:       displacement at end of time step\nudotnp1:    velocity at end of time step\nuddotnp1:   acceleration at end of time step\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#OWENS.transMat-Tuple{Any, Any, Any}","page":"OWENS","title":"OWENS.transMat","text":"transMat(theta1, theta2, theta3)\n\nInternal, computes the 3x3 transformation matrix for given input rotations. The generated matrix is the closest orthonormal matrix to the Bernoulli-Euler transformation matrix from beam theory, which assumes small rotations. A full description of this matrix is found in the \"FASTCoordinateSystems.doc\" document by Jason Jonkman.\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#OWENS.trapezoidalRule-NTuple{4, Any}","page":"OWENS","title":"OWENS.trapezoidalRule","text":"Internal, simple trapezoidal rule integration\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#OWENS.updateRotorRotation-NTuple{9, Any}","page":"OWENS","title":"OWENS.updateRotorRotation","text":"updateRotorRotation updates rotor rotation\n\nupdateRotorRotation(Irotor,Crotor,Krotor,shaftTorque,genTorque,azi_s,Omega_s,OmegaDot_s,delta_t)\n\nInternal, updates the rotor rotation given rotor properties and external torques\n\n#Input\n\nIrotor:      rotor inertia\nCrotor:      arbitrary rotor damping\nKrotor:      arbitrary rotor stiffness\nshaftTorque: torque from external forces on rotor\ngenTorque:   torque from generator\nazi_s:       rotor azimuth (rad) at beginning of time step\nOmega_s:     rotor speed (Hz) at beginning of time step\nOmegaDot_s:  rotor acceleration (Hz/s) at beginning of time step\ndelta_t:     time step\n\n#Output\n\nazi_sp1:       rotor azimuth (rad) at end of time step\nOmega_sp1:     rotor speed (Hz/s) at end of time step\nOmegaDot_sp1:  rotor acceleration (Hz/s) at end of time step\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#OWENS.userDefinedRotorSpeedProfile-Tuple{Any}","page":"OWENS","title":"OWENS.userDefinedRotorSpeedProfile","text":"Internal, unused, userDefinedRotorSpeedProfile\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#OWENS.viz-Tuple{Any}","page":"OWENS","title":"OWENS.viz","text":"viz(;mesh=[],meshFile=\"none\",resultsFile=\"none\",selectedMode=10,sf=10)\n\nPlots the mode shapes of a mode from a modal analysis performed using the OWENS toolkit.  Either send the mesh struct or the mesh filename but not both\n\n#Input\n\nmesh::OWENSFEA.Mesh:    Mesh struct, See ?OWENSFEA.Mesh\nmeshFile::String:       optional string containing mesh file name\nresultsFile::String:    optional string containing results file name\nselectedMode::Int:      integer denoting selected mode to plot\nsf::Float:                scale factor for mode shape displacements\n\n#Output None\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#OWENS.writeOwensNDL-NTuple{4, Any}","page":"OWENS","title":"OWENS.writeOwensNDL","text":"writeOwensNDL(fileRoot, nodes, cmkType, cmkValues)\n\nwrites a nodal input file\n\n#Intput\n\nfileRoot::string: string path to desired location with name but no extension\nnodes::int: node numbers for C/M/K\ncmkType::string: \"C\" \"M\" or \"K\"\ncmkValues::float: C/M/K value\n\n#Output\n\nnone:\n\n\n\n\n\n","category":"method"},{"location":"FramesOfReference/","page":"-","title":"-","text":"OWENS X is outwards on blade, y is trailing edge always","category":"page"},{"location":"FramesOfReference/","page":"-","title":"-","text":"Struts, CCW, z is inwards, y trailing, and CW z is outwards","category":"page"},{"location":"FramesOfReference/","page":"-","title":"-","text":"Aerodyn ","category":"page"},{"location":"FramesOfReference/","page":"-","title":"-","text":"if CW z is up, y is trailing (root at bottom) blades, z is outwards and y is towards trailing edge.  If struts have asymmetric, then you need to align your desired suction side with the x-vector, which means you might have to invert your airfoil lookup tables for struts that the suction side isn’t where you want it.","category":"page"},{"location":"FramesOfReference/","page":"-","title":"-","text":"Aerodyn if CCW, root is at top and z is down, y is trailing edge, for struts, z is outwards, and y is trailing edge. ","category":"page"},{"location":"FramesOfReference/","page":"-","title":"-","text":"Hub is rotated such that the axis of rotation is x. So for a VAWT hub-x points up, and hawt hub-x point in x.","category":"page"},{"location":"FramesOfReference/","page":"-","title":"-","text":"(Image: ){width=\"4.917280183727034in\" height=\"4.585993000874891in\"}(Image: ){width=\"5.469136045494313in\" height=\"5.071805555555556in\"}Meet porcupine the OWENS element orientation helper. It is comprised of a tower, horizonal struts, and blades that have both curved and vertical sections. Let's start with all of the orientations set to 0. We can see that the 1,0,0 norm is in the positive x direction, and likewise for the y and z norms.","category":"page"},{"location":"FramesOfReference/","page":"-","title":"-","text":"Now, let's turn on just the yaw orientation, (psi in OWENS). The top blade gets a -90 degree yaw shift (like the other blades), and the other blades' yaw is additionally rotated to match the global blade orientation around the turbine axis of rotation. Yes the initial 90 degree shift is confusing, but it is the convention in the structural solver – is seems that the z-norm of the blade is intended to be eventually pointing away from the axis of rotation.","category":"page"},{"location":"FramesOfReference/","page":"-","title":"-","text":"(Image: ){width=\"5.595138888888889in\" height=\"4.875694444444444in\"}(Image: ){width=\"5.737141294838145in\" height=\"5.283430664916885in\"}","category":"page"},{"location":"FramesOfReference/","page":"-","title":"-","text":"If we add 30 degrees of rotation to the yaw, this is what it looks like.","category":"page"},{"location":"FramesOfReference/","page":"-","title":"-","text":"(Image: ){width=\"4.91704615048119in\" height=\"4.992732939632546in\"}","category":"page"},{"location":"FramesOfReference/","page":"-","title":"-","text":"Ok, let's now turn on roll (in addition to yaw), which is the blade slope, or theta in OWENS. Now, the z norm is no longer always vertical, but now aligned with the blade slope.","category":"page"},{"location":"FramesOfReference/","page":"-","title":"-","text":"(Image: ){width=\"4.382957130358705in\" height=\"4.783430664916885in\"}(Image: ){width=\"5.226388888888889in\" height=\"4.833333333333333in\"}","category":"page"},{"location":"FramesOfReference/","page":"-","title":"-","text":"(Image: ){width=\"4.406944444444444in\" height=\"3.9298611111111112in\"}If we add 30 degrees of roll, this is what it looks like:","category":"page"},{"location":"FramesOfReference/","page":"-","title":"-","text":"(Image: ){width=\"5.124857830271216in\" height=\"4.771802274715661in\"}","category":"page"},{"location":"FramesOfReference/","page":"-","title":"-","text":"(Image: ){width=\"4.45625in\" height=\"4.469444444444444in\"}Now, the blade pitch, also angle of attack, is generally 0, but can be offset similarly to the yaw, but the rotation is truly in a blade angle of attack frame of reference. Here it is with 30 degrees offset.","category":"page"},{"location":"FramesOfReference/","page":"-","title":"-","text":"(Image: ){width=\"4.095165135608049in\" height=\"4.388081802274716in\"}","category":"page"},{"location":"FramesOfReference/","page":"-","title":"-","text":"In all, these are the rotation matrices were used to create the plots: Twist/aoa about the x-axis, slope/theta about the y-axis, and psi/yaw about the z axis.","category":"page"},{"location":"FramesOfReference/","page":"-","title":"-","text":"# apply the twist rotation, which is about the x (1) axis","category":"page"},{"location":"FramesOfReference/","page":"-","title":"-","text":"myvec = myvec*[1.0 0.0 0.0","category":"page"},{"location":"FramesOfReference/","page":"-","title":"-","text":"0.0 cosd(Twistdel) sind(Twistdel)","category":"page"},{"location":"FramesOfReference/","page":"-","title":"-","text":"0.0 -sind(Twistdel) cosd(Twistdel)]","category":"page"},{"location":"FramesOfReference/","page":"-","title":"-","text":"# apply theta rotation, which is the tilt angle, or about the y (2) axis in global","category":"page"},{"location":"FramesOfReference/","page":"-","title":"-","text":"myvec = myvec*[cosd(Thetadel) 0.0 -sind(Thetadel)","category":"page"},{"location":"FramesOfReference/","page":"-","title":"-","text":"0.0 1.0 0.0","category":"page"},{"location":"FramesOfReference/","page":"-","title":"-","text":"sind(Thetadel) 0.0 cosd(Thetadel)]","category":"page"},{"location":"FramesOfReference/","page":"-","title":"-","text":"# apply Psi rotation, which is about Z (3) axis in global","category":"page"},{"location":"FramesOfReference/","page":"-","title":"-","text":"myvec = myvec*[cosd(Psidel) sind(Psidel) 0.0","category":"page"},{"location":"FramesOfReference/","page":"-","title":"-","text":"-sind(Psidel) cosd(Psidel) 0.0","category":"page"},{"location":"FramesOfReference/","page":"-","title":"-","text":"0.0 0.0 1.0]","category":"page"},{"location":"examples/C_customizablePreprocessing/#simple3","page":"Customizable Preprocessing","title":"Customizable Preprocessing","text":"","category":"section"},{"location":"examples/C_customizablePreprocessing/","page":"Customizable Preprocessing","title":"Customizable Preprocessing","text":"In this example, we show the third level of what is going on behind the precompiled binary This includes all of the second, but also breaks out the setupOWENS function. This would be a good starting point if you need to make modifications to use a unique mesh generation function, change how sectional properties are input, or adapt for a unique design an properly map the sectional properties to each element and apply unique boundary conditions, etc.","category":"page"},{"location":"examples/C_customizablePreprocessing/","page":"Customizable Preprocessing","title":"Customizable Preprocessing","text":"tip: Tip\nThis example is also available as a Jupyter notebook: C_customizablePreprocessing.ipynb.","category":"page"},{"location":"examples/C_customizablePreprocessing/","page":"Customizable Preprocessing","title":"Customizable Preprocessing","text":"This example is the same as example B except that the setupOWENS function is broken out and each step defined","category":"page"},{"location":"examples/C_customizablePreprocessing/","page":"Customizable Preprocessing","title":"Customizable Preprocessing","text":"import OWENS\nimport OWENSFEA\nimport OWENSAero\nimport QuadGK\nimport FLOWMath\n# import PyPlot\n# PyPlot.pygui(true)\nimport OWENSOpenFASTWrappers\n\n\nrunpath = path = \"/home/runner/work/OWENS.jl/OWENS.jl/examples/literate\" # to run locally, change to splitdir(@__FILE__)[1]\n# runpath = path = splitdir(@__FILE__)[1]\n\nInp = OWENS.MasterInput(\"$runpath/sampleOWENS.yml\")\n\nnothing","category":"page"},{"location":"examples/C_customizablePreprocessing/","page":"Customizable Preprocessing","title":"Customizable Preprocessing","text":"Unpack inputs, or you could directly input them here and bypass the file","category":"page"},{"location":"examples/C_customizablePreprocessing/","page":"Customizable Preprocessing","title":"Customizable Preprocessing","text":"verbosity = 1\n\nanalysisType = Inp.analysisType\nturbineType = Inp.turbineType\neta = Inp.eta\nNbld = Inp.Nbld\ntowerHeight = Inp.towerHeight\nrho = Inp.rho\nVinf = Inp.Vinf\ncontrolStrategy = Inp.controlStrategy\nRPM = Inp.RPM\nNslices = Inp.Nslices\nntheta = Inp.ntheta\nstructuralModel = Inp.structuralModel\nntelem = Inp.ntelem\nnbelem = Inp.nbelem\nncelem = Inp.ncelem\nnselem = Inp.nselem\nifw = Inp.ifw\nWindType = Inp.WindType\nAeroModel = Inp.AeroModel\nwindINPfilename = \"$(path)$(Inp.windINPfilename)\"\nifw_libfile = Inp.ifw_libfile\nif ifw_libfile == \"nothing\"\n    ifw_libfile = nothing\nend\nBlade_Height = Inp.Blade_Height\nBlade_Radius = Inp.Blade_Radius\nnumTS = Inp.numTS\ndelta_t = Inp.delta_t\nNuMad_geom_xlscsv_file_twr = \"$(path)$(Inp.NuMad_geom_xlscsv_file_twr)\"\nNuMad_mat_xlscsv_file_twr = \"$(path)$(Inp.NuMad_mat_xlscsv_file_twr)\"\nNuMad_geom_xlscsv_file_bld = \"$(path)$(Inp.NuMad_geom_xlscsv_file_bld)\"\nNuMad_mat_xlscsv_file_bld = \"$(path)$(Inp.NuMad_mat_xlscsv_file_bld)\"\nNuMad_geom_xlscsv_file_strut = \"$(path)$(Inp.NuMad_geom_xlscsv_file_strut)\"\nNuMad_mat_xlscsv_file_strut = \"$(path)$(Inp.NuMad_mat_xlscsv_file_strut)\"\nadi_lib = Inp.adi_lib\nif adi_lib == \"nothing\"\n    adi_lib = nothing\nend\nadi_rootname = \"$(path)$(Inp.adi_rootname)\"\n\nprintln(\"Set up Turbine\")\n\nAD15On = true\nB = Nbld\nR = Blade_Radius#177.2022*0.3048 #m\nH = Blade_Height#1.02*R*2 #m\n\nshapeZ = collect(LinRange(0,H,Nslices+1))\nshapeX = R.*(1.0.-4.0.*(shapeZ/H.-.5).^2)\nshapeY = zeros(Nslices+1)\n\n\nstack_layers_bld = nothing\nstack_layers_scale = [1.0,1.0]\nchord_scale = [1.0,1.0]\nthickness_scale = [1.0,1.0]\nHtwr_base=towerHeight\nstrut_mountpointbot = 0.11\nstrut_mountpointtop = 0.89\njoint_type = 0\nc_mount_ratio = 0.05\nangularOffset = -pi/2\ncustommesh = nothing\nif AeroModel==\"AD\" #TODO: unify flag\n    AD15On=true #AD for AeroDyn, DMS for double multiple streamtube, AC for actuator cylinder\nelse\n    AD15On=false\nend\nDynamicStallModel=\"BV\"\nRPI=true\ncables_connected_to_blade_base = true\nmeshtype = \"Darrieus\"\n\nnothing","category":"page"},{"location":"examples/C_customizablePreprocessing/","page":"Customizable Preprocessing","title":"Customizable Preprocessing","text":"Here is where we take the inputs from setupOWENS and break out what is going on behind the function. We do some intermediate calculations on the blade shape and angles","category":"page"},{"location":"examples/C_customizablePreprocessing/","page":"Customizable Preprocessing","title":"Customizable Preprocessing","text":"Nstrutperbld = 2 #TODO: generalize and propogate\nstrut_twr_mountpoint = [0.25,0.75]\nstrut_bld_mountpoint = [0.25,0.75]\nNbld = B\nH = maximum(shapeZ) #m,\nHtwr_blds = H\nAD15hubR = 0.1\nR = maximum(shapeX) #m,\nomega = RPM / 60 * 2 * pi\ntsr = omega*R/Vinf\n\nnothing","category":"page"},{"location":"examples/C_customizablePreprocessing/","page":"Customizable Preprocessing","title":"Customizable Preprocessing","text":"Here we set up the mesh using one of the pre-made meshing functions.  For this case, there is a function for the ARCUS, as well as for towered VAWTs where you can have an arbitrary blade shape with connected struts, and if the blade tips touch the tower, then you can tell it to constrain them to the tower thus allowing for both H-VAWT and Darrieus designs.","category":"page"},{"location":"examples/C_customizablePreprocessing/","page":"Customizable Preprocessing","title":"Customizable Preprocessing","text":"#########################################\n### Set up mesh\n#########################################\nif meshtype == \"ARCUS\" && custommesh == nothing #TODO, for all of these propogate the AeroDyn additional output requirements\n    mymesh,myort,myjoint, AD15bldNdIdxRng, AD15bldElIdxRng = OWENS.create_arcus_mesh(;Htwr_base,\n        Hbld = H, #blade height\n        R, # m bade radius\n        nblade = Nbld,\n        ntelem, #tower elements\n        nbelem, #blade elements\n        ncelem,\n        c_mount_ratio,\n        bshapex = shapeX, #Blade shape, magnitude is irrelevant, scaled based on height and radius above\n        bshapez = shapeZ,\n        AD15_ccw = true,\n        joint_type, #hinged about y axis\n        cables_connected_to_blade_base,\n        angularOffset) #Blade shape, magnitude is irrelevant, scaled based on height and radius above\nelseif (meshtype == \"Darrieus\" || meshtype == \"H-VAWT\") && custommesh == nothing\n\n    if meshtype == \"Darrieus\"\n        connectBldTips2Twr = true\n    else\n        connectBldTips2Twr = false\n    end\n\n    mymesh, myort, myjoint, AD15bldNdIdxRng, AD15bldElIdxRng = OWENS.create_mesh_struts(;Htwr_base,\n        Htwr_blds,\n        Hbld = H, #blade height\n        R, # m bade radius\n        AD15hubR, #TODO: hook up with AD15 file generation\n        nblade = Nbld,\n        ntelem, #tower elements\n        nbelem, #blade elements\n        nselem,\n        strut_twr_mountpoint,\n        strut_bld_mountpoint,\n        bshapex = shapeX, #Blade shape, magnitude is irrelevant, scaled based on height and radius above\n        bshapez = shapeZ,\n        bshapey = shapeY, # but magnitude for this is relevant\n        angularOffset, #Blade shape, magnitude is irrelevant, scaled based on height and radius above\n        AD15_ccw = true,\n        verbosity=0, # 0 nothing, 1 basic, 2 lots: amount of printed information\n        connectBldTips2Twr)\nelseif custommesh != nothing\n    mymesh, myort, myjoint, AD15bldNdIdxRng, AD15bldElIdxRng = custommesh(;Htwr_base,\n    Htwr_blds,\n    Hbld = H, #blade height\n    R, # m bade radius\n    AD15hubR, #TODO: hook up with AD15 file generation\n    nblade = Nbld,\n    ntelem, #tower elements\n    nbelem, #blade elements\n    nselem,\n    strut_twr_mountpoint,\n    strut_bld_mountpoint,\n    bshapex = shapeX, #Blade shape, magnitude is irrelevant, scaled based on height and radius above\n    bshapez = shapeZ,\n    bshapey = shapeY, # but magnitude for this is relevant\n    angularOffset, #Blade shape, magnitude is irrelevant, scaled based on height and radius above\n    AD15_ccw = true,\n    verbosity=0, # 0 nothing, 1 basic, 2 lots: amount of printed information)\n    )\nelse #TODO unify with HAWT\n    error(\"please choose a valid mesh type (Darrieus, H-VAWT, ARCUS)\")\nend\n\nnTwrElem = Int(mymesh.meshSeg[1])\ntry\n    if contains(NuMad_mat_xlscsv_file_bld,\"34m\") || meshtype == \"ARCUS\" #TODO: this is really odd,\n        nTwrElem = Int(mymesh.meshSeg[1])+1\n    end\ncatch\n    nTwrElem = Int(mymesh.meshSeg[1])\nend\n\nnothing","category":"page"},{"location":"examples/C_customizablePreprocessing/","page":"Customizable Preprocessing","title":"Customizable Preprocessing","text":"Here is a way that you can visualize the nodal numbers of the mesh PyPlot.figure() for icon = 1:length(mymesh.conn[:,1])     idx1 = mymesh.conn[icon,1]     idx2 = mymesh.conn[icon,2]     PyPlot.plot3D([mymesh.x[idx1],mymesh.x[idx2]],[mymesh.y[idx1],mymesh.y[idx2]],[mymesh.z[idx1],mymesh.z[idx2]],\"k.-\")     PyPlot.text3D(mymesh.x[idx1].+rand()/30,mymesh.y[idx1].+rand()/30,mymesh.z[idx1].+rand()/30,\"idx1ha=centerva=center)      sleep(01) end for ijoint = 1length(myjoint1)     idx2 = Int(myjointijoint2)     idx1 = Int(myjointijoint3)     PyPlotplot3D(mymeshxidx1mymeshxidx2mymeshyidx1mymeshyidx2mymeshzidx1mymeshzidx2r-)     PyPlottext3D(mymeshxidx1+rand()30mymeshyidx1+rand()30mymeshzidx1+rand()30idx1\",color=\"r\",ha=\"center\",va=\"center\")     PyPlot.text3D(mymesh.x[idx2].+rand()/30,mymesh.y[idx2].+rand()/30,mymesh.z[idx2].+rand()/30,\"idx2\",color=\"r\",ha=\"center\",va=\"center\")     #### sleep(0.1) end PyPlot.xlabel(\"x\") PyPlot.ylabel(\"y\") PyPlot.zlabel(\"z\")","category":"page"},{"location":"examples/C_customizablePreprocessing/","page":"Customizable Preprocessing","title":"Customizable Preprocessing","text":"This is where the sectional properties for the tower are either read in from the file, or are directly input and could be manuplated here in the script","category":"page"},{"location":"examples/C_customizablePreprocessing/","page":"Customizable Preprocessing","title":"Customizable Preprocessing","text":"#########################################\n### Set up Sectional Properties\n#########################################\n\nif !isnothing(NuMad_geom_xlscsv_file_twr)\n    numadIn_twr = OWENS.readNuMadGeomCSV(NuMad_geom_xlscsv_file_twr;section=:tower)\nelse\n    n_web = 0\n    n_stack = 2\n    n_segments = 2\n    span = [0.0, 6.607421057, 13.21484211, 19.82226317, 26.42968423, 33.03710529, 39.64452634, 46.2519474, 52.85936846, 59.46678951, 66.07421057, 72.68163163, 79.28905268, 85.89647374, 92.5038948, 99.11131586, 105.7187369, 112.326158, 118.933579, 125.5410001, 132.1484211]\n    airfoil = [\"circular\", \"circular\", \"circular\", \"circular\", \"circular\", \"circular\", \"circular\", \"circular\", \"circular\", \"circular\", \"circular\", \"circular\", \"circular\", \"circular\", \"circular\", \"circular\", \"circular\", \"circular\", \"circular\", \"circular\", \"circular\"]\n    te_type = [\"round\", \"round\", \"round\", \"round\", \"round\", \"round\", \"round\", \"round\", \"round\", \"round\", \"round\", \"round\", \"round\", \"round\", \"round\", \"round\", \"round\", \"round\", \"round\", \"round\", \"round\"]\n    twist_d = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n    chord = [10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 0.25, 0.25, 0.25]\n    xoffset = [0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5]\n    aerocenter = [0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25]\n    stack_mat_types = [8, 2]\n    stack_layers = [70 3; 70 3; 70 3; 30.303 3.03; 30.303 3.03; 30.303 3.03; 30.303 3.03; 30.303 3.03; 30.303 3.03; 30.303 3.03; 30.303 3.03; 30.303 3.03; 30.303 3.03; 30.303 3.03; 30.303 3.03; 30.303 3.03; 30.303 3.03; 30.303 3.03; 30.303 3.03; 30.303 3.03; 30.303 3.03]\n    segments = [-1.0 0.0 1.0; -1.0 0.0 1.0; -1.0 0.0 1.0; -1.0 0.0 1.0; -1.0 0.0 1.0; -1.0 0.0 1.0; -1.0 0.0 1.0; -1.0 0.0 1.0; -1.0 0.0 1.0; -1.0 0.0 1.0; -1.0 0.0 1.0; -1.0 0.0 1.0; -1.0 0.0 1.0; -1.0 0.0 1.0; -1.0 0.0 1.0; -1.0 0.0 1.0; -1.0 0.0 1.0; -1.0 0.0 1.0; -1.0 0.0 1.0; -1.0 0.0 1.0; -1.0 0.0 1.0]\n    DPtypes = [\"\" \"\" \"\"; \"\" \"\" \"\"; \"\" \"\" \"\"; \"\" \"\" \"\"; \"\" \"\" \"\"; \"\" \"\" \"\"; \"\" \"\" \"\"; \"\" \"\" \"\"; \"\" \"\" \"\"; \"\" \"\" \"\"; \"\" \"\" \"\"; \"\" \"\" \"\"; \"\" \"\" \"\"; \"\" \"\" \"\"; \"\" \"\" \"\"; \"\" \"\" \"\"; \"\" \"\" \"\"; \"\" \"\" \"\"; \"\" \"\" \"\"; \"\" \"\" \"\"; \"\" \"\" \"\"]\n    skin_seq = [Seq([2, 1, 2]) Seq([2, 1, 2]); Seq([2, 1, 2]) Seq([2, 1, 2]); Seq([2, 1, 2]) Seq([2, 1, 2]); Seq([2, 1, 2]) Seq([2, 1, 2]); Seq([2, 1, 2]) Seq([2, 1, 2]); Seq([2, 1, 2]) Seq([2, 1, 2]); Seq([2, 1, 2]) Seq([2, 1, 2]); Seq([2, 1, 2]) Seq([2, 1, 2]); Seq([2, 1, 2]) Seq([2, 1, 2]); Seq([2, 1, 2]) Seq([2, 1, 2]); Seq([2, 1, 2]) Seq([2, 1, 2]); Seq([2, 1, 2]) Seq([2, 1, 2]); Seq([2, 1, 2]) Seq([2, 1, 2]); Seq([2, 1, 2]) Seq([2, 1, 2]); Seq([2, 1, 2]) Seq([2, 1, 2]); Seq([2, 1, 2]) Seq([2, 1, 2]); Seq([2, 1, 2]) Seq([2, 1, 2]); Seq([2, 1, 2]) Seq([2, 1, 2]); Seq([2, 1, 2]) Seq([2, 1, 2]); Seq([2, 1, 2]) Seq([2, 1, 2]); Seq([2, 1, 2]) Seq([2, 1, 2])]\n    web_seq = Array{Seq, 2}(undef, length(twist_d),0) #can be any number of stack nums, so we have to make non-square containers\n    web_dp = Array{Seq, 2}(undef, length(twist_d),0) #this is fixed size square, but it's easier to do it this way\n\n    numadIn_twr = NuMad(n_web,n_stack,n_segments,span,airfoil,te_type,twist_d,chord,xoffset,aerocenter,stack_mat_types,stack_layers,segments,DPtypes,skin_seq,web_seq,web_dp)\nend\n\n#### Add the full path\nfor (i,airfoil) in enumerate(numadIn_twr.airfoil)\n    numadIn_twr.airfoil[i] = \"$path/airfoils/$airfoil\"\nend\n\nnothing","category":"page"},{"location":"examples/C_customizablePreprocessing/","page":"Customizable Preprocessing","title":"Customizable Preprocessing","text":"Here is where the material properties for the tower are either read in from the file, or directly input","category":"page"},{"location":"examples/C_customizablePreprocessing/","page":"Customizable Preprocessing","title":"Customizable Preprocessing","text":"if !isnothing(NuMad_mat_xlscsv_file_twr)\n    plyprops_twr = OWENS.readNuMadMaterialsCSV(NuMad_mat_xlscsv_file_twr)\nelse\n    names = [\"CLA_5500\", \"CBX_2400\", \"ETLX_2400\", \"Airex_C70_55\", \"EBX_2400_x10\", \"ETLX_2400_x10\", \"Airex_C70_55_x10\", \"CFP-baseline\"]\n    plies = [Composites.Material{Float64}(9.824e10, 5.102e9, 4.274e9, 0.3, 1540.0, 8.75634139e8, 5.92949102e8, 1.0e8, 1.0e8, 1.0e8, 0.00066), Composites.Material{Float64}(1.4931e10, 1.4931e10, 2.389e10, 0.3, 1530.0, 4.55053962e8, 4.55053962e8, 1.0e8, 1.0e8, 1.0e8, 0.0008100000000000001), Composites.Material{Float64}(2.0333e10, 9.305e9, 4.756e9, 0.3, 1900.0, 5.30896289e8, 5.30896289e8, 1.0e8, 1.0e8, 1.0e8, 0.00066), Composites.Material{Float64}(4.5e7, 4.5e7, 2.2e7, 0.2, 59.0, 1.0e8, 1.0e8, 1.0e8, 1.0e8, 1.0e8, 0.001), Composites.Material{Float64}(9.824e11, 5.102e10, 4.274e10, 0.3, 15300.0, 4.55053962e9, 4.55053962e9, 1.0e8, 1.0e8, 1.0e8, 7.000000000000001e-5), Composites.Material{Float64}(1.4931e11, 1.4931e11, 2.389e11, 0.3, 19000.0, 5.30896289e9, 5.30896289e9, 1.0e8, 1.0e8, 1.0e8, 8.0e-5), Composites.Material{Float64}(2.03335e11, 9.3051e10, 4.756e10, 0.2, 590.0, 1.0e9, 1.0e9, 1.0e8, 1.0e8, 1.0e8, 7.000000000000001e-5), Composites.Material{Float64}(1.576e11, 9.1e9, 3.3e9, 0.263, 1600.0, 2.236e9, 1.528e9, 1.0e8, 1.0e8, 1.0e8, 0.00066)]\n    plyprops_twr = OWENS.plyproperties(names,plies)\nend","category":"page"},{"location":"examples/C_customizablePreprocessing/","page":"Customizable Preprocessing","title":"Customizable Preprocessing","text":"Then this is where precomp.jl is called to get first the precomp outputs, then formatting those into the OWENS format, and then in the GXBeam.jl format for if GXBeam is used as the structural solver.","category":"page"},{"location":"examples/C_customizablePreprocessing/","page":"Customizable Preprocessing","title":"Customizable Preprocessing","text":"twr_precompoutput,twr_precompinput,lam_U_twr,lam_L_twr,lam_W_twr = OWENS.getOWENSPreCompOutput(numadIn_twr;plyprops = plyprops_twr)\nsectionPropsArray_twr = OWENS.getSectPropsFromOWENSPreComp(LinRange(0,1,nTwrElem),numadIn_twr,twr_precompoutput;precompinputs=twr_precompinput)\nstiff_twr, mass_twr = OWENS.getSectPropsFromOWENSPreComp(LinRange(0,1,nTwrElem),numadIn_twr,twr_precompoutput;GX=true)\n\nnothing","category":"page"},{"location":"examples/C_customizablePreprocessing/","page":"Customizable Preprocessing","title":"Customizable Preprocessing","text":"For the blades, we repeat what was done for the tower, but also include some simple design options for scaling thicknesses,","category":"page"},{"location":"examples/C_customizablePreprocessing/","page":"Customizable Preprocessing","title":"Customizable Preprocessing","text":"if !isnothing(NuMad_geom_xlscsv_file_bld)\n    numadIn_bld = OWENS.readNuMadGeomCSV(NuMad_geom_xlscsv_file_bld;section=:blade)\nelse\n    n_web = 1\n    n_stack = 7\n    n_segments = 12\n    span = [0.0, 6.607, 13.215, 19.822, 26.43, 33.037, 39.645, 46.252, 52.859, 59.467, 66.074, 72.682, 79.289, 85.896, 92.504, 99.111, 105.719, 112.326, 118.934, 125.541, 132.148]\n    airfoil = [\"circular\", \"NACA_0021\", \"NACA_0021\", \"NACA_0021\", \"NACA_0021\", \"NACA_0021\", \"NACA_0021\", \"NACA_0021\", \"NACA_0021\", \"NACA_0021\", \"NACA_0021\", \"NACA_0021\", \"NACA_0021\", \"NACA_0021\", \"NACA_0021\", \"NACA_0021\", \"NACA_0021\", \"NACA_0021\", \"NACA_0021\", \"NACA_0021\", \"NACA_0021\"]\n    te_type = [\"round\", \"sharp\", \"sharp\", \"sharp\", \"sharp\", \"sharp\", \"sharp\", \"sharp\", \"sharp\", \"sharp\", \"sharp\", \"sharp\", \"sharp\", \"sharp\", \"sharp\", \"sharp\", \"sharp\", \"sharp\", \"sharp\", \"sharp\", \"sharp\"]\n    twist_d = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n    chord = [10.0, 10.0, 9.0, 8.0, 8.0, 7.0, 7.0, 6.0, 6.0, 6.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0]\n    xoffset = [0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3]\n    aerocenter = [0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2]\n    stack_mat_types = [8, 2, 4, 8, 8, 8, 4]\n    if isnothing(stack_layers_bld)\n        stack_layers = [30.0 2.0 15.0 25.0 25.0 2.0 13.0; 15.0 2.0 10.0 13.0 11.0 2.0 11.0; 10.0 1.0 8.0 10.0 10.0 2.0 10.0; 8.0 1.0 6.0 9.0 10.0 1.0 9.0; 7.0 1.0 5.0 8.0 9.0 1.0 7.0; 6.0 1.0 4.0 8.0 9.0 1.0 6.0; 6.0 1.0 4.0 8.0 8.0 1.0 5.0; 6.0 1.0 4.0 7.0 7.0 1.0 5.0; 7.0 1.0 3.0 6.0 6.0 1.0 5.0; 8.0 1.0 3.0 6.0 6.0 1.0 5.0; 8.0 1.0 3.0 6.0 6.0 1.0 5.0; 7.0 1.0 3.0 6.0 6.0 1.0 5.0; 7.0 1.0 3.0 6.0 6.0 2.0 5.0; 7.0 1.0 3.0 6.0 6.0 2.0 5.0; 7.0 1.0 3.0 7.0 8.0 3.0 5.0; 7.0 2.0 3.0 9.0 12.0 3.0 6.0; 10.0 3.0 4.0 11.0 15.0 3.0 6.0; 12.0 3.0 4.0 13.0 15.0 3.0 6.0; 12.0 3.0 4.0 15.0 15.0 3.0 6.0; 12.0 3.0 4.0 15.0 15.0 3.0 6.0; 10.0 1.0 4.0 10.0 12.0 1.0 5.0]\n    else\n        stack_layers = stack_layers_bld\n    end\n    segments = [-1.0 -0.95 -0.5 -0.3 -0.1 -0.095 0.0 0.095 0.1 0.3 0.5 0.95 1.0; -1.0 -0.95 -0.5 -0.3 -0.1 -0.095 0.0 0.095 0.1 0.3 0.5 0.95 1.0; -1.0 -0.95 -0.5 -0.3 -0.1 -0.095 0.0 0.095 0.1 0.3 0.5 0.95 1.0; -1.0 -0.95 -0.5 -0.3 -0.1 -0.095 0.0 0.095 0.1 0.3 0.5 0.95 1.0; -1.0 -0.95 -0.5 -0.3 -0.1 -0.095 0.0 0.095 0.1 0.3 0.5 0.95 1.0; -1.0 -0.95 -0.5 -0.3 -0.1 -0.095 0.0 0.095 0.1 0.3 0.5 0.95 1.0; -1.0 -0.95 -0.5 -0.3 -0.1 -0.095 0.0 0.095 0.1 0.3 0.5 0.95 1.0; -1.0 -0.95 -0.5 -0.3 -0.1 -0.095 0.0 0.095 0.1 0.3 0.5 0.95 1.0; -1.0 -0.95 -0.5 -0.3 -0.1 -0.095 0.0 0.095 0.1 0.3 0.5 0.95 1.0; -1.0 -0.95 -0.5 -0.3 -0.1 -0.095 0.0 0.095 0.1 0.3 0.5 0.95 1.0; -1.0 -0.95 -0.5 -0.3 -0.1 -0.095 0.0 0.095 0.1 0.3 0.5 0.95 1.0; -1.0 -0.95 -0.5 -0.3 -0.1 -0.095 0.0 0.095 0.1 0.3 0.5 0.95 1.0; -1.0 -0.95 -0.5 -0.3 -0.1 -0.095 0.0 0.095 0.1 0.3 0.5 0.95 1.0; -1.0 -0.95 -0.5 -0.3 -0.1 -0.095 0.0 0.095 0.1 0.3 0.5 0.95 1.0; -1.0 -0.95 -0.5 -0.3 -0.1 -0.095 0.0 0.095 0.1 0.3 0.5 0.95 1.0; -1.0 -0.95 -0.5 -0.3 -0.1 -0.095 0.0 0.095 0.1 0.3 0.5 0.95 1.0; -1.0 -0.95 -0.5 -0.3 -0.1 -0.095 0.0 0.095 0.1 0.3 0.5 0.95 1.0; -1.0 -0.95 -0.5 -0.3 -0.1 -0.095 0.0 0.095 0.1 0.3 0.5 0.95 1.0; -1.0 -0.95 -0.5 -0.3 -0.1 -0.095 0.0 0.095 0.1 0.3 0.5 0.95 1.0; -1.0 -0.95 -0.5 -0.3 -0.1 -0.095 0.0 0.095 0.1 0.3 0.5 0.95 1.0; -1.0 -0.95 -0.5 -0.3 -0.1 -0.095 0.0 0.095 0.1 0.3 0.5 0.95 1.0]\n    DPtypes = [\"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\"; \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\"; \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\"; \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\"; \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\"; \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\"; \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\"; \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\"; \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\"; \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\"; \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\"; \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\"; \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\"; \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\"; \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\"; \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\"; \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\"; \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\"; \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\"; \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\"; \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\"]\n    skin_seq = [Seq([2, 5, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 1, 2]) Seq([2, 1, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 5, 2]); Seq([2, 5, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 1, 2]) Seq([2, 1, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 5, 2]); Seq([2, 5, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 1, 2]) Seq([2, 1, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 5, 2]); Seq([2, 5, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 1, 2]) Seq([2, 1, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 5, 2]); Seq([2, 5, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 1, 2]) Seq([2, 1, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 5, 2]); Seq([2, 5, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 1, 2]) Seq([2, 1, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 5, 2]); Seq([2, 5, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 1, 2]) Seq([2, 1, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 5, 2]); Seq([2, 5, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 1, 2]) Seq([2, 1, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 5, 2]); Seq([2, 5, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 1, 2]) Seq([2, 1, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 5, 2]); Seq([2, 5, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 1, 2]) Seq([2, 1, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 5, 2]); Seq([2, 5, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 1, 2]) Seq([2, 1, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 5, 2]); Seq([2, 5, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 1, 2]) Seq([2, 1, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 5, 2]); Seq([2, 5, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 1, 2]) Seq([2, 1, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 5, 2]); Seq([2, 5, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 1, 2]) Seq([2, 1, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 5, 2]); Seq([2, 5, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 1, 2]) Seq([2, 1, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 5, 2]); Seq([2, 5, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 1, 2]) Seq([2, 1, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 5, 2]); Seq([2, 5, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 1, 2]) Seq([2, 1, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 5, 2]); Seq([2, 5, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 1, 2]) Seq([2, 1, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 5, 2]); Seq([2, 5, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 1, 2]) Seq([2, 1, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 5, 2]); Seq([2, 5, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 1, 2]) Seq([2, 1, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 5, 2]); Seq([2, 5, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 1, 2]) Seq([2, 1, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 5, 2])]\n    web_seq = [Seq([6, 7, 6]); Seq([6, 7, 6]); Seq([6, 7, 6]); Seq([6, 7, 6]); Seq([6, 7, 6]); Seq([6, 7, 6]); Seq([6, 7, 6]); Seq([6, 7, 6]); Seq([6, 7, 6]); Seq([6, 7, 6]); Seq([6, 7, 6]); Seq([6, 7, 6]); Seq([6, 7, 6]); Seq([6, 7, 6]); Seq([6, 7, 6]); Seq([6, 7, 6]); Seq([6, 7, 6]); Seq([6, 7, 6]); Seq([6, 7, 6]); Seq([6, 7, 6]); Seq([6, 7, 6]);;]\n    web_dp = [Seq([9, 3, 3, 9]); Seq([9, 3, 3, 9]); Seq([9, 3, 3, 9]); Seq([9, 3, 3, 9]); Seq([9, 3, 3, 9]); Seq([9, 3, 3, 9]); Seq([9, 3, 3, 9]); Seq([9, 3, 3, 9]); Seq([9, 3, 3, 9]); Seq([9, 3, 3, 9]); Seq([9, 3, 3, 9]); Seq([9, 3, 3, 9]); Seq([9, 3, 3, 9]); Seq([9, 3, 3, 9]); Seq([9, 3, 3, 9]); Seq([9, 3, 3, 9]); Seq([9, 3, 3, 9]); Seq([9, 3, 3, 9]); Seq([9, 3, 3, 9]); Seq([9, 3, 3, 9]); Seq([9, 3, 3, 9]);;]\n\n    numadIn_bld = NuMad(n_web,n_stack,n_segments,span,airfoil,te_type,twist_d,chord,xoffset,aerocenter,stack_mat_types,stack_layers,segments,DPtypes,skin_seq,web_seq,web_dp)\nend\nfor icol = 1:length(numadIn_bld.stack_layers[1,:])\n    numadIn_bld.stack_layers[:,icol] .*= LinRange(stack_layers_scale[1],stack_layers_scale[2],length(numadIn_bld.chord))\nend\nnumadIn_bld.chord .*= LinRange(chord_scale[1],chord_scale[2],length(numadIn_bld.chord))\n\nfor (i,airfoil) in enumerate(numadIn_bld.airfoil)\n    numadIn_bld.airfoil[i] = \"$path/airfoils/$airfoil\"\nend\n\nif !isnothing(NuMad_mat_xlscsv_file_bld)\n    plyprops_bld = OWENS.readNuMadMaterialsCSV(NuMad_mat_xlscsv_file_bld)\nelse\n    names = [\"CLA_5500\", \"CBX_2400\", \"ETLX_2400\", \"Airex_C70_55\", \"EBX_2400_x10\", \"ETLX_2400_x10\", \"Airex_C70_55_x10\", \"CFP-baseline\"]\n    plies = [Composites.Material{Float64}(9.824e10, 5.102e9, 4.274e9, 0.3, 1540.0, 8.75634139e8, 5.92949102e8, 1.0e8, 1.0e8, 1.0e8, 0.00066), Composites.Material{Float64}(1.4931e10, 1.4931e10, 2.389e10, 0.3, 1530.0, 4.55053962e8, 4.55053962e8, 1.0e8, 1.0e8, 1.0e8, 0.0008100000000000001), Composites.Material{Float64}(2.0333e10, 9.305e9, 4.756e9, 0.3, 1900.0, 5.30896289e8, 5.30896289e8, 1.0e8, 1.0e8, 1.0e8, 0.00066), Composites.Material{Float64}(4.5e7, 4.5e7, 2.2e7, 0.2, 59.0, 1.0e8, 1.0e8, 1.0e8, 1.0e8, 1.0e8, 0.001), Composites.Material{Float64}(9.824e11, 5.102e10, 4.274e10, 0.3, 15300.0, 4.55053962e9, 4.55053962e9, 1.0e8, 1.0e8, 1.0e8, 7.000000000000001e-5), Composites.Material{Float64}(1.4931e11, 1.4931e11, 2.389e11, 0.3, 19000.0, 5.30896289e9, 5.30896289e9, 1.0e8, 1.0e8, 1.0e8, 8.0e-5), Composites.Material{Float64}(2.03335e11, 9.3051e10, 4.756e10, 0.2, 590.0, 1.0e8, 1.0e8, 1.0e8, 1.0e8, 1.0e8, 7.000000000000001e-5), Composites.Material{Float64}(1.576e11, 9.1e9, 3.3e9, 0.263, 1600.0, 2.236e9, 1.528e9, 1.0e8, 1.0e8, 1.0e8, 0.00066)]\n    plyprops_bld = OWENS.plyproperties(names,plies)\nend\n\nbld1start = Int(mymesh.structuralNodeNumbers[1,1]) #Get blade spanwise position\nbld1end = Int(mymesh.structuralNodeNumbers[1,end])\nspanpos = [0.0;cumsum(sqrt.(diff(mymesh.x[bld1start:bld1end]).^2 .+ diff(mymesh.z[bld1start:bld1end]).^2))]\n\nif length(thickness_scale)==2\n    yscale = collect(LinRange(thickness_scale[1],thickness_scale[2],length(numadIn_bld.span)))\nelseif length(thickness_scale)==length(numadIn_bld.span)\n    yscale = thickness_scale\nend\n\nbld_precompoutput,bld_precompinput,lam_U_bld,lam_L_bld,lam_W_bld = OWENS.getOWENSPreCompOutput(numadIn_bld;yscale,plyprops = plyprops_bld)\nsectionPropsArray_bld = OWENS.getSectPropsFromOWENSPreComp(spanpos,numadIn_bld,bld_precompoutput;precompinputs=bld_precompinput)\nstiff_bld, mass_bld = OWENS.getSectPropsFromOWENSPreComp(spanpos,numadIn_bld,bld_precompoutput;GX=true)\n\nnothing","category":"page"},{"location":"examples/C_customizablePreprocessing/","page":"Customizable Preprocessing","title":"Customizable Preprocessing","text":"Similarly for the struts, we do what was done for the blades","category":"page"},{"location":"examples/C_customizablePreprocessing/","page":"Customizable Preprocessing","title":"Customizable Preprocessing","text":"numadIn_strut = Array{OWENS.NuMad, 1}(undef, Nstrutperbld)\nstrut_precompoutput = Array{Array{OWENS.OWENSPreComp.Output, 1},1}(undef, Nstrutperbld)\nstrut_precompinput = Array{Array{OWENS.OWENSPreComp.Input, 1},1}(undef, Nstrutperbld)\nplyprops_strut = Array{OWENS.plyproperties, 1}(undef, Nstrutperbld)\nlam_U_strut = Array{Array{OWENS.Composites.Laminate, 2}}(undef, Nstrutperbld)\nlam_L_strut = Array{Array{OWENS.Composites.Laminate, 2}}(undef, Nstrutperbld)\nlam_W_strut = Array{Array{OWENS.Composites.Laminate, 2}}(undef, Nstrutperbld)\nsectionPropsArray_strut = Array{Array{OWENSFEA.SectionPropsArray, 1}}(undef, Nstrutperbld)\nstiff_strut = Array{Array{Array{Float64,2}, 1},1}(undef, Nstrutperbld)\nmass_strut = Array{Array{Array{Float64,2}, 1},1}(undef, Nstrutperbld)\nfor istrut = 1:Nstrutperbld\n    if !isnothing(NuMad_geom_xlscsv_file_strut)\n        if typeof(NuMad_geom_xlscsv_file_strut)==String\n            numadIn_strut[istrut] = OWENS.readNuMadGeomCSV(NuMad_geom_xlscsv_file_strut)\n        elseif typeof(NuMad_geom_xlscsv_file_strut) == OrderedCollections.OrderedDict{Symbol, Any}\n            if length(NuMad_geom_xlscsv_file_strut[:components][:struts])==1\n                numadIn_strut[istrut] = OWENS.readNuMadGeomCSV(NuMad_geom_xlscsv_file_strut;section=:struts,subsection=1)\n            else\n                numadIn_strut[istrut] = OWENS.readNuMadGeomCSV(NuMad_geom_xlscsv_file_strut;section=:struts,subsection=istrut)\n            end\n        else\n            numadIn_strut[istrut] = OWENS.readNuMadGeomCSV(NuMad_geom_xlscsv_file_strut[istrut])\n        end\n    else\n        n_web = 1\n        n_stack = 7\n        n_segments = 12\n        span = [0.0, 6.607, 13.215, 19.822, 26.43, 33.037, 39.645, 46.252, 52.859, 59.467, 66.074, 72.682, 79.289, 85.896, 92.504, 99.111, 105.719, 112.326, 118.934, 125.541, 132.148]\n        airfoil = [\"circular\", \"NACA_0021\", \"NACA_0021\", \"NACA_0021\", \"NACA_0021\", \"NACA_0021\", \"NACA_0021\", \"NACA_0021\", \"NACA_0021\", \"NACA_0021\", \"NACA_0021\", \"NACA_0021\", \"NACA_0021\", \"NACA_0021\", \"NACA_0021\", \"NACA_0021\", \"NACA_0021\", \"NACA_0021\", \"NACA_0021\", \"NACA_0021\", \"NACA_0021\"]\n        te_type = [\"round\", \"sharp\", \"sharp\", \"sharp\", \"sharp\", \"sharp\", \"sharp\", \"sharp\", \"sharp\", \"sharp\", \"sharp\", \"sharp\", \"sharp\", \"sharp\", \"sharp\", \"sharp\", \"sharp\", \"sharp\", \"sharp\", \"sharp\", \"sharp\"]\n        twist_d = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n        chord = [10.0, 10.0, 9.0, 8.0, 8.0, 7.0, 7.0, 6.0, 6.0, 6.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0]\n        xoffset = [0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3]\n        aerocenter = [0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2]\n        stack_mat_types = [8, 2, 4, 8, 8, 8, 4]\n        if isnothing(stack_layers_strut)\n            stack_layers = [30.0 2.0 15.0 25.0 25.0 2.0 13.0; 15.0 2.0 10.0 13.0 11.0 2.0 11.0; 10.0 1.0 8.0 10.0 10.0 2.0 10.0; 8.0 1.0 6.0 9.0 10.0 1.0 9.0; 7.0 1.0 5.0 8.0 9.0 1.0 7.0; 6.0 1.0 4.0 8.0 9.0 1.0 6.0; 6.0 1.0 4.0 8.0 8.0 1.0 5.0; 6.0 1.0 4.0 7.0 7.0 1.0 5.0; 7.0 1.0 3.0 6.0 6.0 1.0 5.0; 8.0 1.0 3.0 6.0 6.0 1.0 5.0; 8.0 1.0 3.0 6.0 6.0 1.0 5.0; 7.0 1.0 3.0 6.0 6.0 1.0 5.0; 7.0 1.0 3.0 6.0 6.0 2.0 5.0; 7.0 1.0 3.0 6.0 6.0 2.0 5.0; 7.0 1.0 3.0 7.0 8.0 3.0 5.0; 7.0 2.0 3.0 9.0 12.0 3.0 6.0; 10.0 3.0 4.0 11.0 15.0 3.0 6.0; 12.0 3.0 4.0 13.0 15.0 3.0 6.0; 12.0 3.0 4.0 15.0 15.0 3.0 6.0; 12.0 3.0 4.0 15.0 15.0 3.0 6.0; 10.0 1.0 4.0 10.0 12.0 1.0 5.0]\n        else\n            stack_layers = stack_layers_strut\n        end\n        segments = [-1.0 -0.95 -0.5 -0.3 -0.1 -0.095 0.0 0.095 0.1 0.3 0.5 0.95 1.0; -1.0 -0.95 -0.5 -0.3 -0.1 -0.095 0.0 0.095 0.1 0.3 0.5 0.95 1.0; -1.0 -0.95 -0.5 -0.3 -0.1 -0.095 0.0 0.095 0.1 0.3 0.5 0.95 1.0; -1.0 -0.95 -0.5 -0.3 -0.1 -0.095 0.0 0.095 0.1 0.3 0.5 0.95 1.0; -1.0 -0.95 -0.5 -0.3 -0.1 -0.095 0.0 0.095 0.1 0.3 0.5 0.95 1.0; -1.0 -0.95 -0.5 -0.3 -0.1 -0.095 0.0 0.095 0.1 0.3 0.5 0.95 1.0; -1.0 -0.95 -0.5 -0.3 -0.1 -0.095 0.0 0.095 0.1 0.3 0.5 0.95 1.0; -1.0 -0.95 -0.5 -0.3 -0.1 -0.095 0.0 0.095 0.1 0.3 0.5 0.95 1.0; -1.0 -0.95 -0.5 -0.3 -0.1 -0.095 0.0 0.095 0.1 0.3 0.5 0.95 1.0; -1.0 -0.95 -0.5 -0.3 -0.1 -0.095 0.0 0.095 0.1 0.3 0.5 0.95 1.0; -1.0 -0.95 -0.5 -0.3 -0.1 -0.095 0.0 0.095 0.1 0.3 0.5 0.95 1.0; -1.0 -0.95 -0.5 -0.3 -0.1 -0.095 0.0 0.095 0.1 0.3 0.5 0.95 1.0; -1.0 -0.95 -0.5 -0.3 -0.1 -0.095 0.0 0.095 0.1 0.3 0.5 0.95 1.0; -1.0 -0.95 -0.5 -0.3 -0.1 -0.095 0.0 0.095 0.1 0.3 0.5 0.95 1.0; -1.0 -0.95 -0.5 -0.3 -0.1 -0.095 0.0 0.095 0.1 0.3 0.5 0.95 1.0; -1.0 -0.95 -0.5 -0.3 -0.1 -0.095 0.0 0.095 0.1 0.3 0.5 0.95 1.0; -1.0 -0.95 -0.5 -0.3 -0.1 -0.095 0.0 0.095 0.1 0.3 0.5 0.95 1.0; -1.0 -0.95 -0.5 -0.3 -0.1 -0.095 0.0 0.095 0.1 0.3 0.5 0.95 1.0; -1.0 -0.95 -0.5 -0.3 -0.1 -0.095 0.0 0.095 0.1 0.3 0.5 0.95 1.0; -1.0 -0.95 -0.5 -0.3 -0.1 -0.095 0.0 0.095 0.1 0.3 0.5 0.95 1.0; -1.0 -0.95 -0.5 -0.3 -0.1 -0.095 0.0 0.095 0.1 0.3 0.5 0.95 1.0]\n        DPtypes = [\"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\"; \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\"; \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\"; \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\"; \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\"; \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\"; \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\"; \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\"; \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\"; \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\"; \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\"; \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\"; \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\"; \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\"; \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\"; \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\"; \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\"; \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\"; \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\"; \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\"; \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\"]\n        skin_seq = [Seq([2, 5, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 1, 2]) Seq([2, 1, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 5, 2]); Seq([2, 5, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 1, 2]) Seq([2, 1, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 5, 2]); Seq([2, 5, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 1, 2]) Seq([2, 1, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 5, 2]); Seq([2, 5, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 1, 2]) Seq([2, 1, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 5, 2]); Seq([2, 5, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 1, 2]) Seq([2, 1, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 5, 2]); Seq([2, 5, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 1, 2]) Seq([2, 1, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 5, 2]); Seq([2, 5, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 1, 2]) Seq([2, 1, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 5, 2]); Seq([2, 5, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 1, 2]) Seq([2, 1, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 5, 2]); Seq([2, 5, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 1, 2]) Seq([2, 1, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 5, 2]); Seq([2, 5, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 1, 2]) Seq([2, 1, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 5, 2]); Seq([2, 5, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 1, 2]) Seq([2, 1, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 5, 2]); Seq([2, 5, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 1, 2]) Seq([2, 1, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 5, 2]); Seq([2, 5, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 1, 2]) Seq([2, 1, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 5, 2]); Seq([2, 5, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 1, 2]) Seq([2, 1, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 5, 2]); Seq([2, 5, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 1, 2]) Seq([2, 1, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 5, 2]); Seq([2, 5, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 1, 2]) Seq([2, 1, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 5, 2]); Seq([2, 5, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 1, 2]) Seq([2, 1, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 5, 2]); Seq([2, 5, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 1, 2]) Seq([2, 1, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 5, 2]); Seq([2, 5, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 1, 2]) Seq([2, 1, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 5, 2]); Seq([2, 5, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 1, 2]) Seq([2, 1, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 5, 2]); Seq([2, 5, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 1, 2]) Seq([2, 1, 2]) Seq([2, 3, 2]) Seq([2, 4, 2]) Seq([2, 4, 2]) Seq([2, 3, 2]) Seq([2, 5, 2])]\n        web_seq = [Seq([6, 7, 6]); Seq([6, 7, 6]); Seq([6, 7, 6]); Seq([6, 7, 6]); Seq([6, 7, 6]); Seq([6, 7, 6]); Seq([6, 7, 6]); Seq([6, 7, 6]); Seq([6, 7, 6]); Seq([6, 7, 6]); Seq([6, 7, 6]); Seq([6, 7, 6]); Seq([6, 7, 6]); Seq([6, 7, 6]); Seq([6, 7, 6]); Seq([6, 7, 6]); Seq([6, 7, 6]); Seq([6, 7, 6]); Seq([6, 7, 6]); Seq([6, 7, 6]); Seq([6, 7, 6]);;]\n        web_dp = [Seq([9, 3, 3, 9]); Seq([9, 3, 3, 9]); Seq([9, 3, 3, 9]); Seq([9, 3, 3, 9]); Seq([9, 3, 3, 9]); Seq([9, 3, 3, 9]); Seq([9, 3, 3, 9]); Seq([9, 3, 3, 9]); Seq([9, 3, 3, 9]); Seq([9, 3, 3, 9]); Seq([9, 3, 3, 9]); Seq([9, 3, 3, 9]); Seq([9, 3, 3, 9]); Seq([9, 3, 3, 9]); Seq([9, 3, 3, 9]); Seq([9, 3, 3, 9]); Seq([9, 3, 3, 9]); Seq([9, 3, 3, 9]); Seq([9, 3, 3, 9]); Seq([9, 3, 3, 9]); Seq([9, 3, 3, 9]);;]\n\n        numadIn_strut[istrut] = NuMad(n_web,n_stack,n_segments,span,airfoil,te_type,twist_d,chord,xoffset,aerocenter,stack_mat_types,stack_layers,segments,DPtypes,skin_seq,web_seq,web_dp)\n    end\n    for icol = 1:length(numadIn_strut[istrut].stack_layers[1,:])\n        numadIn_strut[istrut].stack_layers[:,icol] .*= LinRange(stack_layers_scale[1],stack_layers_scale[2],length(numadIn_strut[istrut].chord))\n    end\n    #### numadIn_strut[istrut].chord .*= LinRange(chord_scale[1],chord_scale[2],length(numadIn_strut[istrut].chord))\n\n    for (i,airfoil) in enumerate(numadIn_strut[istrut].airfoil)\n        numadIn_strut[istrut].airfoil[i] = \"$path/airfoils/$airfoil\"\n    end\n\n    if !isnothing(NuMad_mat_xlscsv_file_strut)\n        plyprops_strut[istrut] = OWENS.readNuMadMaterialsCSV(NuMad_mat_xlscsv_file_strut)\n    else\n        names = [\"CLA_5500\", \"CBX_2400\", \"ETLX_2400\", \"Airex_C70_55\", \"EBX_2400_x10\", \"ETLX_2400_x10\", \"Airex_C70_55_x10\", \"CFP-baseline\"]\n        plies = [Composites.Material{Float64}(9.824e10, 5.102e9, 4.274e9, 0.3, 1540.0, 8.75634139e8, 5.92949102e8, 1.0e8, 1.0e8, 1.0e8, 0.00066), Composites.Material{Float64}(1.4931e10, 1.4931e10, 2.389e10, 0.3, 1530.0, 4.55053962e8, 4.55053962e8, 1.0e8, 1.0e8, 1.0e8, 0.0008100000000000001), Composites.Material{Float64}(2.0333e10, 9.305e9, 4.756e9, 0.3, 1900.0, 5.30896289e8, 5.30896289e8, 1.0e8, 1.0e8, 1.0e8, 0.00066), Composites.Material{Float64}(4.5e7, 4.5e7, 2.2e7, 0.2, 59.0, 1.0e8, 1.0e8, 1.0e8, 1.0e8, 1.0e8, 0.001), Composites.Material{Float64}(9.824e11, 5.102e10, 4.274e10, 0.3, 15300.0, 4.55053962e9, 4.55053962e9, 1.0e8, 1.0e8, 1.0e8, 7.000000000000001e-5), Composites.Material{Float64}(1.4931e11, 1.4931e11, 2.389e11, 0.3, 19000.0, 5.30896289e9, 5.30896289e9, 1.0e8, 1.0e8, 1.0e8, 8.0e-5), Composites.Material{Float64}(2.03335e11, 9.3051e10, 4.756e10, 0.2, 590.0, 1.0e8, 1.0e8, 1.0e8, 1.0e8, 1.0e8, 7.000000000000001e-5), Composites.Material{Float64}(1.576e11, 9.1e9, 3.3e9, 0.263, 1600.0, 2.236e9, 1.528e9, 1.0e8, 1.0e8, 1.0e8, 0.00066)]\n        plyprops_strut[istrut] = OWENS.plyproperties(names,plies)\n    end\n\n    #### TODO: not straight struts\n    spanpos = LinRange(0,1,nselem+1)#[0.0;cumsum(sqrt.(diff(mymesh.x[strut1start:strut1end]).^2 .+ diff(mymesh.z[strut1start:strut1end]).^2))]\n\n    if length(thickness_scale)==2\n        yscale = collect(LinRange(thickness_scale[1],thickness_scale[2],length(numadIn_strut[istrut].span)))\n    elseif length(thickness_scale)==length(numadIn_strut[istrut].span)\n        yscale = thickness_scale\n    end\n\n    strut_precompoutput[istrut],strut_precompinput[istrut],lam_U_strut[istrut],lam_L_strut[istrut],lam_W_strut[istrut] = OWENS.getOWENSPreCompOutput(numadIn_strut[istrut];yscale,plyprops = plyprops_strut[istrut])\n    sectionPropsArray_strut[istrut] = OWENS.getSectPropsFromOWENSPreComp(spanpos,numadIn_strut[istrut],strut_precompoutput[istrut];precompinputs=strut_precompinput[istrut])\n    stiff_strut[istrut], mass_strut[istrut] = OWENS.getSectPropsFromOWENSPreComp(spanpos,numadIn_strut[istrut],strut_precompoutput[istrut];GX=true)\nend\n\nnothing","category":"page"},{"location":"examples/C_customizablePreprocessing/","page":"Customizable Preprocessing","title":"Customizable Preprocessing","text":"Here we combine the section properties into an array matching the mesh elements","category":"page"},{"location":"examples/C_customizablePreprocessing/","page":"Customizable Preprocessing","title":"Customizable Preprocessing","text":"bldssecprops = collect(Iterators.flatten(fill(sectionPropsArray_bld, Nbld)))\n#### strutssecprops = collect(Iterators.flatten(fill(sectionPropsArray_strut, Nstrutperbld*Nbld)))\n\nif meshtype == \"ARCUS\"\n    sectionPropsArray = [sectionPropsArray_twr; bldssecprops]#; strutssecprops]#;sectionPropsArray_str;sectionPropsArray_str;sectionPropsArray_str;sectionPropsArray_str]\n\n    stiff_blds = collect(Iterators.flatten(fill(stiff_bld, Nbld)))\n    stiff_array = [stiff_twr; stiff_blds]#; stiff_struts]\n\n    mass_blds = collect(Iterators.flatten(fill(mass_bld, Nbld)))\n    mass_array = [mass_twr; mass_blds]#; mass_struts]\n\n    for icable = 1:Nbld\n        sectionPropsArray = [sectionPropsArray; sectionPropsArray_strut[1]]\n        stiff_array = [stiff_array;stiff_strut[1]]\n        mass_array = [mass_array;mass_strut[1]]\n    end\nelse\n    sectionPropsArray = [sectionPropsArray_twr; bldssecprops]#; strutssecprops]#;sectionPropsArray_str;sectionPropsArray_str;sectionPropsArray_str;sectionPropsArray_str]\n\n    stiff_blds = collect(Iterators.flatten(fill(stiff_bld, Nbld)))\n    stiff_array = [stiff_twr; stiff_blds]#; stiff_struts]\n\n    mass_blds = collect(Iterators.flatten(fill(mass_bld, Nbld)))\n    mass_array = [mass_twr; mass_blds]#; mass_struts]\n\n    for istrut = 1:Nstrutperbld\n        for ibld = 1:Nbld\n            global sectionPropsArray = [sectionPropsArray; sectionPropsArray_strut[istrut]]\n            global stiff_array = [stiff_array;stiff_strut[istrut]]\n            global mass_array = [mass_array;mass_strut[istrut]]\n        end\n    end\nend\nrotationalEffects = ones(mymesh.numEl) #TODO: non rotating tower, or rotating blades\n\nif length(sectionPropsArray)<mymesh.numEl\n    @warn \"There are more mesh elements than sectional properties, applying the last strut's sectional properties to the remaining\"\n    n_diff = mymesh.numEl - length(sectionPropsArray)\n    sectionPropsArray = [sectionPropsArray; fill(sectionPropsArray_strut[end][2],n_diff)]\n    stiff_array = [stiff_array;fill(stiff_strut[end][2],n_diff)]\n    mass_array = [mass_array;fill(mass_strut[end][2],n_diff)]\nend\n\n#### store data in element object\nmyel = OWENSFEA.El(sectionPropsArray,myort.Length,myort.Psi_d,myort.Theta_d,myort.Twist_d,rotationalEffects)\nsystem, assembly, sections = OWENS.owens_to_gx(mymesh,myort,myjoint,sectionPropsArray,stiff_array,mass_array)\n\nnothing","category":"page"},{"location":"examples/C_customizablePreprocessing/","page":"Customizable Preprocessing","title":"Customizable Preprocessing","text":"Set up the OWENSAero aerodynamics if used","category":"page"},{"location":"examples/C_customizablePreprocessing/","page":"Customizable Preprocessing","title":"Customizable Preprocessing","text":"if !AD15On\n    #########################################\n    ### Set up aero forces\n    #########################################\n    #### translate from blade span to blade height between the numad definition and the vertical slice positions\n    #### First get the angles from the overall geometry npoints and go to the numad npoints\n    delta_xs = shapeX[2:end] - shapeX[1:end-1]\n    delta_zs = shapeZ[2:end] - shapeZ[1:end-1]\n    delta3D = atan.(delta_xs./delta_zs)\n    delta3D_spl = safeakima(shapeZ[1:end-1]./maximum(shapeZ[1:end-1]), delta3D,LinRange(0,1,length(numadIn_bld.span)-1))\n    #### now convert the numad span to a height\n    bld_height_numad = cumsum(diff(numadIn_bld.span).*(1.0.-abs.(sin.(delta3D_spl))))\n    bld_height_numad_unit = bld_height_numad./maximum(bld_height_numad)\n    #### now we can use it to access the numad data\n    chord = safeakima(bld_height_numad_unit, numadIn_bld.chord,LinRange(bld_height_numad_unit[1],1,Nslices))\n    airfoils = fill(\"nothing\",Nslices)\n\n    twist = safeakima(bld_height_numad_unit, numadIn_bld.twist_d.*pi/180,LinRange(bld_height_numad_unit[1],1,Nslices))\n\n    #### Discretely assign the airfoils\n    for (iheight_numad,height_numad) in enumerate(bld_height_numad_unit)\n        for (iheight,height_slices) in enumerate(collect(LinRange(0,1,Nslices)))\n            if airfoils[iheight]==\"nothing\" && height_slices<=height_numad\n                airfoils[iheight] = \"$(numadIn_bld.airfoil[iheight_numad]).dat\"\n            end\n        end\n    end\n\n    OWENSAero.setupTurb(shapeX,shapeZ,B,chord,tsr,Vinf;AeroModel,DynamicStallModel,\n    afname = airfoils,\n    bld_y = shapeY,\n    rho,\n    twist, #TODO: verify twist is in same direction\n    mu,\n    eta,\n    ifw, #TODO: propogate WindType\n    turbsim_filename = windINPfilename,\n    ifw_libfile,\n    tau = [1e-5,1e-5],\n    Aero_AddedMass_Active,\n    Aero_RotAccel_Active,\n    Aero_Buoyancy_Active,\n    ntheta,\n    Nslices,\n    RPI)\n\n    aeroForcesACDMS(t,azi) = OWENS.mapACDMS(t,azi,mymesh,myel,OWENSAero.AdvanceTurbineInterpolate;alwaysrecalc=true)\n    deformAeroACDMS = OWENSAero.deformTurb\nend\nnothing","category":"page"},{"location":"examples/C_customizablePreprocessing/","page":"Customizable Preprocessing","title":"Customizable Preprocessing","text":"Set up AeroDyn if used Here we create AeroDyn the files, first by specifying the names, then by creating the files, TODO: hook up the direct sectionPropsArray_str Then by initializing AeroDyn and grabbing the backend functionality with a function handle","category":"page"},{"location":"examples/C_customizablePreprocessing/","page":"Customizable Preprocessing","title":"Customizable Preprocessing","text":"if AD15On\n    ad_input_file = \"$path/ADInputFile_SingleTurbine2.dat\"\n    ifw_input_file = \"$path/IW2.dat\"\n    OLAF_filename = \"$path/OLAF2.dat\"\n\n    NumADBldNds = NumADStrutNds = 10\n\n    bldchord_spl = OWENS.safeakima(numadIn_bld.span./maximum(numadIn_bld.span), numadIn_bld.chord,LinRange(0,1,NumADBldNds))\n\n    #### Discretely assign the blade airfoils based on the next closest neighbor\n    bld_airfoil_filenames = fill(\"nothing\",NumADBldNds) #TODO: cable drag?\n    for (ispan_numad,span_numad) in enumerate(numadIn_bld.span./maximum(numadIn_bld.span))\n        for (ispan,span_slices) in enumerate(collect(LinRange(0,1,NumADBldNds)))\n            if bld_airfoil_filenames[ispan]==\"nothing\" && span_slices<=span_numad\n                bld_airfoil_filenames[ispan] = \"$(numadIn_bld.airfoil[ispan_numad]).dat\"\n            end\n        end\n    end\n\n    if meshtype == \"ARCUS\"\n        blade_filenames = [\"$path/blade$i.dat\" for i=1:Nbld]\n        blade_chords = [bldchord_spl for i=1:Nbld]\n        blade_Nnodes = [NumADBldNds for i=1:Nbld]\n        airfoil_filenames = [bld_airfoil_filenames for i=1:Nbld]\n\n    else\n        blade_filenames = [\"$path/blade$i.dat\" for i=1:Nbld]\n        blade_chords = [bldchord_spl for i=1:Nbld]\n        blade_Nnodes = [NumADBldNds for i=1:Nbld]\n        airfoil_filenames = collect(Iterators.flatten([bld_airfoil_filenames for i=1:Nbld]))\n\n        for istrut = 1:Nstrutperbld\n            strutchord_spl = OWENS.safeakima(numadIn_strut[istrut].span./maximum(numadIn_strut[istrut].span), numadIn_strut[istrut].chord,LinRange(0,1,NumADStrutNds))\n            for ibld = 1:Nbld\n                global blade_filenames = [blade_filenames;\"$path/strut$(istrut)_bld$ibld.dat\"]\n                global blade_chords = [blade_chords;[strutchord_spl]]\n                global blade_Nnodes = [blade_Nnodes;NumADStrutNds]\n\n                #### Discretely assign the strut airfoils based on the next closest neighbor\n                strut_airfoil_filenames = fill(\"nothing\",NumADStrutNds)\n                for (ispan_numad,span_numad) in enumerate(numadIn_strut[istrut].span./maximum(numadIn_strut[istrut].span))\n                    for (ispan,span_slices) in enumerate(collect(LinRange(0,1,NumADBldNds)))\n                        if strut_airfoil_filenames[ispan]==\"nothing\" && span_slices<=span_numad\n                            strut_airfoil_filenames[ispan] = \"$(numadIn_strut[istrut].airfoil[ispan_numad]).dat\"\n                        end\n                    end\n                end\n\n                global airfoil_filenames = [airfoil_filenames; strut_airfoil_filenames]\n\n            end\n        end\n    end\n\n    OWENSOpenFASTWrappers.writeADinputFile(ad_input_file,blade_filenames,airfoil_filenames,OLAF_filename;rho)\n\n    NumADBody = length(AD15bldNdIdxRng[:,1])\n    bld_len = zeros(NumADBody)\n    #### bladefileissaved = false\n    for (iADBody,filename) in enumerate(blade_filenames)\n        strt_idx = AD15bldNdIdxRng[iADBody,1]\n        end_idx = AD15bldNdIdxRng[iADBody,2]\n        if end_idx<strt_idx\n            tmp_end = end_idx\n            end_idx = strt_idx\n            strt_idx = tmp_end\n        end\n\n        #### Get the blade length\n        x1 = mymesh.x[strt_idx]\n        x2 = mymesh.x[end_idx]\n        y1 = mymesh.y[strt_idx]\n        y2 = mymesh.y[end_idx]\n        z1 = mymesh.z[strt_idx]\n        z2 = mymesh.z[end_idx]\n        bld_len[iADBody] = sqrt((x2-x1)^2+(y2-y1)^2+(z2-z1)^2)\n\n        #### Get the blade shape\n        ADshapeZ = collect(LinRange(0,H,NumADBldNds))\n        xmesh = mymesh.x[strt_idx:end_idx]\n        ymesh = mymesh.y[strt_idx:end_idx]\n        ADshapeX = sqrt.(xmesh.^2 .+ ymesh.^2)\n        ADshapeX .-= ADshapeX[1] #get it starting at zero #TODO: make robust for blades that don't start at 0\n        ADshapeXspl = OWENS.safeakima(LinRange(0,H,length(ADshapeX)),ADshapeX,ADshapeZ)\n\n        if iADBody<=Nbld #&& !bladefileissaved#Note that the blades can be curved and are assumed to be oriented vertically\n            ####  bladefileissaved = true\n            BlSpn0=ADshapeZ\n            BlCrvAC0=ADshapeXspl\n\n            bladeangle = (iADBody-1)*2.0*pi/Nbld + angularOffset #TODO: pitch offset and twist offset that isn't from the helical\n\n            BlSpn = ADshapeZ\n            blade_twist = atan.(xmesh,ymesh).-bladeangle\n\n            #### TODO: reevalueate these equations and make sure they are robust against varying designs\n            BlCrvACinput = -ymesh.*sin(bladeangle).+xmesh.*cos(bladeangle)\n            BlCrvACinput = BlCrvACinput .- BlCrvACinput[1]\n            BlSwpAC = -OWENS.safeakima(LinRange(0,H,length(BlCrvACinput)),BlCrvACinput,ADshapeZ)\n\n            BlSwpACinput = xmesh.*sin(bladeangle).+ymesh.*cos(bladeangle)\n            BlSwpACinput = BlSwpACinput .- BlSwpACinput[1]\n            BlCrvAC = OWENS.safeakima(LinRange(0,H,length(BlSwpACinput)),BlSwpACinput,ADshapeZ)\n\n            BlCrvAng = zeros(blade_Nnodes[iADBody])\n\n            BlTwistinput =(blade_twist.-blade_twist[1])*180/pi\n            BlTwist = OWENS.safeakima(LinRange(0,H,length(BlTwistinput)),BlTwistinput,ADshapeZ)\n\n            BlChord=blade_chords[iADBody]\n\n            BlAFID=collect((iADBody-1)*NumADBldNds+1:iADBody*NumADBldNds)\n\n        elseif iADBody>Nbld # while the arms/struts are assumed to be straight and are oriented by the mesh angle\n            BlSpn=collect(LinRange(0,bld_len[iADBody],blade_Nnodes[iADBody]))\n            BlCrvAC=zeros(blade_Nnodes[iADBody])\n            BlSwpAC=zeros(blade_Nnodes[iADBody])\n            BlCrvAng=zeros(blade_Nnodes[iADBody])\n            BlTwist=zeros(blade_Nnodes[iADBody])\n            BlChord=blade_chords[iADBody]\n            BlAFID=collect((iADBody-1)*NumADStrutNds+1:iADBody*NumADStrutNds)\n        end\n        OWENSOpenFASTWrappers.writeADbladeFile(filename;NumBlNds=blade_Nnodes[iADBody],BlSpn,BlCrvAC,BlSwpAC,BlCrvAng,BlTwist,BlChord,BlAFID)\n    end\n\n    OWENSOpenFASTWrappers.writeOLAFfile(OLAF_filename;nNWPanel=200,nFWPanels=10)\n\n    OWENSOpenFASTWrappers.writeIWfile(Vinf,ifw_input_file;windINPfilename)\n\n    OWENSOpenFASTWrappers.setupTurb(adi_lib,ad_input_file,ifw_input_file,adi_rootname,[shapeX],[shapeZ],[B],[Htwr_base],[mymesh],[myort],[AD15bldNdIdxRng],[AD15bldElIdxRng];\n            rho     = rho,\n            adi_dt  = delta_t,\n            adi_tmax= numTS*delta_t,\n            omega   = [omega],\n            adi_wrOuts = 1,     # write output file [0 none, 1 txt, 2 binary, 3 both]\n            adi_DT_Outs = delta_t,   # output frequency\n            numTurbines = 1,\n            refPos=[[0,0,0]],\n            hubPos=[[0,0,0.0]],\n            hubAngle=[[0,0,0]],\n            nacPos=[[0,0,0]],\n            adi_nstrut=[Nstrutperbld],\n            adi_debug=0,\n            isHAWT = false     # true for HAWT, false for crossflow or VAWT\n            )\n\n    aeroForcesAD(t,azi) = OWENS.mapAD15(t,azi,[mymesh],OWENSOpenFASTWrappers.advanceAD15;alwaysrecalc=true,verbosity=1)\n    deformAeroAD=OWENSOpenFASTWrappers.deformAD15\nend\n\nnothing","category":"page"},{"location":"examples/C_customizablePreprocessing/","page":"Customizable Preprocessing","title":"Customizable Preprocessing","text":"Calculate mass breakout of each material","category":"page"},{"location":"examples/C_customizablePreprocessing/","page":"Customizable Preprocessing","title":"Customizable Preprocessing","text":"mass_breakout_bld = OWENS.get_material_mass(plyprops_bld,numadIn_bld)\nmass_breakout_blds = mass_breakout_bld.*length(mymesh.structuralNodeNumbers[:,1])\nmass_breakout_twr = OWENS.get_material_mass(plyprops_twr,numadIn_twr;int_start=0.0,int_stop=Htwr_base)\n\n################################\n##### End setupOWENS\n################################\n\nnothing","category":"page"},{"location":"examples/C_customizablePreprocessing/","page":"Customizable Preprocessing","title":"Customizable Preprocessing","text":"Then the rest of this example is the same as example B","category":"page"},{"location":"examples/C_customizablePreprocessing/","page":"Customizable Preprocessing","title":"Customizable Preprocessing","text":"if verbosity>0\n\n    println(\"\\nBlades' Mass Breakout\")\n    for (i,name) in enumerate(plyprops_bld.names)\n        println(\"$name $(mass_breakout_blds[i]) kg, $(plyprops_bld.costs[i]) \\$/kg: \\$$(mass_breakout_blds[i]*plyprops_bld.costs[i])\")\n    end\n\n    println(\"\\nTower Mass Breakout\")\n    for (i,name) in enumerate(plyprops_twr.names)\n        println(\"$name $(mass_breakout_twr[i]) kg, $(plyprops_twr.costs[i]) \\$/kg: \\$$(mass_breakout_twr[i]*plyprops_twr.costs[i])\")\n    end\n\n    println(\"Total Material Cost Blades: \\$$(sum(mass_breakout_blds.*plyprops_bld.costs))\")\n    println(\"Total Material Cost Tower: \\$$(sum(mass_breakout_twr.*plyprops_twr.costs))\")\n    println(\"Total Material Cost: \\$$(sum(mass_breakout_blds.*plyprops_bld.costs)+ sum(mass_breakout_twr.*plyprops_twr.costs))\")\n\nend\n\npBC = [1 1 0\n1 2 0\n1 3 0\n1 4 0\n1 5 0\n1 6 0]\n\ninputs = OWENS.Inputs(;verbosity,analysisType = structuralModel,\ntocp = [0.0,100000.1],\nOmegaocp = [RPM,RPM] ./ 60,\ntocp_Vinf = [0.0,100000.1],\nVinfocp = [Vinf,Vinf],\nnumTS,\ndelta_t,\nAD15On,\naeroLoadsOn = 2)\n\nfeamodel = OWENS.FEAModel(;analysisType = structuralModel,\ndataOutputFilename = \"none\",\njoint = myjoint,\nplatformTurbineConnectionNodeNumber = 1,\npBC,\nnlOn = true,\nnumNodes = mymesh.numNodes,\nRayleighAlpha = 0.05,\nRayleighBeta = 0.05,\niterationType = \"DI\")\n\nprintln(\"Running Unsteady\")\nif AD15On\n    t, aziHist,OmegaHist,OmegaDotHist,gbHist,gbDotHist,gbDotDotHist,FReactionHist,\n    FTwrBsHist,genTorque,genPower,torqueDriveShaft,uHist,uHist_prp,epsilon_x_hist,epsilon_y_hist,\n    epsilon_z_hist,kappa_x_hist,kappa_y_hist,kappa_z_hist = OWENS.Unsteady_Land(inputs;system,assembly,\n    topModel=feamodel,topMesh=mymesh,topEl=myel,aero=aeroForcesAD,deformAero=deformAeroAD)\nelse\n    t, aziHist,OmegaHist,OmegaDotHist,gbHist,gbDotHist,gbDotDotHist,FReactionHist,\n    FTwrBsHist,genTorque,genPower,torqueDriveShaft,uHist,uHist_prp,epsilon_x_hist,epsilon_y_hist,\n    epsilon_z_hist,kappa_x_hist,kappa_y_hist,kappa_z_hist = OWENS.Unsteady_Land(inputs;system,assembly,\n    topModel=feamodel,topMesh=mymesh,topEl=myel,aero=aeroForcesACDMS,deformAero=deformAeroACDMS)\nend\n\nif AD15On #TODO: move this into the run functions\n    OWENSOpenFASTWrappers.endTurb()\nend\n\nprintln(\"Saving VTK time domain files\")\nOWENS.OWENSFEA_VTK(\"$path/vtk/SNLARCUS5MW_timedomain_TNBnltrue\",t,uHist,system,assembly,sections;scaling=1,azi=aziHist)\n\n\n##########################################\n#### Ultimate Failure #####\n##########################################\n\nmassOwens,stress_U,SF_ult_U,SF_buck_U,stress_L,SF_ult_L,SF_buck_L,stress_TU,SF_ult_TU,\nSF_buck_TU,stress_TL,SF_ult_TL,SF_buck_TL,topstrainout_blade_U,topstrainout_blade_L,\ntopstrainout_tower_U,topstrainout_tower_LtopDamage_blade_U,\ntopDamage_blade_L,topDamage_tower_U,topDamage_tower_L = OWENS.extractSF(bld_precompinput,\nbld_precompoutput,plyprops_bld,numadIn_bld,lam_U_bld,lam_L_bld,\ntwr_precompinput,twr_precompoutput,plyprops_twr,numadIn_twr,lam_U_twr,lam_L_twr,\nmymesh,myel,myort,Nbld,epsilon_x_hist,kappa_y_hist,kappa_z_hist,epsilon_z_hist,\nkappa_x_hist,epsilon_y_hist;verbosity, #Verbosity 0:no printing, 1: summary, 2: summary and spanwise worst safety factor # epsilon_x_hist_1,kappa_y_hist_1,kappa_z_hist_1,epsilon_z_hist_1,kappa_x_hist_1,epsilon_y_hist_1,\ncomposite_station_idx_U_strut = [1,6,3,2,5],\ncomposite_station_name_U_strut = [\"Leading Edge\",\"Trailing Edge\",\"Spar Cap\",\"Front Panel\",\"Rear Panel\"],\ncomposite_station_idx_L_strut = [1,6,3,2,5],\ncomposite_station_name_L_strut = [\"Leading Edge\",\"Trailing Edge\",\"Spar Cap\",\"Front Panel\",\"Rear Panel\"],\ncomposite_station_idx_U_bld = [1,6,3,2,5],\ncomposite_station_name_U_bld = [\"Leading Edge\",\"Trailing Edge\",\"Spar Cap\",\"Front Panel\",\"Rear Panel\"],\ncomposite_station_idx_L_bld = [1,6,3,2,5],\ncomposite_station_name_L_bld = [\"Leading Edge\",\"Trailing Edge\",\"Spar Cap\",\"Front Panel\",\"Rear Panel\"],\nTwr_LE_U_idx=1,Twr_LE_L_idx=1,\nAD15bldNdIdxRng,AD15bldElIdxRng,strut_precompoutput=nothing,strut_precompinput,plyprops_strut,numadIn_strut,lam_U_strut,lam_L_strut) #TODO: add in ability to have material safety factors and load safety factors\n\nnothing","category":"page"},{"location":"examples/C_customizablePreprocessing/","page":"Customizable Preprocessing","title":"Customizable Preprocessing","text":"","category":"page"},{"location":"examples/C_customizablePreprocessing/","page":"Customizable Preprocessing","title":"Customizable Preprocessing","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/referencePreComp/#OWENSPreComp","page":"OWENSPreComp","title":"OWENSPreComp","text":"","category":"section"},{"location":"reference/referencePreComp/#Types-and-functions","page":"OWENSPreComp","title":"Types and functions","text":"","category":"section"},{"location":"reference/referencePreComp/#OWENSPreComp.Input","page":"OWENSPreComp","title":"OWENSPreComp.Input","text":"Struct for holding inputs to OWENSPreComp.properties()\n\n\n\n\n\n","category":"type"},{"location":"reference/referencePreComp/#OWENSPreComp.Output","page":"OWENSPreComp","title":"OWENSPreComp.Output","text":"Struct type for holding outputs of OWENSPreComp.properties()\n\n\n\n\n\n","category":"type"},{"location":"reference/referencePreComp/#OWENSPreComp.input","page":"OWENSPreComp","title":"OWENSPreComp.input","text":"Struct for holding inputs to OWENSPreComp.properties()\n\n\n\n\n\n","category":"type"},{"location":"reference/referencePreComp/#OWENSPreComp.embed_ls-NTuple{4, Any}","page":"OWENSPreComp","title":"OWENSPreComp.embed_ls","text":"embed_ls(x, nodes_l, xnode_l, ynode_l)\n\npurpose: embed a node in the lower-surface airfoil section nodes NOTE: nodal x coordinates must be in ascending order\n\nArguments:\n\nx::Real: x-coordinate of node to be embedded in the l-surf\nnodes_l::Int: no of current nodes on the lower surface\nxnode_l::Array{<:Real,1}: x-nodes on lower surface\nynode_l::Array{<:Real,1}: y-nodes on lower surface\n\nOutputs:\n\nnodes_l: revised no of current nodes on lower surface\nxnode_l: x-nodes on lower surface\nynode_l: y-nodes on lower surface\ny: y-coordinate of node embedded in the l-surf\nnewnode : number of the embedded node\n\n\n\n\n\n","category":"method"},{"location":"reference/referencePreComp/#OWENSPreComp.embed_us-Tuple{Real, Int64, Any, Any}","page":"OWENSPreComp","title":"OWENSPreComp.embed_us","text":"embed_us(x, nodes_u, xnode_u, ynode_u)\n\npurpose: embed a node in the upper-surface airfoil section nodes NOTE: nodal x coordinates must be in ascending order\n\nArguments:\n\nx::Real: x-coordinate of node to be embedded in the u-surf\nnodes_u::Int: no of current nodes on the upper surface\nxnode_u::Array{<:Real,1}: x-nodes on upper surface\nynode_u::Array{<:Real,1}: y-nodes on upper surface\n\nOutputs:\n\nnodes_u: revised no of current nodes on upper surface\nxnode_u: x-nodes on upper surface\nynode_u: y-nodes on upper surface\ny: y-coordinate of node embedded in the u-surf\nnewnode : number of the embedded node\n\n\n\n\n\n","category":"method"},{"location":"reference/referencePreComp/#OWENSPreComp.properties-Tuple{Real, Real, Real, Real, AbstractVector{<:Real}, AbstractVector{<:Real}, AbstractVector{<:Real}, AbstractVector{<:Real}, AbstractVector{<:Real}, AbstractVector{<:Real}, AbstractVector{<:Real}, AbstractVector{<:Real}, AbstractVector{<:Real}, AbstractVector{<:Real}, AbstractVector{<:Real}, AbstractVector{<:Real}, AbstractVector{<:Real}, AbstractVector{<:Real}, AbstractVector{<:Real}, AbstractVector{<:Real}, AbstractVector{<:Real}, AbstractVector{<:Real}, AbstractVector{<:Real}, AbstractVector{<:Real}, AbstractVector{<:Real}, AbstractVector{<:Real}, AbstractVector{<:Real}, AbstractVector{<:Real}, AbstractVector{<:Real}}","page":"OWENSPreComp","title":"OWENSPreComp.properties","text":"properties(chord::Array{<:Real,1}, tw_aero_d::Array{<:Real,1},\ntw_prime_d::Array{<:Real,1}, le_loc::Real, xnode::Array{<:Real,1},\nynode::Array{<:Real,1}, e1::Array{<:Real,1}, e2::Array{<:Real,1},\ng12::Array{<:Real,1}, anu12::Array{<:Real,1}, density::Array{<:Real,1},\nxsec_nodeU::Array{<:Real,1}, n_laminaU::Array{Int64,1},\nn_pliesU::Array{Int64,1}, t_lamU::Array{<:Real,1},\ntht_lamU::Array{<:Real,1}, mat_lamU::Array{Int64,1},\nxsec_nodeL::Array{<:Real,1}, n_laminaL::Array{Int64,1},\nn_pliesL::Array{Int64,1}, t_lamL::Array{<:Real,1},\ntht_lamL::Array{<:Real,1}, mat_lamL::Array{Int64,1},\nloc_web::Array{<:Real,1}, n_laminaW::Array{Int64,1},\nn_pliesW::Array{Int64,1}, t_lamW::Array{<:Real,1},\ntht_lamW::Array{<:Real,1}, mat_lamW::Array{Int64,1})\n\nCalculates span-variant structural properties for composite blades\n\nInputs\n\nchord::Real: section chord length (m)\ntw_aero_d::Real: section twist angle (deg)\ntw_prime_d::Real: derivative of section twist angle w.r.t. span location (deg/m)\nle_loc::Real: leading edge location relative to reference axis (normalized by chord)\nxnode::Array{<:Real,1}: x airfoil coordinates starting at leading edge traversing upper surface and back around lower surface\nynode::Array{<:Real,1}: y airfoil coordinates starting at leading edge traversing upper surface and back around lower surface\ne1::Array{<:Real,1}: E1\ne2::Array{<:Real,1}: E2\ng12::Array{<:Real,1}: G12\nanu12::Array{<:Real,1}: Nu12\ndensity::Array{<:Real,1}: density\nxsec_nodeU::Array{<:Real,1}: upper surface normalized chord location of sector boundaries\nn_laminaU::Array{Int64,1}: upper surface number of lamina in each sector\nn_pliesU::Array{Int64,1}: upper surface number of plies\nt_lamU::Array{<:Real,1}: upper surface ply thickness (m) for the lamina\ntht_lamU::Array{<:Real,1}: upper surface orientation (deg) for the lamina\nmat_lamU::Array{Int64,1}: upper surface material id for the lamina\nxsec_nodeL::Array{<:Real,1}: lower surface normalized chord location of sector boundaries\nn_laminaL::Array{Int64,1}: lower surface number of lamina in each sector\nn_pliesL::Array{Int64,1}: lower surface number of plies\nt_lamL::Array{<:Real,1}: lower surface ply thickness (m) for the lamina\ntht_lamL::Array{<:Real,1}: lower surface orientation (deg) for the lamina\nmat_lamL::Array{Int64,1}: lower surface material id for the lamina\nloc_web::Array{<:Real,1}: web normalized chord location of sector boundaries\nn_laminaW::Array{Int64,1}: web number of lamina in each sector\nn_pliesW::Array{Int64,1}: web number of plies\nt_lamW::Array{<:Real,1}: web ply thickness (m) for the lamina\ntht_lamW::Array{<:Real,1}: web orientation (deg) for the lamina\nmat_lamW::Array{Int64,1}: web material id for the lamina\n\nOutputs:\n\neifbar: ei_flap, Section flap bending stiffness about the YE axis (Nm2)\neilbar: ei_lag, Section lag (edgewise) bending stiffness about the XE axis (Nm2)\ngjbar: gj, Section torsion stiffness (Nm2)\neabar: ea, Section axial stiffness (N)\neiflbar: s_fl, Coupled flap-lag stiffness with respect to the XE-YE frame (Nm2)\nsfbar: s_af, Coupled axial-flap stiffness with respect to the XE-YE frame (Nm)\nslbar: s_al, Coupled axial-lag stiffness with respect to the XE-YE frame (Nm.)\nsftbar: s_ft, Coupled flap-torsion stiffness with respect to the XE-YE frame (Nm2)\nsltbar: s_lt, Coupled lag-torsion stiffness with respect to the XE-YE frame (Nm2)\nsatbar: s_at, Coupled axial-torsion stiffness (Nm)\nz_sc: x_sc, X-coordinate of the shear-center offset with respect to the XR-YR axes (m)\ny_sc: y_sc, Chordwise offset of the section shear-center with respect to the reference frame, XR-YR (m)\nztc_ref: x_tc, X-coordinate of the tension-center offset with respect to the XR-YR axes (m)\nytc_ref: y_tc, Chordwise offset of the section tension-center with respect to the XR-YR axes (m)\nmass: mass, Section mass per unit length (Kg/m)\niflap_eta: flap_iner, Section flap inertia about the YG axis per unit length (Kg-m)\nilag_zeta: lag_iner, Section lag inertia about the XG axis per unit length (Kg-m)\ntw_iner_d: twinerd, Orientation of the section principal inertia axes with respect the blade reference plane, θ (deg)\nzcm_ref: x_cm, X-coordinate of the center-of-mass offset with respect to the XR-YR axes (m)\nycm_ref: y_cm, Chordwise offset of the section center of mass with respect to the XR-YR axes (m)\nn_af_nodes: number of airfoil nodes\nn_materials: number of materials\nn_sctU: number of sectors on upper\nn_sctL: number of sectors on lower\nnwebin: number of webs\nn_laminaTotalU: total number of lamina on upper\nn_laminaTotalL: total number of lamina on lower\nn_laminaTotalW: total number of lamina on webs\n\n\n\n\n\n","category":"method"},{"location":"reference/referencePreComp/#OWENSPreComp.properties-Union{Tuple{OWENSPreComp.Input{R}}, Tuple{R}} where R<:Real","page":"OWENSPreComp","title":"OWENSPreComp.properties","text":"properties(pc_input::Input)\n\nCalculates span-variant structural properties for composite blades. Holds all inputs and outputs to properties function in structs\n\n\n\n\n\n","category":"method"},{"location":"reference/referencePreComp/#OWENSPreComp.q_bars-NTuple{7, Any}","page":"OWENSPreComp","title":"OWENSPreComp.q_bars","text":"q_bars(mat, thp, density, q11, q22, q12, q66)\n\nArguments\n\nmat: material id\nthp: ply orientation\ndensity:\nq11:\nq22:\nq12:\nq66:\n\nOutputs\n\nqbar11:\nqbar22:\nqbar12:\nqbar16:\nqbar26:\nqbar66:\nrho_m:\n\n\n\n\n\n","category":"method"},{"location":"reference/referencePreComp/#OWENSPreComp.readcompositesection-Tuple{String, Vector{Float64}}","page":"OWENSPreComp","title":"OWENSPreComp.readcompositesection","text":"readcompositesection(fname::String,locw::Array{Float64,1})\n\nReads a composite section input file. Returns locU, nlaminaU, npliesU, tU, thetaU, matidxU, locL, nlaminaL, npliesL, tL, thetaL, matidxL, locW, nlaminaW, npliesW, tW, thetaW, mat_idxW\n\n\n\n\n\n","category":"method"},{"location":"reference/referencePreComp/#OWENSPreComp.readmain-Tuple{String}","page":"OWENSPreComp","title":"OWENSPreComp.readmain","text":"readmain(\"fname::String\")\n\nReads a main OWENSPreComp input file. Returns sloc,leloc,chord,twaero,afshapefile,intstrfile, ibspstn,obspstn,ibchloc,obchloc\n\n\n\n\n\n","category":"method"},{"location":"reference/referencePreComp/#OWENSPreComp.readmaterials","page":"OWENSPreComp","title":"OWENSPreComp.readmaterials","text":"readmaterials(fname = \"materials.inp\")\n\nreads material properties from OWENSPreComp materials input file fname returns e1,e2,g12,nu12,rho,name\n\n\n\n\n\n","category":"function"},{"location":"reference/referencePreComp/#OWENSPreComp.readprecompprofile-Tuple{String}","page":"OWENSPreComp","title":"OWENSPreComp.readprecompprofile","text":"readprecompprofile(filename::String) Reads precomp profile file. Returns xu, yu, xl, yl\n\n\n\n\n\n","category":"method"},{"location":"reference/referencePreComp/#OWENSPreComp.readprofile-Tuple{String, Int64, Bool}","page":"OWENSPreComp","title":"OWENSPreComp.readprofile","text":"readprofile(filename::String, numHeaderlines::Int64, LEtoLE::Bool) Reads precomp profile file. Returns xu, yu, xl, yl\n\n\n\n\n\n","category":"method"},{"location":"reference/referencePreComp/#OWENSPreComp.readsectorsfromfile-Tuple{IOStream, Int64}","page":"OWENSPreComp","title":"OWENSPreComp.readsectorsfromfile","text":"readsectorsfromfile(f::IOStream, n_sector::Int64)\n\nReads OWENSPreComp sector. Returns nlamina,nplies, t, theta, mat_idx\n\n\n\n\n\n","category":"method"},{"location":"reference/referencePreComp/#OWENSPreComp.seg_info-NTuple{16, Any}","page":"OWENSPreComp","title":"OWENSPreComp.seg_info","text":"seg_info(ch, rle, nseg, nseg_u, nseg_p, xnode_u, ynode_u,\nxnode_l, ynode_l, ndl1, ndu1, loc_web, weby_u, weby_l, n_scts,\nxsec_node)\n\nNOTE: coord transformation from xaf-yaf to yre-zref and seg info\n\n\n\n\n\n","category":"method"},{"location":"reference/referencePreComp/#OWENSPreComp.tw_rate-Tuple{Any, Any, Any}","page":"OWENSPreComp","title":"OWENSPreComp.tw_rate","text":"tw_rate(naf, sloc, tw_aero)\n\nArguments\n\nnaf: no of blade stations\nsloc: vector of station locations\ntw_aero_d: vector of twist distribution in degrees\n\nOutputs\n\nth_prime_d: vector of twist rates in degrees\n\n\n\n\n\n","category":"method"},{"location":"examples/B_detailedInputs/#simple2","page":"Detailed Inputs","title":"Detailed Inputs","text":"","category":"section"},{"location":"examples/B_detailedInputs/","page":"Detailed Inputs","title":"Detailed Inputs","text":"In this example, we show the second level of what is going on behind the precompiled binary This would be appropriate if you need more customization in the run and design parameters than the input file currently allows, but your design still fits within the setupOWENS helper function etc.","category":"page"},{"location":"examples/B_detailedInputs/","page":"Detailed Inputs","title":"Detailed Inputs","text":"tip: Tip\nThis example is also available as a Jupyter notebook: B_detailedInputs.ipynb.","category":"page"},{"location":"examples/B_detailedInputs/","page":"Detailed Inputs","title":"Detailed Inputs","text":"First we import the packages.  If \"using\" was employed, then all of the functions of the packages specified would be made available, but \"import\" requires PackageName.FunctionName to be used unless the function was explicitely exported in the package.  If \"include(\"filepath/filename.jl)\" is used, that is the same as copying and pasting.  Please see the respective page on YAML input (TODO) for a description of the YAML inputs","category":"page"},{"location":"examples/B_detailedInputs/","page":"Detailed Inputs","title":"Detailed Inputs","text":"import OWENS\nimport OWENSAero\n#### import PyPlot\nrunpath = path = \"/home/runner/work/OWENS.jl/OWENS.jl/examples/literate\" # to run locally, change to splitdir(@__FILE__)[1]\n# runpath = path = splitdir(@__FILE__)[1]\nInp = OWENS.MasterInput(\"$runpath/sampleOWENS.yml\")\n\nnothing","category":"page"},{"location":"examples/B_detailedInputs/","page":"Detailed Inputs","title":"Detailed Inputs","text":"Unpack inputs, or you could directly input them here and bypass the file","category":"page"},{"location":"examples/B_detailedInputs/","page":"Detailed Inputs","title":"Detailed Inputs","text":"verbosity = 1\n\nanalysisType = Inp.analysisType\nturbineType = Inp.turbineType\neta = Inp.eta\nNbld = Inp.Nbld\ntowerHeight = Inp.towerHeight\nrho = Inp.rho\nVinf = Inp.Vinf\ncontrolStrategy = Inp.controlStrategy\nRPM = Inp.RPM\nNslices = Inp.Nslices\nntheta = Inp.ntheta\nstructuralModel = Inp.structuralModel\nntelem = Inp.ntelem\nnbelem = Inp.nbelem\nncelem = Inp.ncelem\nnselem = Inp.nselem\nifw = Inp.ifw\nWindType = Inp.WindType\nAeroModel = Inp.AeroModel\nwindINPfilename = \"$(path)$(Inp.windINPfilename)\"\nifw_libfile = Inp.ifw_libfile\nif ifw_libfile == \"nothing\"\n    ifw_libfile = nothing\nend\nBlade_Height = Inp.Blade_Height\nBlade_Radius = Inp.Blade_Radius\nnumTS = Inp.numTS\ndelta_t = Inp.delta_t\nNuMad_geom_xlscsv_file_twr = \"$(path)$(Inp.NuMad_geom_xlscsv_file_twr)\"\nNuMad_mat_xlscsv_file_twr = \"$(path)$(Inp.NuMad_mat_xlscsv_file_twr)\"\nNuMad_geom_xlscsv_file_bld = \"$(path)$(Inp.NuMad_geom_xlscsv_file_bld)\"\nNuMad_mat_xlscsv_file_bld = \"$(path)$(Inp.NuMad_mat_xlscsv_file_bld)\"\nNuMad_geom_xlscsv_file_strut = \"$(path)$(Inp.NuMad_geom_xlscsv_file_strut)\"\nNuMad_mat_xlscsv_file_strut = \"$(path)$(Inp.NuMad_mat_xlscsv_file_strut)\"\nadi_lib = Inp.adi_lib\nif adi_lib == \"nothing\"\n    adi_lib = nothing\nend\nadi_rootname = \"$(path)$(Inp.adi_rootname)\"\n\nB = Nbld\nR = Blade_Radius#177.2022*0.3048 #m\nH = Blade_Height#1.02*R*2 #m\n\nshapeZ = collect(LinRange(0,H,Nslices+1))\nshapeX = R.*(1.0.-4.0.*(shapeZ/H.-.5).^2)#shapeX_spline(shapeZ)\n\nnothing","category":"page"},{"location":"examples/B_detailedInputs/","page":"Detailed Inputs","title":"Detailed Inputs","text":"Call the helper function that builds the mesh, calculates the sectional properties, and aligns the sectional properties to the mesh elements,","category":"page"},{"location":"examples/B_detailedInputs/","page":"Detailed Inputs","title":"Detailed Inputs","text":"mymesh,myel,myort,myjoint,sectionPropsArray,mass_twr, mass_bld,\nstiff_twr, stiff_bld,bld_precompinput,\nbld_precompoutput,plyprops_bld,numadIn_bld,lam_U_bld,lam_L_bld,\ntwr_precompinput,twr_precompoutput,plyprops_twr,numadIn_twr,lam_U_twr,lam_L_twr,aeroForces,deformAero,\nmass_breakout_blds,mass_breakout_twr,system,assembly,sections,AD15bldNdIdxRng, AD15bldElIdxRng = OWENS.setupOWENS(OWENSAero,path;\n    rho,\n    Nslices,\n    ntheta,\n    RPM,\n    Vinf,\n    eta,\n    B,\n    H,\n    R,\n    shapeZ,\n    shapeX,\n    ifw,\n    WindType,\n    delta_t,\n    numTS,\n    adi_lib,\n    adi_rootname,\n    windINPfilename,\n    ifw_libfile,\n    NuMad_geom_xlscsv_file_twr,# = \"$path/data/NuMAD_Geom_SNL_5MW_ARCUS_Cables.csv\",\n    NuMad_mat_xlscsv_file_twr,# = \"$path/data/NuMAD_Materials_SNL_5MW_D_TaperedTower.csv\",\n    NuMad_geom_xlscsv_file_bld,# = \"$path/data/NuMAD_Geom_SNL_5MW_ARCUS.csv\",\n    NuMad_mat_xlscsv_file_bld,# = \"$path/data/NuMAD_Materials_SNL_5MW_D_Carbon_LCDT_ThickFoils_ThinSkin.csv\",\n    NuMad_geom_xlscsv_file_strut,\n    NuMad_mat_xlscsv_file_strut,\n    Htwr_base=towerHeight,\n    strut_twr_mountpoint = [0.2,0.8],\n    strut_bld_mountpoint = [0.2,0.8],\n    ntelem,\n    nbelem,\n    ncelem,\n    nselem,\n    joint_type = 0,\n    c_mount_ratio = 0.05,\n    AeroModel, #AD, DMS, AC\n    DynamicStallModel=\"BV\",\n    RPI=true,\n    cables_connected_to_blade_base = true,\n    meshtype = turbineType)\n\nnothing","category":"page"},{"location":"examples/B_detailedInputs/","page":"Detailed Inputs","title":"Detailed Inputs","text":"Optionally, we can run the finite element solver with gemetrically exact beam theory via GXBeam.jl this requires that the OWENS style inputs are converted to the GXBeam inputs.  This interface also includes the ability to output VTK files, which can be viewed in paraview.  We have adapted this interface to work with OWENS inputs as well.","category":"page"},{"location":"examples/B_detailedInputs/","page":"Detailed Inputs","title":"Detailed Inputs","text":"nothing","category":"page"},{"location":"examples/B_detailedInputs/","page":"Detailed Inputs","title":"Detailed Inputs","text":"If the sectional properties material files includes cost information, that is combined with the density to estimate the overall material cost of of materials in the blades","category":"page"},{"location":"examples/B_detailedInputs/","page":"Detailed Inputs","title":"Detailed Inputs","text":"if verbosity>0\n\n    println(\"\\nBlades' Mass Breakout\")\n    for (i,name) in enumerate(plyprops_bld.names)\n        println(\"$name $(mass_breakout_blds[i]) kg, $(plyprops_bld.costs[i]) \\$/kg: \\$$(mass_breakout_blds[i]*plyprops_bld.costs[i])\")\n    end\n\n    println(\"\\nTower Mass Breakout\")\n    for (i,name) in enumerate(plyprops_twr.names)\n        println(\"$name $(mass_breakout_twr[i]) kg, $(plyprops_twr.costs[i]) \\$/kg: \\$$(mass_breakout_twr[i]*plyprops_twr.costs[i])\")\n    end\n\n    println(\"Total Material Cost Blades: \\$$(sum(mass_breakout_blds.*plyprops_bld.costs))\")\n    println(\"Total Material Cost Tower: \\$$(sum(mass_breakout_twr.*plyprops_twr.costs))\")\n    println(\"Total Material Cost: \\$$(sum(mass_breakout_blds.*plyprops_bld.costs)+ sum(mass_breakout_twr.*plyprops_twr.costs))\")\n\nend\n\nnothing","category":"page"},{"location":"examples/B_detailedInputs/","page":"Detailed Inputs","title":"Detailed Inputs","text":"Here we apply the boundary conditions.  For this case, with a regular cantelever tower, the tower base node which is 1 is constrained in all 6 degrees of freedom to have a displacement of 0.  You can change this displacement to allow for things like pretension, and you can apply boundary conditions to any node.","category":"page"},{"location":"examples/B_detailedInputs/","page":"Detailed Inputs","title":"Detailed Inputs","text":"pBC = [1 1 0\n1 2 0\n1 3 0\n1 4 0\n1 5 0\n1 6 0]\n\nnothing","category":"page"},{"location":"examples/B_detailedInputs/","page":"Detailed Inputs","title":"Detailed Inputs","text":"There are inputs for the overall coupled simulation, please see the api reference for specifics on all the options","category":"page"},{"location":"examples/B_detailedInputs/","page":"Detailed Inputs","title":"Detailed Inputs","text":"if AeroModel==\"AD\"\n    AD15On = true\nelse\n    AD15On = false\nend\n\ninputs = OWENS.Inputs(;verbosity,analysisType = structuralModel,\ntocp = [0.0,100000.1],\nOmegaocp = [RPM,RPM] ./ 60,\ntocp_Vinf = [0.0,100000.1],\nVinfocp = [Vinf,Vinf],\nnumTS,\ndelta_t,\nAD15On,\naeroLoadsOn = 2)\n\nnothing","category":"page"},{"location":"examples/B_detailedInputs/","page":"Detailed Inputs","title":"Detailed Inputs","text":"Then there are inputs for the finite element models, also, please see the api reference for specifics on the options (TODO: ensure that this is propogated to the docs)","category":"page"},{"location":"examples/B_detailedInputs/","page":"Detailed Inputs","title":"Detailed Inputs","text":"feamodel = OWENS.FEAModel(;analysisType = structuralModel,\ndataOutputFilename = \"none\",\njoint = myjoint,\nplatformTurbineConnectionNodeNumber = 1,\npBC,\nnlOn = true,\nnumNodes = mymesh.numNodes,\nRayleighAlpha = 0.05,\nRayleighBeta = 0.05,\niterationType = \"DI\")\n\nnothing","category":"page"},{"location":"examples/B_detailedInputs/","page":"Detailed Inputs","title":"Detailed Inputs","text":"Here is where we actually call the unsteady simulation and where owens pulls the aero and structural solutions together and propogates things in time.","category":"page"},{"location":"examples/B_detailedInputs/","page":"Detailed Inputs","title":"Detailed Inputs","text":"println(\"Running Unsteady\")\nt, aziHist,OmegaHist,OmegaDotHist,gbHist,gbDotHist,gbDotDotHist,FReactionHist,\nFTwrBsHist,genTorque,genPower,torqueDriveShaft,uHist,uHist_prp,epsilon_x_hist,epsilon_y_hist,\nepsilon_z_hist,kappa_x_hist,kappa_y_hist,kappa_z_hist = OWENS.Unsteady_Land(inputs;system,assembly,\ntopModel=feamodel,topMesh=mymesh,topEl=myel,aero=aeroForces,deformAero)\n\nif AD15On #TODO: move this into the run functions\n    OWENS.OWENSOpenFASTWrappers.endTurb()\nend\n\nnothing","category":"page"},{"location":"examples/B_detailedInputs/","page":"Detailed Inputs","title":"Detailed Inputs","text":"Like described above, we can output vtk files viewable in paraview.  Here it is done for each time step and shows the deformations.  Additionaly, there is a method to input custom values and have them show up on the vtk surface mesh for example, strain, or reaction force, etc.  This is described in more detail in the api reference for the function and: TODO","category":"page"},{"location":"examples/B_detailedInputs/","page":"Detailed Inputs","title":"Detailed Inputs","text":"println(\"Saving VTK time domain files\")\nOWENS.OWENSFEA_VTK(\"$path/vtk/SNLARCUS5MW_timedomain_TNBnltrue\",t,uHist,system,assembly,sections;scaling=1,azi=aziHist)\n\nnothing","category":"page"},{"location":"examples/B_detailedInputs/","page":"Detailed Inputs","title":"Detailed Inputs","text":"This helper function looks through all the loads and picks out the worst case safety factor in each of the stacks of composite lamina it also calculates analytical simply supported buckling safety factors","category":"page"},{"location":"examples/B_detailedInputs/","page":"Detailed Inputs","title":"Detailed Inputs","text":"##########################################\n#### Ultimate Failure #####\n##########################################\n\nmassOwens,stress_U,SF_ult_U,SF_buck_U,stress_L,SF_ult_L,SF_buck_L,stress_TU,SF_ult_TU,\nSF_buck_TU,stress_TL,SF_ult_TL,SF_buck_TL,topstrainout_blade_U,topstrainout_blade_L,\ntopstrainout_tower_U,topstrainout_tower_LtopDamage_blade_U,\ntopDamage_blade_L,topDamage_tower_U,topDamage_tower_L = OWENS.extractSF(bld_precompinput,\nbld_precompoutput,plyprops_bld,numadIn_bld,lam_U_bld,lam_L_bld,\ntwr_precompinput,twr_precompoutput,plyprops_twr,numadIn_twr,lam_U_twr,lam_L_twr,\nmymesh,myel,myort,Nbld,epsilon_x_hist,kappa_y_hist,kappa_z_hist,epsilon_z_hist,\nkappa_x_hist,epsilon_y_hist;verbosity, #Verbosity 0:no printing, 1: summary, 2: summary and spanwise worst safety factor # epsilon_x_hist_1,kappa_y_hist_1,kappa_z_hist_1,epsilon_z_hist_1,kappa_x_hist_1,epsilon_y_hist_1,\ncomposite_station_idx_U_strut = [1,6,3,2,5],\ncomposite_station_name_U_strut = [\"Leading Edge\",\"Trailing Edge\",\"Spar Cap\",\"Front Panel\",\"Rear Panel\"],\ncomposite_station_idx_L_strut = [1,6,3,2,5],\ncomposite_station_name_L_strut = [\"Leading Edge\",\"Trailing Edge\",\"Spar Cap\",\"Front Panel\",\"Rear Panel\"],\ncomposite_station_idx_U_bld = [1,6,3,2,5],\ncomposite_station_name_U_bld = [\"Leading Edge\",\"Trailing Edge\",\"Spar Cap\",\"Front Panel\",\"Rear Panel\"],\ncomposite_station_idx_L_bld = [1,6,3,2,5],\ncomposite_station_name_L_bld = [\"Leading Edge\",\"Trailing Edge\",\"Spar Cap\",\"Front Panel\",\"Rear Panel\"],\nTwr_LE_U_idx=1,Twr_LE_L_idx=1,\nAD15bldNdIdxRng,AD15bldElIdxRng,strut_precompoutput=nothing) #TODO: add in ability to have material safety factors and load safety factors\n\nnothing","category":"page"},{"location":"examples/B_detailedInputs/","page":"Detailed Inputs","title":"Detailed Inputs","text":"","category":"page"},{"location":"examples/B_detailedInputs/","page":"Detailed Inputs","title":"Detailed Inputs","text":"This page was generated using Literate.jl.","category":"page"},{"location":"VAWTGenUserGuide/#All-of-this-has-been-automated,-but-the-option-to-create-and-load-these-legacy-files-has-been-preserved.-TODO:-show-how-to-do-this-and-condense-and-modernize-this-text.","page":"Legacy VAWTGen Guide","title":"All of this has been automated, but the option to create and load these legacy files has been preserved.  TODO: show how to do this and condense and modernize this text.","text":"","category":"section"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"Version 1.0 User GuideBrian C. OwensWind Energy TechnologiesSandia National LaboratoriesNovember 7, 2013Contents","category":"page"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"Introduction 1","category":"page"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"Overview of VAWTGen Mesh Generator 1","category":"page"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"Demonstration 3","category":"page"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"Conventions Employed in Creating a Model with VAWTGen 5","category":"page"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"Structural and aerodynamic description of components 5","category":"page"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"Caveats of creating a VAWT configuration in VAWTGen 7","category":"page"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"Coordinate system 7","category":"page"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"Tower component 7","category":"page"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"Blade component 7","category":"page"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"Blade component 8","category":"page"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"VAWTGen Input File 9","category":"page"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"VAWTGen Command Line Execution 10","category":"page"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"VAWTGen Graphical Output 11","category":"page"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"VAWTGen Output Files 15","category":"page"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"OWENS Main Input File (.owens) 15","category":"page"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"Mesh File (.mesh) 16","category":"page"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"Element Property File (.el) 16","category":"page"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"Element Orientation File (.ort) 17","category":"page"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"Joint File (.jnt) 17","category":"page"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"Boundary Conditions File (.bc) 17","category":"page"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"Blade Data File (.bld) 18","category":"page"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"Output File (.out) 18","category":"page"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"Future Versions 18","category":"page"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"References 19","category":"page"},{"location":"VAWTGenUserGuide/#Introduction","page":"Legacy VAWTGen Guide","title":"Introduction","text":"","category":"section"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"This user guide presents instructions for using the VAWTGen vertical-axis wind turbine (VAWT) mesh generator. This generator is intended to be utilized with the Offshore Wind ENergy Simulation (OWENS) analysis tool [1]. The input files for this mesh generator are discussed in detail. Turbine components (tower, blades, and struts) are described using existing National Renewable Energy Laboratory (NREL) file formats [2]. A simple input file sizes these basic components and positions them in a hub fixed coordinate frame at arbitrary distances from the origin with arbitrary orientation. VAWTGen generates a mesh of a VAWT consisting of Timoshenko beam elements along with other files describing properties of the VAWT. These files serve as inputs to the OWENS analysis tool. VAWTGen also visualizes the VAWT assembly and mesh to provide a visual confirmation that the VAWT is constructed correctly. Furthermore, VAWTGen can visualize the modal and transient results output by the OWENS analysis tool.","category":"page"},{"location":"VAWTGenUserGuide/#Overview-of-VAWTGen-Mesh-Generator","page":"Legacy VAWTGen Guide","title":"Overview of VAWTGen Mesh Generator","text":"","category":"section"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"A VAWT rotor primarily consists of a tower and blade components. The blades may be affixed to the tower at their ends as in the Darrieus and V-VAWT configurations or via struts as in the H-VAWT configuration. Struts may also provide a connection between the tower and blades at any position along the tower and blade spans. The VAWTGen mesh generator is capable of generating VAWTs of arbitrary geometry, including H-type, V-type, and Darrieus configurations shown in Figure 1. The VAWT configuration is discretized from continuous structural components into a finite number of beam elements. Elements span between discrete points in the mesh, known as nodes. Finite element analysis examines the motions of nodes as dictated by the deformation of the beam elements under prescribed boundary conditions. This collection of nodes and elements forms the mesh of the VAWT configuration.","category":"page"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"(Image: ){width=\"2.5990562117235347in\" height=\"1.453332239720035in\"}","category":"page"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"[]{#_bookmark2 .anchor}Figure 1 Illustrations of V, H, and Darrieus VAWT configurationsVAWTGen accepts data files containing the basic geometry of tower, blade, and strut components. Other crucial configuration information is specified such as the elevation of the blade root from the tower root, as well as the radial distance the blade root is positioned from the tower. An arbitrary number of blades may be specified for the configuration. VAWTGen positions the blade roots with equal azimuth spacing about the tower axis. The blades may be rotated into an arbitrary orientation per a sequence of Euler angles input by the user. If required, struts may be inserted between the tower and ablade by specifying a fraction of the tower span and the blade span the strut will span. VAWTGen will insert a straight strut of the appropriate length between the tower and blade components. The geometry of the strut component is specified by a file containing geometric data.With these relatively minimal set of inputs (as illustrated in Figure 2) a VAWT of arbitrary configuration may be created. Therefore, a separate tool is not required for the various types of configurations. VAWTGen provides a convenient means to visualize the VAWT turbine in a wireframe or rendered format. This serves as a quick check for the user to ensure the VAWT has been constructed as intended, and shows the actual turbine configuration that the mesh of beam elements represents. VAWTGen also visualizes the finite element mesh once it is created. VAWTGen identifies points of intersection between the various components and inserts nodes accordingly. These node pairs at points of intersection (i.e. strut to tower, blade to strut, blade to tower) are recorded so appropriate constraint conditions at these joints may be imposed. The orientation of the finite elements in the mesh is also visualized to ensure the elements are positioned and oriented as intended.","category":"page"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"(Image: C:\\\\Users\\\\bcowens\\\\Desktop\\\\meshGenFlow.png){width=\"4.016800087489064in\" height=\"2.6266666666666665in\"}","category":"page"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"[]{#_bookmark3 .anchor}Figure 2 Input and output of VAWTGen mesh generatorOutput includes a mesh file is generated that will be used by the analysis software. By default, the mesh is discretized in the same manner as the geometric description of components as specified in the component data files. The user may further subdivide the mesh by specifying an integer factor to further discretize the geometric data into elements. An elemental data file is also created, containing the structural properties of elements. An orientation file is generated containing the Euler angles representing the orientation of the elements. VAWTGen requires data files be supplied to describe the geometry of the primary turbine components (blades, towers, and struts). A joint file is also generated containing nodal information about joint locations. This file is used to specify general constraints between structural components. A blade file is also generated that contains aerodynamic data andprovides information needed for mapping aerodynamic loads to nodal locations on the structural model, as well as supplying geometry to aerodynamic data and geometry to external aerodynamic modules.The format of the structural component data files is the same as the component files for NREL's FAST code [2]. These files describe the geometry and aerodynamic properties of general turbine components, and there is nothing that restricts their use to horizontal-axis wind turbines (HAWTs) specifically. For example, even though a Darrieus blade is not likely be installed on a HAWT, it is easily described by the NREL's FAST blade geometry file format. This allows existing wind energy design tools to be interfaced with the VAWT analysis tool without the need to consider new file formats. NREL's FAST separates geometrical/structural properties of a blade and aerodynamic properties of a blade into two files and the same approach is employed in the VAWTGen mesh generator.","category":"page"},{"location":"VAWTGenUserGuide/#Demonstration","page":"Legacy VAWTGen Guide","title":"Demonstration","text":"","category":"section"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"This section demonstrates the capabilities of the VAWTGen mesh generator. First a two bladed V-VAWT configuration is considered. Figure 3 shows the wireframe visualization of this VAWT. The red line within the wireframe represents the beam flexural axis upon which the actual finite element mesh is created. Note that the blades may be positioned at any orientation. The blades and top of the tower share a common point and can be joined together via a constraint relationship that appropriately models the joint. Next, a three bladed H-VAWT with multiple strut connections is considered. Figure 4 shows the wireframe visualization and mesh for the H-VAWT configuration. The blades are oriented at an arbitrary orientation, and two strut connections per blade are specified. Finally, Darrieus type turbine configurations with swept and strutted blades are considered as shown in Figure 5 and Figure 6 respectively.(Image: C:\\\\Users\\\\bcowens\\\\Desktop\\\\export_fig\\\\Vvawt.png){width=\"1.8892694663167104in\" height=\"3.2266666666666666in\"} (Image: C:\\\\Users\\\\bcowens\\\\Desktop\\\\export_fig\\\\hvawt.png){width=\"1.3600043744531933in\" height=\"3.2133333333333334in\"}[]{#bookmark5 .anchor}Figure 3 Wireframe of V-VAWT []{#bookmark6 .anchor}Figure 4 Wireframe of H-VAWT","category":"page"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"(Image: C:\\\\Users\\\\bcowens\\\\Desktop\\\\export_fig\\\\dar3swept.png){width=\"1.02086176727909in\" height=\"3.3866666666666667in\"}(Image: C:\\\\Users\\\\bcowens\\\\Desktop\\\\export_fig\\\\dar3strut.png){width=\"0.8588167104111986in\" height=\"3.3866666666666667in\"}","category":"page"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"+–––––––––––––––––+–––––––––––––––––-+ | > []{#bookmark7                 | > []{#bookmark8 .anchor}Figure | | > .anchor}Figure 5 Wireframe   | > 6 Wireframe of Strutted         | | > of Swept Darrieus VAWT**       | > Darrieus VAWT**                 | +==================================+===================================+ +–––––––––––––––––+–––––––––––––––––-+","category":"page"},{"location":"VAWTGenUserGuide/#Conventions-Employed-in-Creating-a-Model-with-VAWTGen","page":"Legacy VAWTGen Guide","title":"Conventions Employed in Creating a Model with VAWTGen","text":"","category":"section"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"This section describes some specific conventions and caveats of creating a mesh of a VAWT using the VAWTGen mesh generator. First, the files use to describe the structural and aerodynamic properties of files are discussed","category":"page"},{"location":"VAWTGenUserGuide/#Structural-and-aerodynamic-description-of-components","page":"Legacy VAWTGen Guide","title":"Structural and aerodynamic description of components","text":"","category":"section"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"Structural and aerodynamic descriptions of components are specified through NREL FAST file format using the blade .dat files and Aerodyn .ipt files. For structural description (using the .dat file), only the lines highlighted in red are considered by VAWTGen.","category":"page"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"+––––––+–––+–––––-+–-+–––+–-+–––-+–––-+––+ | > (-)    | *    | >         |   | >    |   | > *   | > **  | ** | | > (-)    | *(de |  (kg/m) |   |  **( |   | *(Nm\\ | (N) | (- | |            | g)** | >         |   | Nm\\^ |   | ^2)** |       | ** | |            |      | (Nm\\^2)** |   | 2)** |   |       |       |    | +============+======+===========+===+======+===+=======+=======+====+ | > ) (kg  | >    | **(m)   | * | (  | > | > **  |       |    | | > m) (kg | m) |           | * | m) |   | (m)** |       |    | |            | > (  |           | ( |      | * |       |       |    | |            | m)** |           | m |      | * |       |       |    | |            |      |           | ) |      | ( |       |       |    | |            |      |           | * |      | m |       |       |    | |            |      |           | * |      | ) |       |       |    | |            |      |           |   |      | * |       |       |    | |            |      |           |   |      | * |       |       |    | +––––––+–––+–––––-+–-+–––+–-+–––-+–––-+––+","category":"page"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"+––-+––+–––-+–––+––––––––-+––––-+––––+––+ | >   |    | 0.  | **   | > **9.163e+009  | > *     | > **   | >  | | **0 |    | 000 | 353. | > 9.163e+009**  | *6.8042 | 8.211e |  * | | .00 |    |       | 43** |                 | e+009** | +009** | *0 | | 000 |    |       |      |                 |         |        | .0 | | > 0 |    |       |      |                 |         |        | 00 | | .20 |    |       |      |                 |         |        | ** | | 0** |    |       |      |                 |         |        |    | +=====+====+=======+======+=================+=========+========+====+ | >   |    | >     | > *  | > 0.000 0.0   | > **    |        |    | |  ** |    |  **0. | *0.0 | > 0.000       | 0.000** |        |    | | 316 |    | 000** | 00** |                 |         |        |    | | .71 |    |       |      |                 |         |        |    | | >   |    |       |      |                 |         |        |    | |  31 |    |       |      |                 |         |        |    | | 6.7 |    |       |      |                 |         |        |    | | 1** |    |       |      |                 |         |        |    | +––-+––+–––-+–––+––––––––-+––––-+––––+––+ | >   |    | 0.  | **   | **9.163e+009    | > *     | **     | *  | | **0 |    | 000 | 353. | 9.163e+009**    | *6.8042 | 8.211e | *0 | | .05 |    |       | 43** |                 | e+009** | +009** | .0 | | > 0 |    |       |      |                 |         |        | 00 | | .20 |    |       |      |                 |         |        | ** | | 0** |    |       |      |                 |         |        |    | +––-+––+–––-+–––+––––––––-+––––-+––––+––+ | >   |    | >     | > *  | > 0.000 0.0   | > **    |        |    | |  ** |    |  **0. | *0.0 | > 0.000       | 0.000** |        |    | | 316 |    | 000** | 00** |                 |         |        |    | | .71 |    |       |      |                 |         |        |    | | >   |    |       |      |                 |         |        |    | |  31 |    |       |      |                 |         |        |    | | 6.7 |    |       |      |                 |         |        |    | | 1** |    |       |      |                 |         |        |    | +––-+––+–––-+–––+––––––––-+––––-+––––+––+ | >   |    | 0.  | **   | **9.163e+009    | > *     | **     | *  | |  ** |    | 000 | 353. | 9.163e+009**    | *6.8042 | 8.211e | *0 | | 0.1 |    |       | 43** |                 | e+009** | +009** | .0 | | > 0 |    |       |      |                 |         |        | 00 | | .20 |    |       |      |                 |         |        | ** | | 0** |    |       |      |                 |         |        |    | +––-+––+–––-+–––+––––––––-+––––-+––––+––+ | >   |    | >     | > *  | > 0.000 0.0   | > **    |        |    | |  ** |    |  **0. | *0.0 | > 0.000       | 0.000** |        |    | | 316 |    | 000** | 00** |                 |         |        |    | | .71 |    |       |      |                 |         |        |    | | >   |    |       |      |                 |         |        |    | |  31 |    |       |      |                 |         |        |    | | 6.7 |    |       |      |                 |         |        |    | | 1** |    |       |      |                 |         |        |    | | >   |    |       |      |                 |         |        |    | | >   |    |       |      |                 |         |        |    | |  ** |    |       |      |                 |         |        |    | | .. |    |       |      |                 |         |        |    | | .** |    |       |      |                 |         |        |    | +––-+––+–––-+–––+––––––––-+––––-+––––+––+ | > * | >  | 0.  | **   | **9.163e+009    | > *     | **     | *  | | *0. |  * | 000 | 353. | 9.163e+009**    | *6.8042 | 8.211e | *0 | | 8** | *0 |       | 43** |                 | e+009** | +009** | .0 | |     | .2 |       |      |                 |         |        | 00 | |     | 00 |       |      |                 |         |        | ** | |     | ** |       |      |                 |         |        |    | +––-+––+–––-+–––+––––––––-+––––-+––––+––+ | > * | ** | >     | > *  | > 0.000 0.0   | > **    |        |    | | *31 | 31 |  **0. | *0.0 | > 0.000       | 0.000** |        |    | | 6.7 | 6. | 000** | 00** |                 |         |        |    | | 1** | 71 |       |      |                 |         |        |    | |     | ** |       |      |                 |         |        |    | +––-+––+–––-+–––+––––––––-+––––-+––––+––+ | >   | >  | 0.  | **   | **9.163e+009    | > *     | **     | *  | |  ** |  * | 000 | 353. | 9.163e+009**    | *6.8042 | 8.211e | *0 | | 0.8 | *0 |       | 43** |                 | e+009** | +009** | .0 | | 5** | .2 |       |      |                 |         |        | 00 | |     | 00 |       |      |                 |         |        | ** | |     | ** |       |      |                 |         |        |    | +––-+––+–––-+–––+––––––––-+––––-+––––+––+ | > * | ** | >     | > *  | > 0.000 0.0   | > **    |        |    | | *31 | 31 |  **0. | *0.0 | > 0.000       | 0.000** |        |    | | 6.7 | 6. | 000** | 00** |                 |         |        |    | | 1** | 71 |       |      |                 |         |        |    | |     | ** |       |      |                 |         |        |    | +––-+––+–––-+–––+––––––––-+––––-+––––+––+ | > * | >  | 0.  | **   | **9.163e+009    | > *     | **     | *  | | *0. |  * | 000 | 353. | 9.163e+009**    | *6.8042 | 8.211e | *0 | | 9** | *0 |       | 43** |                 | e+009** | +009** | .0 | |     | .2 |       |      |                 |         |        | 00 | |     | 00 |       |      |                 |         |        | ** | |     | ** |       |      |                 |         |        |    | +––-+––+–––-+–––+––––––––-+––––-+––––+––+ | > * | ** | >     | > *  | > 0.000 0.0   | > **    |        |    | | *31 | 31 |  **0. | *0.0 | > 0.000       | 0.000** |        |    | | 6.7 | 6. | 000** | 00** |                 |         |        |    | | 1** | 71 |       |      |                 |         |        |    | |     | ** |       |      |                 |         |        |    | +––-+––+–––-+–––+––––––––-+––––-+––––+––+ | >   | >  | 0.  | **   | **9.163e+009    | > *     | **     | *  | |  ** |  * | 000 | 353. | 9.163e+009**    | *6.8042 | 8.211e | *0 | | 0.9 | *0 |       | 43** |                 | e+009** | +009** | .0 | | 5** | .2 |       |      |                 |         |        | 00 | |     | 00 |       |      |                 |         |        | ** | |     | ** |       |      |                 |         |        |    | +––-+––+–––-+–––+––––––––-+––––-+––––+––+ | > * | ** | >     | > *  | > 0.000 0.0   | > **    |        |    | | *31 | 31 |  **0. | *0.0 | > 0.000       | 0.000** |        |    | | 6.7 | 6. | 000** | 00** |                 |         |        |    | | 1** | 71 |       |      |                 |         |        |    | |     | ** |       |      |                 |         |        |    | +––-+––+–––-+–––+––––––––-+––––-+––––+––+ | >   | >  | 0.  | **   | > **9.163e+009  | > *     | > **   | >  | |  ** |  * | 000 | 353. | > 9.163e+009**  | *6.8042 | 8.211e |  * | | 1.0 | *0 |       | 43** |                 | e+009** | +009** | *0 | | 000 | .2 |       |      |                 |         |        | .0 | | 0** | 00 |       |      |                 |         |        | 00 | |     | ** |       |      |                 |         |        | ** | +––-+––+–––-+–––+––––––––-+––––-+––––+––+ | > * | ** | >     | > *  | > 0.000 0.0   | > **    |        |    | | *31 | 31 |  **0. | *0.0 | > 0.000       | 0.000** |        |    | | 6.7 | 6. | 000** | 00** |                 |         |        |    | | 1** | 71 |       |      |                 |         |        |    | |     | ** |       |      |                 |         |        |    | +––-+––+–––-+–––+––––––––-+––––-+––––+––+","category":"page"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"Caveats of blade structural description in VAWTGen are described below.","category":"page"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"(Image: ){width=\"4.046369203849519e-3in\"   height=\"0.15120188101487314in\"}The alpha column describing   bend-twist coupling is not currently employed in the   analysis.(Image: ){width=\"4.046369203849519e-3in\"   height=\"0.15120188101487314in\"}\nFor blades, the reference axis is assumed to pass through the   quarter chord. The blade may be shaped by using the PrecrvRef and   PreswpRef parameters.\nVAWTGen creates a counter clockwise rotating turbine. A positive   PreswpRef parameter sweeps a blade away from the direction of   rotation. A positive PrecrvRef will shape a blade outward from the   machine center.\nEdgewise elastic axis and mass center offsets are positive towards   the trailing edge of the blade section.\nFlapwise elastic axis and mass center offsets are positive in the   direction outward from the machine center.\nUnder these assumptions, positive structural twist twists the   leading edge inwards towards the machine center.\nAll other structural properties are the same as that specified in   the FAST manual[1].","category":"page"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"The aerodynamic description of a component is accomplished via the Aerodyn .ipt file format. As with the blade properties (.dat) file, only certain parts of this file are used by VAWTGen. Specifically, the parts used by VAWTGen are highlighted in red in the example file below.Note that the DRNodes and PrnElm columns are not used by VAWTGen but must remain in the file for successful reading of the .ipt file. As with the conventional use of the file, RNodes denotes a point by a physical distance along a blade span from the root. AeroTwst is the aerodynamic twist angle in degrees such that a positive twist angle rotates the leading edge of the blade inwards towards machine center. Chord is used as an aerodynamic property and also for a wireframe visualization of a VAWT design. N(Image: ){width=\"4.046369203849519e-3in\" height=\"0.15120188101487314in\"}Foil gives an airfoil ID to a section. For wireframe visualization purposes the following thickness to chord ratios for an elliptical cross-section are specified by the NFoil integer: 1 – 1.0, 2 – 0.6, 3 - 0.3, all other –0.2. These thickness to chord ratios are only employed for visualization purposes and do not affect VAWTGen output.","category":"page"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"+––––––-+–––––-+––––––-+–––-+–––+–––––––+ | >           | 11.10 | >           | 1   | *    | **NOPRINT  | | 2.85833 |           | 2.21667 | .22** | *2** |              | +=============+===========+=============+=======+======+==============+ | >           | 11.10 | >           | 1   | *    | **NOPRINT  | | 5.07500 |           | 2.21667 | .22** | *2** |              | +––––––-+–––––-+––––––-+–––-+–––+–––––––+ | >           | 11.10 | >           | 1   | *    | **NOPRINT  | | 7.29167 |           | 2.21667 | .22** | *2** |              | +––––––-+–––––-+––––––-+–––-+–––+–––––––+ | >           | 10.41 | >           | 1   | *    | **NOPRINT  | | 9.50833 |           | 2.21667 | .22** | *2** |              | +––––––-+–––––-+––––––-+–––-+–––+–––––––+ | > *         | 8.38  | >           | 1   | *    | **NOPRINT  | | *11.72500** |           | 2.21667 | .22** | *2** |              | +––––––-+–––––-+––––––-+–––-+–––+–––––––+ | > *         | 6.35  | >           | 1   | *    | **NOPRINT  | | *13.94167** |           | 2.21667 | .22** | *2** |              | +––––––-+–––––-+––––––-+–––-+–––+–––––––+ | > *         | 4.33  | >           | 1   | *    | **NOPRINT  | | *16.15833** |           | 2.21667 | .22** | *2** |              | +––––––-+–––––-+––––––-+–––-+–––+–––––––+ | > *         | 2.85  | >           | 1   | *    | **NOPRINT  | | *18.37500** |           | 2.21667 | .22** | *2** |              | +––––––-+–––––-+––––––-+–––-+–––+–––––––+ | > *         | 2.22  | >           | 1   | *    | **NOPRINT  | | *20.59167** |           | 2.21667 | .22** | *2** |              | +––––––-+–––––-+––––––-+–––-+–––+–––––––+ | > *         | 1.58  | >           | 1   | *    | **NOPRINT  | | *22.80833** |           | 2.21667 | .22** | *2** |              | +––––––-+–––––-+––––––-+–––-+–––+–––––––+ | > *         | 0.95  | >           | 1   | *    | **NOPRINT  | | *25.02500** |           | 2.21667 | .22** | *2** |              | +––––––-+–––––-+––––––-+–––-+–––+–––––––+ | > *         | 0.53  | >           | 1   | *    | **NOPRINT  | | *27.24167** |           | 2.21667 | .22** | *2** |              | +––––––-+–––––-+––––––-+–––-+–––+–––––––+ | > *         | 0.38  | >           | 1   | *    | **NOPRINT  | | *29.45833** |           | 2.21667 | .22** | *2** |              | +––––––-+–––––-+––––––-+–––-+–––+–––––––+ | > *         | 0.23  | >           | 1   | *    | **NOPRINT  | | *31.67500** |           | 2.21667 | .22** | *2** |              | +––––––-+–––––-+––––––-+–––-+–––+–––––––+ | > *         | 0.08  | >           | 1   | *    | **NOPRINT  | | *33.89167** |           | 2.21667 | .22** | *2** |              | +––––––-+–––––-+––––––-+–––-+–––+–––––––+","category":"page"},{"location":"VAWTGenUserGuide/#Caveats-of-creating-a-VAWT-configuration-in-VAWTGen","page":"Legacy VAWTGen Guide","title":"Caveats of creating a VAWT configuration in VAWTGen","text":"","category":"section"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"The previous sections discussed the files for describing the various components (blades, tower, struts) of a VAWT. This section provides details for creating consistent VAWT models using VAWTGen and illustrates input parameters.","category":"page"},{"location":"VAWTGenUserGuide/#Coordinate-system","page":"Legacy VAWTGen Guide","title":"Coordinate system","text":"","category":"section"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"The following coordinate system z-axis is along the tower axis, and x- and y-axes are in the plane of rotation.","category":"page"},{"location":"VAWTGenUserGuide/#Tower-component","page":"Legacy VAWTGen Guide","title":"Tower component","text":"","category":"section"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"The primary input for the tower component is the tower length or height. With this specification, VAWTGen positions the tower vertically along the h~3~ axis with the root of the tower at the origin of the coordinate system. A straight tower is assumed. Any PrecrvRef or PreswpRef specified in the .dat file for the tower is ignored.","category":"page"},{"location":"VAWTGenUserGuide/#Blade-component","page":"Legacy VAWTGen Guide","title":"Blade component","text":"","category":"section"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"The blade components are positioned using the following input parameters:","category":"page"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"Number of blades\nBlade length\nBlade root elevation from tower base elevation (z= 0)\nBlade root radial offset from z-axis (this positions the root of the   blade at the appropriate x and y coordinates depending on the   azimuth location of the blade)\nBlade theta orientation a (degrees, rotation about the y-axis)\nBlade sweep angle (degrees, rotation about an intermediate \"2-axis\"   a positive angle sweeps the blade away from the direction of   rotation)","category":"page"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"Notes:","category":"page"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"The blade \"theta\" orientation angle should be negative so that the   root is at a lower elevation (z-coordinate). A warning message is   output if blade tip elevation is lower than blade root elevation.\nBlades will be positioned with equal azimuth spacing of the blade   root dictated by the specified number of blades.\nUnder this convention the root of \"Blade 1\" will always be   positioned at 180 degrees (the x-axis being at 0 degrees azimuth).   From this position blades are numbered in ascending order counter   clockwise.\nThis convention of blade placement will also produce element   orientations with tangential vectors along the trailing edge of a   cross section and normal vectors outward from the machine center.","category":"page"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"[]{#_bookmark15 .anchor}Strut componentThe strut components (which can provide a structural component between the tower and blade connection) are positioned using the following input parameters:","category":"page"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"Fraction of tower span for strut placement\nFraction of blade span for strut placement","category":"page"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"VAWTGen will automatically determine the strut length and insert the component based off of these two parameters. VAWTGen inserts a straight strut with the discretization described in the .dat file for the strut. Any PrecrvRef or PreswpRef specified in this file is ignored.VAWTGen will also insert nodes as needed to provide connections between the structural components.","category":"page"},{"location":"VAWTGenUserGuide/#VAWTGen-Input-File","page":"Legacy VAWTGen Guide","title":"VAWTGen Input File","text":"","category":"section"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"As mentioned before, the structural component (tower, blade, and struts) are described by the NREL file formats [1] and will not be discussed here. The main input file for VAWTGen is described below. This example input file is for a three bladed VAWT with struts, but without swept blades. The commented input file shown below is sufficient for explanation and will not be discussed further.","category":"page"},{"location":"VAWTGenUserGuide/#VAWTGen-Command-Line-Execution","page":"Legacy VAWTGen Guide","title":"VAWTGen Command Line Execution","text":"","category":"section"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"VAWTGen is written using the MATLAB programming language. The VAWTGen source code directory should be added to the MATLAB path, and VAWTGen should be executed from a job directory containing the component data files (.dat and .ipt NREL formats), and the VAWTGen input file described in the following section. The command line input should be executed in the MATLAB command window as:vawtGen(inputFile,outputFileRootName,renderBool,zeroTolerance);For example:vawtGen('snl34m.in','snl34m',true,1.0e-5);Results in execution with \"snl34m.in\" as the main VAWTGen input file. Resulting output files would have the root \"snl34m\", such as \"snl34m.mesh\", \"snl34m.el\", etc. The renderBool produces a rendered surface plot of the turbine if set to true, and no rendered view if set to \"false\". The zeroTolerance variable specifies a tolerance to be considered numerical zero when searching for coincident points in the configuration for identifying locations where joints are to be specified. If excluded from the command line input a default value of 1.0e-6 is used.Command line output from VAWTGen consists of a set of minimum element length ratios to the length of the actual structural component. This allows the user to ensure that element lengths are not too small to cause problems with the structural dynamics simulation. The located joints in the model are also displayed with information of the master and slave node numbers and component types.A variety of examples are available in the \"sampleJobs\" directory distributed with VAWTGen. They may be executed by adding the VAWTGen directory to the MATLAB path and running the \"generateMesh.m\" scripts in the example job directory.A sample command line output is shown below:","category":"page"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"+––––+––––––––+––––––––––––––––––––––+ | > \\>\\> |                |                                            | | > vawt |                |                                            | | Gen(\\' |                |                                            | | ideal3 |                |                                            | | 4m.in\\ |                |                                            | | ',\\'id |                |                                            | | eal34m |                |                                            | | \\',0); |                |                                            | | >      |                |                                            | | > *   |                |                                            | | *** |                |                                            | | *** |                |                                            | | *** |                |                                            | | *** |                |                                            | | *** |                |                                            | | *** |                |                                            | | *** |                |                                            | | *** |                |                                            | | *** |                |                                            | | *** |                |                                            | | *** |                |                                            | | *** |                |                                            | | *** |                |                                            | | *** |                |                                            | | *** |                |                                            | | *** |                |                                            | | *** |                |                                            | | *** |                |                                            | | *** |                |                                            | | *** |                |                                            | | *** |                |                                            | | *** |                |                                            | | *** |                |                                            | |        |                |                                            | | -      |                |                                            | |    SNL |                |                                            | |     V  |                |                                            | | AWTGen |                |                                            | |        |                |                                            | |   V1.0 |                |                                            | |     * |                |                                            | |        |                |                                            | | -      |                |                                            | |    Dev |                |                                            | | eloped |                |                                            | |     by |                |                                            | |        |                |                                            | | Sandia |                |                                            | |     Na |                |                                            | | tional |                |                                            | |        |                |                                            | | Labora |                |                                            | | tories |                |                                            | |        |                |                                            | |   Wind |                |                                            | |        |                |                                            | | Energy |                |                                            | |        |                |                                            | | Techno |                |                                            | | logies |                |                                            | |     * |                |                                            | |        |                |                                            | | -      |                |                                            | |    See |                |                                            | |        |                |                                            | |  licen |                |                                            | | se.txt |                |                                            | |        |                |                                            | |    for |                |                                            | |        |                |                                            | |   disc |                |                                            | | laimer |                |                                            | |        |                |                                            | |  infor |                |                                            | | mation |                |                                            | |     * |                |                                            | |        |                |                                            | | > *   |                |                                            | | *** |                |                                            | | *** |                |                                            | | *** |                |                                            | | *** |                |                                            | | *** |                |                                            | | *** |                |                                            | | *** |                |                                            | | *** |                |                                            | | *** |                |                                            | | *** |                |                                            | | *** |                |                                            | | *** |                |                                            | | *** |                |                                            | | *** |                |                                            | | *** |                |                                            | | *** |                |                                            | | *** |                |                                            | | *** |                |                                            | | *** |                |                                            | | *** |                |                                            | | *** |                |                                            | | *** |                |                                            | | *** |                |                                            | | > Zero |                |                                            | | > tol  |                |                                            | | erance |                |                                            | | > set  |                |                                            | | > to   |                |                                            | | > d    |                |                                            | | efault |                |                                            | | > of   |                |                                            | | >      |                |                                            | | 1.0e-6 |                |                                            | | >      |                |                                            | | > M    |                |                                            | | inimum |                |                                            | | > e    |                |                                            | | lement |                |                                            | | > to   |                |                                            | | > com  |                |                                            | | ponent |                |                                            | | >      |                |                                            | | length |                |                                            | | > r    |                |                                            | | atios: |                |                                            | | > Com  |                |                                            | | ponent |                |                                            | | > 1 :  |                |                                            | | > 0.   |                |                                            | | 050000 |                |                                            | | >      |                |                                            | | > Com  |                |                                            | | ponent |                |                                            | | > 2 :  |                |                                            | | > 0.   |                |                                            | | 050000 |                |                                            | | >      |                |                                            | | > Com  |                |                                            | | ponent |                |                                            | | > 3 :  |                |                                            | | > 0.   |                |                                            | | 050000 |                |                                            | | >      |                |                                            | | > 4    |                |                                            | | >      |                |                                            | | Joints |                |                                            | | > lo   |                |                                            | | cated: |                |                                            | +========+================+============================================+ | >      | > Master -     | > Component Type T Component Type B        | |  Joint | > Node #1,     |                                            | | > 1:   | > Slave - Node |                                            | |        | > #22,         |                                            | +––––+––––––––+––––––––––––––––––––––+ | >      | > Master -     | > Component Type T Component Type B        | |  Joint | > Node #1,     |                                            | | > 2:   | > Slave - Node |                                            | |        | > #43,         |                                            | +––––+––––––––+––––––––––––––––––––––+ | >      | > Master -     | > Component Type T Component Type B        | |  Joint | > Node #21,    |                                            | | > 3:   | > Slave - Node |                                            | |        | > #42,         |                                            | +––––+––––––––+––––––––––––––––––––––+ | >      | > Master -     | > Component Type T Component Type B        | |  Joint | > Node #21,    |                                            | | > 4:   | > Slave - Node |                                            | |        | > #63,         |                                            | +––––+––––––––+––––––––––––––––––––––+","category":"page"},{"location":"VAWTGenUserGuide/#VAWTGen-Graphical-Output","page":"Legacy VAWTGen Guide","title":"VAWTGen Graphical Output","text":"","category":"section"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"VAWTGen has various graphical outputs after creating a mesh of a VAWT configuration. First, a wire- frame visualization (and surface rendering if requested) is created to allow the user to visually inspect the turbine was constructed as intended. These are shown in Figure 3 through Figure 6. The finite element mesh with node numbering is also visualized as shown in Figure 7. Figure 8 shows the element orientations e~1~ is the local axial direction of an element, e~2~ is the local edgewise direction of an element, and e~3~ is the local flapwise direction of an element.Finite Element MeshElement Orientation Visualization(Image: ){width=\"2.202673884514436in\" height=\"2.950511811023622in\"}(Image: ){width=\"2.1219225721784776in\" height=\"2.6937674978127735in\"}403530252015","category":"page"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"10","category":"page"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"5","category":"page"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"0","category":"page"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"1 0-1","category":"page"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"-15","category":"page"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"15","category":"page"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"1050-5-10x[]{#_bookmark19 .anchor}Figure 7. Finite element mesh with node numbering Figure 8. Finite element mesh with element orientationsVisualization of OWENS Output using VAWTGenA number of visualization options exist in VAWTGen for results obtained with the OWENS analysis tool. This section discusses the available options for modal and transient analysis results. These function are located in the \"vizFiles\" directory of the VAWTGen distribution.Visualization of Static Analysis ResultsThe MATLAB function staticPlotter.m will visualize the deformed mesh from a static analysis. This visualization option shows multiple views of the turbine, with the undeformed mesh, and deformed mesh overlaying. The undeformed mesh is plotted in black, and the deformed mesh is plotted in red. The viz function is executed with the following command line call:staticPlotter(meshFile,resultsFile,scaleFactor);Such that meshFile is the mesh filename (.mesh), resultsFile is the OWENS output file from static analysis (_static.mat), and scaleFactor scales the deformed mesh.Visualization of Modal Analysis ResultsThe MATLAB function viz.m will visualize the mode shapes for a particular mode. This visualization option shows multiple views of the turbine, with the undeformed mesh, 0 degree mode shape, and 90 degree mode shape overlaying. The undeformed mesh is plotted in black, 0 degree mode shape in red, and 90 degree mode shape in blue. The viz function is executed with the following command line call:viz(meshFile,resultsFile,selectedMode,scaleFactor);Such that meshFile is the mesh filename (.mesh), resultsFile is the OWENS output file from modal analysis (.out), selectedMode is an integer mode number, and scaleFactor scales the mode shape deformation.An example of an actual viz function execution is: viz(\\'snl34m.mesh\\',\\'snl34m.out\\',2,3) The resulting plot is shown in Figure 9 below:[]{#bookmark21 .anchor}![C:\\Users\\bcowens\\Desktop\\exportfig\\modefirstas.png](figs/VAWTGenUserGuide/image12.png){width=\"2.5578937007874014in\" height=\"2.013333333333333in\"}[]{#_bookmark20 .anchor}Figure 9 Mode shape visualization using viz.mA similar capability exists for generating animated mode shapes. The vizAnimateModal function is utilized in the following manner:vizAnimateModal(meshFile,resultsFile,selectedMode,sf,dataOutputFilename);All the input parameters are the same as those for viz, however, the last parameter specifies a file name for a AVI movie file.Visualization of Transient Analysis ResultsA visualization option of transient results as an animation of the motion history of the turbine structure is accomplished via the vizAnimateTransient function. The command line argument is executed as:vizAnimateTransient(meshFile,uData,sf,dataOutputFilename);Such that mesh file is the mesh filename (.mesh), uData is an n x m array holding displacement data for n degrees of freedom at m time steps, and sf is the deformation scale factor for the structural mesh. The AVI movie file is generated using dataOutputFilename.","category":"page"},{"location":"VAWTGenUserGuide/#VAWTGen-Output-Files","page":"Legacy VAWTGen Guide","title":"VAWTGen Output Files","text":"","category":"section"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"The following output files are generated to serve as input for the OWENS analysis tool:","category":"page"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"OWENS main input file (.owens)\nBeam mesh file (.mesh)\nElement property file (.el)\nElement orientation file (.ort)\nJoint file (.jnt)\nBoundary conditions file (.bc)\nBlade data file (.bld)","category":"page"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"Additionally, a log file describing the junctions of various structural components is generated in a .out output file.","category":"page"},{"location":"VAWTGenUserGuide/#OWENS-Main-Input-File-(.owens)","page":"Legacy VAWTGen Guide","title":"OWENS Main Input File (.owens)","text":"","category":"section"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"The OWENS main input file is generated with the following format:Here, the root file name of \"vawt\" was specified at the command line input for VAWTGen. Command line usage will be discussed in a later section. The associated mesh, element, orientation, joint, and boundary conditions file are listed. The bracketed file comments serve as place holders and are not essential for all OWENS analysis types. These file types will be discussed separately in the OWENS analysis tool user guide. Lines 7 , 9, and 10 contain certain flags that are used by the OWENS software. The two doubles on the 12^th^ line are damping parameters for Rayleigh damping. These are discussed in the OWENS user guide[1].","category":"page"},{"location":"VAWTGenUserGuide/#Mesh-File-(.mesh)","page":"Legacy VAWTGen Guide","title":"Mesh File (.mesh)","text":"","category":"section"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"The mesh file generated by VAWTGen simply lists nodal coordinates and element connectivity. The number of structural components (tower, blades, and struts) and number of elements per component are also listed in this file. The file format is described below:","category":"page"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"+––––-+–––––+–––-+–––––––-+–––––––––––-+ | > n     | > num    | > y   | > zCoord      |                       | | umNodes | Elements | Coord |               |                       | | >       | >        |       |               |                       | | >       | > xCoord |       |               |                       | | nodeNum |          |       |               |                       | +=========+==========+=======+===============+=======================+ | >       | > xCoord | > y   | > zCoord      |                       | | nodeNum |          | Coord |               |                       | +––––-+–––––+–––-+–––––––-+–––––––––––-+ | >       | > xCoord | > y   | > zCoord      |                       | | nodeNum |          | Coord |               |                       | | >       |          |       |               |                       | | > ...  |          |       |               |                       | +––––-+–––––+–––-+–––––––-+–––––––––––-+ | > ele   | > nu     |       | >             | > localNodeNum2       | | mentNum | mNodesPe |       | localNodeNum1 |                       | |         | rElement |       |               |                       | +––––-+–––––+–––-+–––––––-+–––––––––––-+ | > ele   | > nu     |       | >             | > localNodeNum2       | | mentNum | mNodesPe |       | localNodeNum1 |                       | |         | rElement |       |               |                       | +––––-+–––––+–––-+–––––––-+–––––––––––-+ | > ele   | > nu     |       | >             | > localNodeNum2       | | mentNum | mNodesPe |       | localNodeNum1 |                       | | >       | rElement |       |               |                       | | > ...  |          |       |               |                       | +––––-+–––––+–––-+–––––––-+–––––––––––-+","category":"page"},{"location":"VAWTGenUserGuide/#Element-Property-File-(.el)","page":"Legacy VAWTGen Guide","title":"Element Property File (.el)","text":"","category":"section"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"The element property file generated by VAWTGen contains element mechanical and some aerodynamic properties. The properties specified in this file are those defined in the NREL file formats [1], but sorted into a form that is more usable by the OWENS analysis tool. The file has the following format:","category":"page"},{"location":"VAWTGenUserGuide/#Element-Orientation-File-(.ort)","page":"Legacy VAWTGen Guide","title":"Element Orientation File (.ort)","text":"","category":"section"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"The element orientation file generated by VAWTGen lists Euler angles for a 3-2 rotation sequence and some other miscellaneous element information. The file format is described below:Such that elNum is the element number. Theta3, theta2, and theta1 are the orientation angles (degrees) about a 3, 2, and 1 axes respectively for a 3-2-1 Euler rotation sequence. Length is the element length, and x/y/zOffsets are the offsets of the first node of the element from the coordinate frame origin.","category":"page"},{"location":"VAWTGenUserGuide/#Joint-File-(.jnt)","page":"Legacy VAWTGen Guide","title":"Joint File (.jnt)","text":"","category":"section"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"The joint file generated by VAWTgen specifies joint conditions at coincident nodes between structural components. The file format for the joint file is shown below:A master and slave node is defined at a joint from which constraints will be developed. The joint type is also specified (0 = weld(fixed), 1=pinned, 2 = hinge joint with axis about slave node element's e~2~ axis, 3 = hinge joint axis about slave node element's e~1~ axis, 4 = hinge joint axis about slave node element's e~3~ axis). The mass of the joint may be specified in this file. If this option is not sufficient for modeling purposes concentrated mass can be imposed on degrees of freedom using the .ndl file. A place-holder double of zero after jointMass is also in this file, but not currently used in analysis. The orientation associated with the joint is also described by the jointPsi and jointTheta angles (degrees). These angles are used to transform from the global coordinate frame to the local element/joint frame via a 3-2 Euler rotation sequence. Psi denotes rotation about 3, theta denotes rotation about 2.","category":"page"},{"location":"VAWTGenUserGuide/#Boundary-Conditions-File-(.bc)","page":"Legacy VAWTGen Guide","title":"Boundary Conditions File (.bc)","text":"","category":"section"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"The boundary conditions file generated by VAWTGen specifies a fixed boundary condition at the tower base (node 1). This file specifies the number of boundary conditions, the node number, local degree of freedom, and specified displacement value for the boundary condition. This file attempts to provide a likely boundary condition for a VAWT structure, but may need to be modified by the analyst depending on the specific configuration of interest. The boundary condition file generated by VAWTGen is shown below:","category":"page"},{"location":"VAWTGenUserGuide/#Blade-Data-File-(.bld)","page":"Legacy VAWTGen Guide","title":"Blade Data File (.bld)","text":"","category":"section"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"A blade data file is generated by VAWTGen to aid in mapping aerodynamic loads to the structural mesh generated by VAWTGen. This information includes the blade number, node locations of blade sections in terms of spanwise distance from the blade root, and node number and element numbers associated with these locations. The file also contains the quarter chord coordinate of the blade section, the normal and tangential vector components of the blade section, and the chord of the section. Coordinate and vector components are represented in the rotating, rotor-fixed hub frame. An integer number representing the airfoil as specified in the .ipt file for the blade component and section lift curve slope are also specified. The last column is a place holder not used in the release version of OWENS. The file format for the blade file is described below:","category":"page"},{"location":"VAWTGenUserGuide/#Output-File-(.out)","page":"Legacy VAWTGen Guide","title":"Output File (.out)","text":"","category":"section"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"This file describes the various component junctions in the generated turbine model. An example of the file is shown below. \"T\", \"B\", and \"S\" denote tower, blade, and strut components. \"T/B\" denotes a tower blade junction. The component numbers present at this junction are also output for more detail. By default, the tower component is labeled as component 1. Blade components are considered next in a counter clockwise azimuthal direction with the first blade located at 180 degrees azimuth from the x- axis. Struts are numbered last, per blade in a clockwise manner.","category":"page"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"+–-+–––-+––+–––––––––––––––––––––––––-+ | T | > jun | >  | > (1-2)                                           | | / | ction |  f |                                                   | | B |       | ou |                                                   | |   |       | nd |                                                   | +===+=======+====+===================================================+ | T | > jun | >  | > (1-2)                                           | | / | ction |  f |                                                   | | B |       | ou |                                                   | |   |       | nd |                                                   | +–-+–––-+––+–––––––––––––––––––––––––-+ | T | > jun | >  | > (1-3)                                           | | / | ction |  f |                                                   | | B |       | ou |                                                   | |   |       | nd |                                                   | +–-+–––-+––+–––––––––––––––––––––––––-+ | T | > jun | >  | > (1-3)                                           | | / | ction |  f |                                                   | | B |       | ou |                                                   | |   |       | nd |                                                   | +–-+–––-+––+–––––––––––––––––––––––––-+ | T | > jun | >  | > (1-4)                                           | | / | ction |  f |                                                   | | S |       | ou |                                                   | |   |       | nd |                                                   | +–-+–––-+––+–––––––––––––––––––––––––-+ | T | > jun | >  | > (1-5)                                           | | / | ction |  f |                                                   | | S |       | ou |                                                   | |   |       | nd |                                                   | +–-+–––-+––+–––––––––––––––––––––––––-+ | T | > jun | >  | > (1-6)                                           | | / | ction |  f |                                                   | | S |       | ou |                                                   | |   |       | nd |                                                   | +–-+–––-+––+–––––––––––––––––––––––––-+ | T | > jun | >  | > (1-7)                                           | | / | ction |  f |                                                   | | S |       | ou |                                                   | |   |       | nd |                                                   | +–-+–––-+––+–––––––––––––––––––––––––-+ | B | > jun | >  | > (2-1)                                           | | / | ction |  f |                                                   | | T |       | ou |                                                   | |   |       | nd |                                                   | +–-+–––-+––+–––––––––––––––––––––––––-+ | B | > jun | >  | > (2-1)                                           | | / | ction |  f |                                                   | | T |       | ou |                                                   | |   |       | nd |                                                   | +–-+–––-+––+–––––––––––––––––––––––––-+ | B | > jun | >  | > (2-3)                                           | | / | ction |  f |                                                   | | B |       | ou |                                                   | |   |       | nd |                                                   | +–-+–––-+––+–––––––––––––––––––––––––-+ | \\ |       |    |                                                   | | . |       |    |                                                   | | . |       |    |                                                   | | . |       |    |                                                   | +–-+–––-+––+–––––––––––––––––––––––––-+","category":"page"},{"location":"VAWTGenUserGuide/#Future-Versions","page":"Legacy VAWTGen Guide","title":"Future Versions","text":"","category":"section"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"There are no planned future developments for VAWTGen. Future developments or modifications will be considered as analysis needs arise.","category":"page"},{"location":"VAWTGenUserGuide/#References","page":"Legacy VAWTGen Guide","title":"References","text":"","category":"section"},{"location":"VAWTGenUserGuide/","page":"Legacy VAWTGen Guide","title":"Legacy VAWTGen Guide","text":"OWENS User Guide\nJonkman, J.M., and Buhl, M. L., 2005, FAST User's Guide, National  Renewable Energy Laboratory, NREL/EL- 500-38230.","category":"page"},{"location":"examples/A_simplyRunningOWENS/#simple1","page":"Simply Running OWENS","title":"Simply Running OWENS","text":"","category":"section"},{"location":"examples/A_simplyRunningOWENS/","page":"Simply Running OWENS","title":"Simply Running OWENS","text":"In this example, we show the first level of what is going on behind the precompiled binary Running julia directly with this as a starting point could make things like automating many runs in a way that is not compatible with the current interface, but your design design fits.","category":"page"},{"location":"examples/A_simplyRunningOWENS/","page":"Simply Running OWENS","title":"Simply Running OWENS","text":"OWENS is comprised of many building blocks.  These series of examples progressively shows the internals of several of the key building blocks a new user might employ for their projects.  Fundamentally, OWENS has been built to be as generalizable as possible. The lowest level of building blocks enable this, however, there are many common use cases for which helper functions have been developed, such as for meshing certain standard architectures and calculating and applying sectional properties to these architectures. The figure below summarizes this at a high level.","category":"page"},{"location":"examples/A_simplyRunningOWENS/","page":"Simply Running OWENS","title":"Simply Running OWENS","text":"(Image: )","category":"page"},{"location":"examples/A_simplyRunningOWENS/","page":"Simply Running OWENS","title":"Simply Running OWENS","text":"tip: Tip\nThis example is also available as a Jupyter notebook: A_simplyRunningOWENS.ipynb.","category":"page"},{"location":"examples/A_simplyRunningOWENS/","page":"Simply Running OWENS","title":"Simply Running OWENS","text":"import OWENS\n\nrunpath = path = \"/home/runner/work/OWENS.jl/OWENS.jl/examples/literate\" # to run locally, change to splitdir(@__FILE__)[1]\n# runpath = path = splitdir(@__FILE__)[1]\n\nmodelopt = OWENS.ModelingOptions(\"$(path)/OWENS_Opt.yml\")\ndesignparams = OWENS.Design_Data(\"$path/WINDIO_example.yaml\")\n\nOWENS.runOWENSWINDIO(modelopt,designparams,runpath)","category":"page"},{"location":"examples/A_simplyRunningOWENS/","page":"Simply Running OWENS","title":"Simply Running OWENS","text":"Here is an example of using the same model against the automated DLC run script. TODO: issue with CI version of turbsim Note that for a setup cutom to a specific design, you'll want to go to the B level to get all of the detailed inputs correct One of these is the controller where a discon controller library can be coupled instead of the specified RPM control.","category":"page"},{"location":"examples/A_simplyRunningOWENS/","page":"Simply Running OWENS","title":"Simply Running OWENS","text":"modelopt.DLCOptions.DLCs = [\"11\"] #\"normal\"","category":"page"},{"location":"examples/A_simplyRunningOWENS/#modelopt.DLC*Options.DLCs-[\"1*3\",\"6_1\"]-#\"normal\"","page":"Simply Running OWENS","title":"modelopt.DLCOptions.DLCs = [\"13\",\"6_1\"] #\"normal\"","text":"","category":"section"},{"location":"examples/A_simplyRunningOWENS/","page":"Simply Running OWENS","title":"Simply Running OWENS","text":"OWENS.runDLC(modelopt,designparams,runpath)","category":"page"},{"location":"examples/A_simplyRunningOWENS/","page":"Simply Running OWENS","title":"Simply Running OWENS","text":"nothing","category":"page"},{"location":"examples/A_simplyRunningOWENS/","page":"Simply Running OWENS","title":"Simply Running OWENS","text":"","category":"page"},{"location":"examples/A_simplyRunningOWENS/","page":"Simply Running OWENS","title":"Simply Running OWENS","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/E_RM2_Medium/#RM2","page":"Marine Hydrokinetic RM2","title":"Marine Hydrokinetic RM2","text":"","category":"section"},{"location":"examples/E_RM2_Medium/","page":"Marine Hydrokinetic RM2","title":"Marine Hydrokinetic RM2","text":"In this example we use the OWENS scripting method to model the RM2 turbine, based on “Experimental Study of a Reference Model Vertical-Axis Cross-Flow Turbine”, 2016, Bachant et al. While the windio modeling option based on input yaml files is also included in the OWENS.jl/examples directory, The scripting method enable much more flexibility and the ability to add detailed comments on the setup and use. Note that the documentation contains an API reference for nearly all of the functions where more details can be found also accessed via the julia REPL by loading the module of interest, and: ? ModuleName.functionname()","category":"page"},{"location":"examples/E_RM2_Medium/","page":"Marine Hydrokinetic RM2","title":"Marine Hydrokinetic RM2","text":"(Image: )","category":"page"},{"location":"examples/E_RM2_Medium/","page":"Marine Hydrokinetic RM2","title":"Marine Hydrokinetic RM2","text":"tip: Tip\nThis example is also available as a Jupyter notebook: E_RM2_Medium.ipynb.","category":"page"},{"location":"examples/E_RM2_Medium/","page":"Marine Hydrokinetic RM2","title":"Marine Hydrokinetic RM2","text":"Load in all of the modules that we'll be using, and prettify the plotting options","category":"page"},{"location":"examples/E_RM2_Medium/","page":"Marine Hydrokinetic RM2","title":"Marine Hydrokinetic RM2","text":"import OWENS\nimport OWENSAero\nimport DelimitedFiles\nusing Statistics:mean\nusing Test\nimport FLOWMath\nimport HDF5","category":"page"},{"location":"examples/E_RM2_Medium/","page":"Marine Hydrokinetic RM2","title":"Marine Hydrokinetic RM2","text":"import PyPlot PyPlot.pygui(true) PyPlot.rc(\"figure\", figsize=(4.5, 3)) PyPlot.rc(\"font\", size=10.0) PyPlot.rc(\"lines\", linewidth=1.5) PyPlot.rc(\"lines\", markersize=3.0) PyPlot.rc(\"legend\", frameon=false) PyPlot.rc(\"axes.spines\", right=false, top=false) PyPlot.rc(\"figure.subplot\", left=.18, bottom=.17, top=0.9, right=.9) PyPlot.rc(\"figure\",maxopenwarning=500) plot_cycle=[\"#348ABD\", \"#A60628\", \"#009E73\", \"#7A68A6\", \"#D55E00\", \"#CC79A7\"]","category":"page"},{"location":"examples/E_RM2_Medium/","page":"Marine Hydrokinetic RM2","title":"Marine Hydrokinetic RM2","text":"# path = runpath = splitdir(@__FILE__)[1]\nrunpath = path = \"/home/runner/work/OWENS.jl/OWENS.jl/examples/literate\" # to run locally, change to splitdir(@__FILE__)[1]\n\nnothing","category":"page"},{"location":"examples/E_RM2_Medium/","page":"Marine Hydrokinetic RM2","title":"Marine Hydrokinetic RM2","text":"Here we set the parametric inputs to the preprocessing and run methods.  Defaults are used otherwise Note that for the OpenFAST coupling, such as adi_lib, setting these to nothing will force the program to use the precompiled binaries that are part of the OWENS installation. Again, please refer the to API reference for more detailed options of inputs, but of note is that we are running with AeroModel = \"AD\" which will automatically generate all of the AeroDyn files necessary to run the structural definition generated here.  Also note that this scripting method relys on the NuMAD formatted CSV files for the composite layup that gets run through PreComp.jl to calculate the sectional properties. Finally, this has been shortened to enable automated deployment, update as desired.","category":"page"},{"location":"examples/E_RM2_Medium/","page":"Marine Hydrokinetic RM2","title":"Marine Hydrokinetic RM2","text":"turbineType = \"H-VAWT\" # turbine type, for the automatic meshing\nVinf = 1.2 # inflow velocity\nTSRrange = [3.5]#LinRange(1.0,5.0,2) range of tip speed ratios\nNslices = 20 # vertical discretizations if DMS or AC aero model\nntheta = 30 # azimuthal discretizations if DMS or AC aero model\nstructuralModel = \"TNB\"\nntelem = 100 # tower elements\nnbelem = 30 # blade elements\nnselem = 10 # strut elements\nifw = false # use inflow wind, if DMS or AC aero model\nnumTS = 21#321 # number of simulation time steps\ndelta_t = 0.01 # simulation time step spacing\nadi_lib = nothing#\"$path/../../../../openfast/build/modules/aerodyn/libaerodyn_inflow_c_binding\"\nadi_rootname = \"$path/RM2\" # path and name that all the aerodyn files are saved with\nVTKsaveName = \"$path/vtk/RM2_medium\" # path and name that all OWENS VTK files are saved with\ntsave_idx = 1:1:numTS-1 #you don't have to save every timestep in VTK\nifw_libfile = nothing#\"$path/../../../openfast/build/modules/inflowwind/libifw_c_binding\"\nfluid_density = 1000.0\nfluid_dyn_viscosity = 1.792E-3\nAddedMass_Coeff_Ca = 1.0 #For structural side added mass\nAero_Buoyancy_Active = true # For buoyancy forcing, handled by the OWENSAero module\nAeroModel = \"DMS\"\nverbosity = 1 # verbosity level where higher is more\nif AeroModel==\"AD\"\n    AD15On = true\nelse\n    AD15On = false\nend\n\neta = 0.5 # blade-strut mount point ratio, fraction from leading edge\nnumber_of_blades = 3 # number of blades\ntowerHeight = 0.2165 # height of the tower past the blades\nBlade_Height = 0.807 # height of the blades\nBlade_Radius = 0.5375 # radius of the turbine\n\nNuMad_geom_xlscsv_file_twr = \"$path/data_RM2/TowerGeom.csv\" #\nNuMad_mat_xlscsv_file_twr = \"$path/data_RM2/TowerMaterials.csv\"\nNuMad_geom_xlscsv_file_bld = \"$path/data_RM2/GeomBlades$AeroModel.csv\"\nNuMad_mat_xlscsv_file_bld = \"$path/data_RM2/materials_NuMAD.csv\"\nNuMad_geom_xlscsv_file_strut = \"$path/data_RM2/GeomStruts$AeroModel.csv\"\nNuMad_mat_xlscsv_file_strut = \"$path/data_RM2/materials_NuMAD.csv\"\n\nnothing","category":"page"},{"location":"examples/E_RM2_Medium/","page":"Marine Hydrokinetic RM2","title":"Marine Hydrokinetic RM2","text":"For this simulation, using aerodyn (\"AD\"), we will use a turbulent inflow file, indicated as WindType 3 We can let the built in OWENS library for turbsim generate the file as so. Modify the inp file to your liking and comment out the run command to run your own with more time","category":"page"},{"location":"examples/E_RM2_Medium/","page":"Marine Hydrokinetic RM2","title":"Marine Hydrokinetic RM2","text":"WindType = 1\nwindINPfilename = \"$path/data_RM2/3mx3m1pt2msNTM.bts\"","category":"page"},{"location":"examples/E_RM2_Medium/","page":"Marine Hydrokinetic RM2","title":"Marine Hydrokinetic RM2","text":"windINPfilename = \"pathdata_RM2steady1pt2inp run((OWENS.OWENSOpenFASTWrappers.turbsim()) windINPfilename[1:end - 3]inp`)","category":"page"},{"location":"examples/E_RM2_Medium/","page":"Marine Hydrokinetic RM2","title":"Marine Hydrokinetic RM2","text":"nothing","category":"page"},{"location":"examples/E_RM2_Medium/","page":"Marine Hydrokinetic RM2","title":"Marine Hydrokinetic RM2","text":"Here we would set up to run multiple different inflow conditions, and we can allow the preprocessing to re-run each time since it only takes a few seconds. The for loop is commented out to enable this example to be parsed by the literate package that auto generates the docs.","category":"page"},{"location":"examples/E_RM2_Medium/","page":"Marine Hydrokinetic RM2","title":"Marine Hydrokinetic RM2","text":"CP = zeros(length(TSRrange))\nmymesh = []\nmyel = []\nsystem = []\nassembly = []\nsections = []\nmyjoint = []\npBC = []\n# for (iTSR,TSR) in enumerate(collect(TSRrange))\nTSR = TSRrange[1]\niTSR = 1\n    global Vinf\n    global mymesh\n    global myel\n    global system\n    global assembly\n    global sections\n    global myjoint\n    global pBC\n\n    omega = Vinf/Blade_Radius*TSR\n    RPM = omega * 60 / (2*pi)\n\n    println(RPM)\n\n    nothing","category":"page"},{"location":"examples/E_RM2_Medium/","page":"Marine Hydrokinetic RM2","title":"Marine Hydrokinetic RM2","text":"Here we run the OWENS preprocessing, which creates the beam mesh and joints, calculates the sectional properties maps the sectional properties to the elements.  It also sets up the aero module being used.","category":"page"},{"location":"examples/E_RM2_Medium/","page":"Marine Hydrokinetic RM2","title":"Marine Hydrokinetic RM2","text":"    shapeZ = collect(LinRange(0,Blade_Height,Nslices+1))\n    helix_angle = 0.0#-pi/4\n    shapeX = cos.(shapeZ/maximum(shapeZ)*helix_angle).*Blade_Radius\n    shapeY = sin.(shapeZ/maximum(shapeZ)*helix_angle).*Blade_Radius\n\n    mymesh,myel,myort,myjoint,sectionPropsArray,mass_twr, mass_bld,\n    stiff_twr, stiff_bld,bld_precompinput,\n    bld_precompoutput,plyprops_bld,numadIn_bld,lam_U_bld,lam_L_bld,\n    twr_precompinput,twr_precompoutput,plyprops_twr,numadIn_twr,lam_U_twr,lam_L_twr,aeroForces,deformAero,\n    mass_breakout_blds,mass_breakout_twr,system,assembly,sections,AD15bldNdIdxRng, AD15bldElIdxRng = OWENS.setupOWENS(OWENSAero,path;\n        rho=fluid_density,\n        mu=fluid_dyn_viscosity,\n        Nslices,\n        ntheta,\n        RPM,\n        Vinf,\n        eta,\n        B=number_of_blades,\n        H = Blade_Height,\n        R = Blade_Radius,\n        shapeZ,\n        shapeX,\n        shapeY,\n        ifw,\n        WindType,\n        delta_t,\n        numTS,\n        adi_lib,\n        adi_rootname,\n        windINPfilename,\n        ifw_libfile,\n        NuMad_geom_xlscsv_file_twr,\n        NuMad_mat_xlscsv_file_twr,\n        NuMad_geom_xlscsv_file_bld,\n        NuMad_mat_xlscsv_file_bld,\n        NuMad_geom_xlscsv_file_strut,\n        NuMad_mat_xlscsv_file_strut,\n        Htwr_base=towerHeight,\n        Htwr_blds = Blade_Height+towerHeight,\n        ntelem,\n        nbelem,\n        nselem,\n        joint_type = 0,\n        strut_twr_mountpoint = [0.5],\n        strut_bld_mountpoint = [0.5],\n        AeroModel, #AD, DMS, AC\n        DynamicStallModel=\"BV\",\n        Aero_AddedMass_Active = false,\n        Aero_RotAccel_Active = false,\n        AddedMass_Coeff_Ca,\n        Aero_Buoyancy_Active,\n        verbosity,\n        meshtype = turbineType)\n\n    nothing\n\n    # # PyPlot.figure()\n    # # for idot = 1:length(sectionPropsArray[170].xaf)\n    # #     PyPlot.scatter(sectionPropsArray[170].xaf[idot],sectionPropsArray[170].yaf[idot])\n    # #     sleep(0.001)\n    # # end\n    #\n    # ## This plots the mesh and node numbering of the resulting mesh and overlays the joint connections\n    #\n    # PyPlot.figure()\n    # for icon = 1:length(mymesh.conn[:,1])\n        # idx1 = mymesh.conn[icon,1]\n        # idx2 = mymesh.conn[icon,2]\n        # PyPlot.plot3D([mymesh.x[idx1],mymesh.x[idx2]],[mymesh.y[idx1],mymesh.y[idx2]],[mymesh.z[idx1],mymesh.z[idx2]],\"k.-\")\n        # PyPlot.plot3D([1,1],[1,1],[1,1],\"k.-\")\n        # PyPlot.text3D(mymesh.x[idx1].+rand()/30,mymesh.y[idx1].+rand()/30,mymesh.z[idx1].+rand()/30,\"$idx1\",ha=\"center\",va=\"center\")\n    # end\n    # for ijoint = 1:length(myjoint[:,1])\n        # idx2 = Int(myjoint[ijoint,2])\n        # idx1 = Int(myjoint[ijoint,3])\n        # PyPlot.plot3D([mymesh.x[idx1],mymesh.x[idx2]],[mymesh.y[idx1],mymesh.y[idx2]],[mymesh.z[idx1],mymesh.z[idx2]],\"r.-\")\n        # PyPlot.text3D(mymesh.x[idx1].+rand()/30,mymesh.y[idx1].+rand()/30,mymesh.z[idx1].+rand()/30,\"$idx1\",color=\"r\",ha=\"center\",va=\"center\")\n        # PyPlot.text3D(mymesh.x[idx2].+rand()/30,mymesh.y[idx2].+rand()/30,mymesh.z[idx2].+rand()/30,\"$idx2\",color=\"r\",ha=\"center\",va=\"center\")\n    # end\n    # PyPlot.xlabel(\"x\")\n    # PyPlot.ylabel(\"y\")\n    # PyPlot.zlabel(\"z\")\n    # PyPlot.axis(\"equal\")\n\n    nothing","category":"page"},{"location":"examples/E_RM2_Medium/","page":"Marine Hydrokinetic RM2","title":"Marine Hydrokinetic RM2","text":"Here we apply the boundary conditions.  For this case, the tower base node which is 1 is constrained in all 6 degrees of freedom to have a displacement of 0, and the tower top is also constrained. You can change this displacement to allow for things like pretension, and you can apply boundary conditions to any node.","category":"page"},{"location":"examples/E_RM2_Medium/","page":"Marine Hydrokinetic RM2","title":"Marine Hydrokinetic RM2","text":"    pBC = [1 1 0\n    1 2 0\n    1 3 0\n    1 4 0\n    1 5 0\n    1 6 0\n    AD15bldElIdxRng[1,2]-1 1 0\n    AD15bldElIdxRng[1,2]-1 2 0\n    AD15bldElIdxRng[1,2]-1 3 0\n    AD15bldElIdxRng[1,2]-1 4 0\n    AD15bldElIdxRng[1,2]-1 5 0]\n\n    nothing","category":"page"},{"location":"examples/E_RM2_Medium/","page":"Marine Hydrokinetic RM2","title":"Marine Hydrokinetic RM2","text":"There are inputs for the overall coupled simulation, please see the api reference for specifics on all the options: ? OWENS.Inputs()","category":"page"},{"location":"examples/E_RM2_Medium/","page":"Marine Hydrokinetic RM2","title":"Marine Hydrokinetic RM2","text":"    tocp = [0.0;10.0; 1e6]\n    Omegaocp = [RPM; RPM; RPM]./60 #control inputs\n\n    tocp_Vinf = [0.0;10.0; 1e6]\n    Vinfocp = [Vinf;Vinf;Vinf]\n\n    inputs = OWENS.Inputs(;verbosity,analysisType = structuralModel,\n    tocp,\n    dataOutputFilename = \"./InitialDataOutputs_scripting.out\",\n    Omegaocp,\n    tocp_Vinf,\n    Vinfocp,\n    numTS,\n    delta_t,\n    AD15On,\n    aeroLoadsOn = 2,\n    MAXITER = 20)\n\n    nothing","category":"page"},{"location":"examples/E_RM2_Medium/","page":"Marine Hydrokinetic RM2","title":"Marine Hydrokinetic RM2","text":"Then there are inputs for the finite element models, also, please see the api reference for specifics on the options","category":"page"},{"location":"examples/E_RM2_Medium/","page":"Marine Hydrokinetic RM2","title":"Marine Hydrokinetic RM2","text":"    FEAinputs = OWENS.FEAModel(;analysisType = structuralModel,\n    dataOutputFilename = \"./InitialDataOutputs_scripting.out\",\n    joint = myjoint,\n    platformTurbineConnectionNodeNumber = 1,\n    pBC,\n    nlOn = false,\n    numModes = 70,\n    gravityOn = [0,0,9.81], #positive since the turbine is upside down\n    numNodes = mymesh.numNodes,\n    RayleighAlpha = 0.005,\n    RayleighBeta = 0.005,\n    AddedMass_Coeff_Ca,\n    iterationType = \"DI\")\n\n    nothing","category":"page"},{"location":"examples/E_RM2_Medium/","page":"Marine Hydrokinetic RM2","title":"Marine Hydrokinetic RM2","text":"Here is where we actually call the unsteady simulation and where owens pulls the aero and structural solutions together and propogates things in time. Note that for the sake of quickly deployable docs, a shortened simulation is conducted and the CP will not be correct","category":"page"},{"location":"examples/E_RM2_Medium/","page":"Marine Hydrokinetic RM2","title":"Marine Hydrokinetic RM2","text":"    println(\"Running Unsteady\")\n    t, aziHist,OmegaHist,OmegaDotHist,gbHist,gbDotHist,gbDotDotHist,FReactionHist,\n    FTwrBsHist,genTorque,genPower,torqueDriveShaft,uHist,uHist_prp,epsilon_x_hist,epsilon_y_hist,\n    epsilon_z_hist,kappa_x_hist,kappa_y_hist,kappa_z_hist,FPtfmHist,FHydroHist,FMooringHist,\n    topFexternal_hist,rbDataHist = OWENS.Unsteady_Land(inputs;system,assembly,\n    topModel=FEAinputs,topMesh=mymesh,topEl=myel,aero=aeroForces,deformAero,turbsimfile = windINPfilename)\n\n    area = Blade_Height*2*Blade_Radius\n    full_rev_N_timesteps = round(Int,RPM/60/delta_t)*2\n    if full_rev_N_timesteps>numTS\n        idx_start = 1\n    else\n        idx_start = numTS-full_rev_N_timesteps\n    end\n    CP[iTSR] = mean(FReactionHist[idx_start:end,6].*OmegaHist[idx_start:end]*2*pi)/(0.5*fluid_density*mean(Vinfocp)^3*area)\n    TSR = mean(OmegaHist*2*pi*Blade_Radius/mean(Vinfocp))\n    ReD = fluid_density*mean(Vinfocp)*Blade_Radius*2/fluid_dyn_viscosity\n\n    nothing","category":"page"},{"location":"examples/E_RM2_Medium/","page":"Marine Hydrokinetic RM2","title":"Marine Hydrokinetic RM2","text":"We can output vtk files viewable in paraview.  Here it is done for each time step and shows the deformations.  Additionaly, there is a method to input custom values and have them show up on the vtk surface mesh for example, strain, or reaction force, etc.  This is described in more detail in the api reference for the function This helper function looks through all the loads and picks out the worst case safety factor in each of the stacks of composite lamina it also calculates analytical simply supported buckling safety factors","category":"page"},{"location":"examples/E_RM2_Medium/","page":"Marine Hydrokinetic RM2","title":"Marine Hydrokinetic RM2","text":"    ##########################################\n    #### Ultimate Failure #####\n    ##########################################\n\n    massOwens,stress_U,SF_ult_U,SF_buck_U,stress_L,SF_ult_L,SF_buck_L,stress_TU,SF_ult_TU,\n    SF_buck_TU,stress_TL,SF_ult_TL,SF_buck_TL,topstrainout_blade_U,topstrainout_blade_L,\n    topstrainout_tower_U,topstrainout_tower_L,topDamage_blade_U,\n    topDamage_blade_L,topDamage_tower_U,topDamage_tower_L = OWENS.extractSF(bld_precompinput,\n    bld_precompoutput,plyprops_bld,numadIn_bld,lam_U_bld,lam_L_bld,\n    twr_precompinput,twr_precompoutput,plyprops_twr,numadIn_twr,lam_U_twr,lam_L_twr,\n    mymesh,myel,myort,number_of_blades,epsilon_x_hist,kappa_y_hist,kappa_z_hist,epsilon_z_hist,\n    kappa_x_hist,epsilon_y_hist;verbosity, #Verbosity 0:no printing, 1: summary, 2: summary and spanwise worst safety factor\n    Twr_LE_U_idx=1,Twr_LE_L_idx=1,delta_t,\n    AD15bldNdIdxRng,AD15bldElIdxRng,strut_precompoutput=nothing)\n\n    OWENS.outputData(;mymesh,inputs,t,aziHist,OmegaHist,OmegaDotHist,gbHist,gbDotHist,gbDotDotHist,FReactionHist,genTorque,genPower,torqueDriveShaft,uHist,uHist_prp,epsilon_x_hist,epsilon_y_hist,epsilon_z_hist,kappa_x_hist,kappa_y_hist,kappa_z_hist,FTwrBsHist,massOwens,stress_U,SF_ult_U,SF_buck_U,stress_L,SF_ult_L,SF_buck_L,stress_TU,SF_ult_TU,SF_buck_TU,stress_TL,SF_ult_TL,SF_buck_TL,topstrainout_blade_U,topstrainout_blade_L,topstrainout_tower_U,topstrainout_tower_L,topDamage_blade_U,topDamage_blade_L,topDamage_tower_U,topDamage_tower_L)\n\n    # OWENS.OWENSVTK(VTKsaveName,t,uHist,system,assembly,sections,aziHist,mymesh,myel,\n    #     epsilon_x_hist,epsilon_y_hist,epsilon_z_hist,kappa_x_hist,kappa_y_hist,kappa_z_hist,\n    #     FReactionHist,topFexternal_hist;tsave_idx)\n\n\n# end\n\n# PyPlot.figure(\"CP2\")\n# PyPlot.plot(TSRrange,CP,\".-\",color=plot_cycle[2],label=\"OWENS Aero, 1.3 RE_d (No Added Mass)\") #,color=color_cycle[2]\n# RM2_0_538D_RE_D_1_3E6 = DelimitedFiles.readdlm(\"$(path)/data_RM2/RM2_0.538D_RE_D_1.3E6.csv\", ',',Float64)\n# PyPlot.plot(RM2_0_538D_RE_D_1_3E6[:,1],RM2_0_538D_RE_D_1_3E6[:,2],\"k-\",label=\"Exp. 1.3e6 RE_d\")\n# PyPlot.legend()\n# PyPlot.xlabel(\"TSR\")\n# PyPlot.ylabel(\"Cp\")\n\nQinst = -FReactionHist[idx_start:end,6]\nQinst2 = topFexternal_hist[idx_start:end,6]\n\ndrag = FReactionHist[idx_start:end,1] #./ (0.5*fluid_density*mean(Vinfocp)^2*area)\ndrag2 = topFexternal_hist[idx_start:end,1] #./ (0.5*fluid_density*mean(Vinfocp)^2*area)\n\ndat_strt = round(Int,160800/80*11.0)\ndat_end = round(Int,160800/80*14.0)\n\n# # Open the HDF5 file in read mode\n# carriage_pos = nothing\n# drag_left = nothing\n# drag_right = nothing\n# time = nothing\n# torque_arm = nothing\n# torque_trans = nothing\n# turbine_angle = nothing\n# # This data is located at https://figshare.com/articles/dataset/UNH_RM2_tow_tank_experiment_Raw_data/1302029, with the file matching that here\n# c = HDF5.h5open(\"$path/data_RM2/Perf1.2b_16_nidata.h5\", \"r\") do file\n#     global carriage_pos = read(file,\"data/carriage_pos\")\n#     global drag_left = read(file,\"data/drag_left\")\n#     global drag_right = read(file,\"data/drag_right\")\n#     global time = read(file,\"data/time\")\n#     global torque_arm = read(file,\"data/torque_arm\")\n#     global torque_trans = read(file,\"data/torque_trans\")\n#     global turbine_angle = read(file,\"data/turbine_angle\")\n# end\n\n\n\n# PyPlot.figure()\n# PyPlot.plot((t[idx_start:end].-t[idx_start]),Qinst,\".-\",color=plot_cycle[1],label=\"Reaction\") #,color=color_cycle[2]\n# # PyPlot.plot((t[idx_start:end].-t[idx_start]),-Qinst2,\"x-\",color=plot_cycle[2],label=\"Applied\") #,color=color_cycle[2]\n# PyPlot.plot(time[dat_strt:dat_end].-time[dat_strt],torque_trans[dat_strt:dat_end],\"k-\",label=\"Exp. \")\n# PyPlot.legend()\n# PyPlot.xlabel(\"Time (s)\")\n# PyPlot.ylabel(\"Q (instantaneous)\")\n#\n# PyPlot.figure()\n# # PyPlot.plot((t[idx_start:end].-t[idx_start]),drag,\".-\",color=plot_cycle[1],label=\"Reaction\") #,color=color_cycle[2]\n# PyPlot.plot((t[idx_start:end].-t[idx_start]),drag2,\"x-\",color=plot_cycle[2],label=\"Applied\") #,color=color_cycle[2]\n# PyPlot.plot(time[dat_strt:dat_end].-time[dat_strt],drag_left[dat_strt:dat_end],\"k-\",label=\"Exp. L\")\n# PyPlot.plot(time[dat_strt:dat_end].-time[dat_strt],drag_right[dat_strt:dat_end],\"k--\",label=\"Exp. R\")\n# PyPlot.legend()\n# PyPlot.xlabel(\"Time (s)\")\n# PyPlot.ylabel(\"Drag (instantaneous)\")\n\n# nothing\n\n# # Calculate mean Q and compare\n# mean_Q_owens = mean(Qinst)\n# mean_Q_exp = mean(torque_trans[dat_strt:dat_end])\n# println(\"Percent Difference in Torque: $((mean_Q_owens-mean_Q_exp)/mean_Q_exp*100)\")\n\n# dat_strt = round(Int,160800/80*10)\n# dat_end = round(Int,160800/80*10.5)\n# amp_Q_exp = maximum(torque_trans[dat_strt:dat_end])-minimum(torque_trans[dat_strt:dat_end])\n# amp_Q_owens = maximum(Qinst[end-round(Int,0.5/delta_t):end])-minimum(Qinst[end-round(Int,0.5/delta_t):end])\n# println(\"Percent Difference in Amplitude: $((amp_Q_owens-amp_Q_exp)/amp_Q_exp*100)\")","category":"page"},{"location":"examples/E_RM2_Medium/","page":"Marine Hydrokinetic RM2","title":"Marine Hydrokinetic RM2","text":"Here we use the automated campbell diagram function to run the modal analysis of the turbine and save the modeshapes to VTK","category":"page"},{"location":"examples/E_RM2_Medium/","page":"Marine Hydrokinetic RM2","title":"Marine Hydrokinetic RM2","text":"rotSpdArrayRPM = [0.0, 42.64]\n\nFEAinputs = OWENS.FEAModel(;analysisType = \"GX\",\ndataOutputFilename = \"none\",\njoint = myjoint,\nplatformTurbineConnectionNodeNumber = 1,\npBC,\nnlOn = false,\ngravityOn = [0,0,9.81], #positive since the turbine is upside down\nnumNodes = mymesh.numNodes,\nRayleighAlpha = 0.05,\nRayleighBeta = 0.05,\nAddedMass_Coeff_Ca,\niterationType = \"DI\")\n\nfreq2 = OWENS.AutoCampbellDiagram(FEAinputs,mymesh,myel,system,assembly,sections;\n    rotSpdArrayRPM,\n    VTKsavename=VTKsaveName,\n    saveModes = [1,3,5], #must be int\n    saveRPM = [2], #must be int\n    mode_scaling = 500.0,\n    )\nfreqGX = [freq2[:,i] for i=1:2:FEAinputs.numModes-6-2]\n\nnothing\n\n# Now the Campbell diagram can be generated\n# NperRevLines = 8\n# PyPlot.figure()\n# for i=1:NperRevLines\n#     linex=[rotSpdArrayRPM[1], rotSpdArrayRPM[end]+5]\n#     liney=[rotSpdArrayRPM[1], rotSpdArrayRPM[end]+5].*i./60.0\n#     PyPlot.plot(linex,liney,\"--k\",linewidth=0.5)\n#     PyPlot.annotate(\"$i P\",xy=(0.95*linex[2],liney[2]+.05+(i-1)*.01))\n# end\n# PyPlot.grid()\n# PyPlot.xlabel(\"Rotor Speed (RPM)\")\n# PyPlot.ylabel(\"Frequency (Hz)\")\n# PyPlot.plot(0,0,\"k-\",label=\"Experimental\")\n# PyPlot.plot(0,0,color=plot_cycle[1],\"-\",label=\"OWENS\")\n# PyPlot.legend()\n\n# for i=1:1:FEAinputs.numModes\n#        PyPlot.plot(rotSpdArrayRPM,freq2[:,i],color=plot_cycle[2],\"-\") #plot mode i at various rotor speeds\n# end\n# PyPlot.plot(0,0,color=plot_cycle[2],\"-\",label=\"GXBeam\")\n# PyPlot.legend(fontsize=8.5,loc = (0.09,0.8),ncol=2,handleheight=1.8, labelspacing=0.03)\n# PyPlot.ylim([0,40.0])\n\nnothing","category":"page"},{"location":"examples/E_RM2_Medium/","page":"Marine Hydrokinetic RM2","title":"Marine Hydrokinetic RM2","text":"","category":"page"},{"location":"examples/E_RM2_Medium/","page":"Marine Hydrokinetic RM2","title":"Marine Hydrokinetic RM2","text":"This page was generated using Literate.jl.","category":"page"},{"location":"getting_started/#nothing-yet","page":"nothing yet","title":"nothing yet","text":"","category":"section"},{"location":"examples/D_simulatingFloatingPlatforms/#simple4","page":"Simulating Floating Platforms","title":"Simulating Floating Platforms","text":"","category":"section"},{"location":"examples/D_simulatingFloatingPlatforms/","page":"Simulating Floating Platforms","title":"Simulating Floating Platforms","text":"In this example, we make the OWENS model more complex by simulation a floating wind turbine instead of a land-based one. This involves coupling two meshes together: one representing the wind turbine (this will be similar to meshes used in previous tutorials), and one representing the floating platform.","category":"page"},{"location":"examples/D_simulatingFloatingPlatforms/","page":"Simulating Floating Platforms","title":"Simulating Floating Platforms","text":"The wind turbine mesh (or \"topside\") will be created similarly to the previous tutorial, though we will overwrite some of the inputs so the simulation works better for a floating system. This will help with revealing some more internals of OWENS and the potential inputs available to users, which is helpful for explaining how the floating platform mesh (or \"bottom side\") is defined and differs from the topside.","category":"page"},{"location":"examples/D_simulatingFloatingPlatforms/","page":"Simulating Floating Platforms","title":"Simulating Floating Platforms","text":"tip: Tip\nThis example is also available as a Jupyter notebook: D_simulatingFloatingPlatforms.ipynb.","category":"page"},{"location":"examples/D_simulatingFloatingPlatforms/","page":"Simulating Floating Platforms","title":"Simulating Floating Platforms","text":"# import PyPlot\n\nimport OWENS\nimport OWENSFEA\nimport OWENSAero\n\nrunpath = path = \"/home/runner/work/OWENS.jl/OWENS.jl/examples/literate\"\n##runpath = path = splitdir(@__FILE__)[1] # use to run locally\n\nnothing","category":"page"},{"location":"examples/D_simulatingFloatingPlatforms/","page":"Simulating Floating Platforms","title":"Simulating Floating Platforms","text":"First, create the inputs for the topside mesh as done previous in tutorials A and B.","category":"page"},{"location":"examples/D_simulatingFloatingPlatforms/","page":"Simulating Floating Platforms","title":"Simulating Floating Platforms","text":"Inp = OWENS.MasterInput(\"$runpath/sampleOWENS.yml\")\n\nanalysisType = \"TNB\" # this differs from previous tutorials, as it has been verified to work well with floating capabilities\nturbineType = Inp.turbineType\neta = Inp.eta\nNbld = Inp.Nbld\ntowerHeight = Inp.towerHeight\nrho = Inp.rho\nVinf = Inp.Vinf\ncontrolStrategy = Inp.controlStrategy\nRPM = Inp.RPM\nNslices = Inp.Nslices\nntheta = Inp.ntheta\nstructuralModel = Inp.structuralModel\nntelem = Inp.ntelem\nnbelem = Inp.nbelem\nncelem = Inp.ncelem\nnselem = Inp.nselem\nifw = Inp.ifw\nWindType = Inp.WindType\nAeroModel = \"DMS\"#Inp.AeroModel\nwindINPfilename = \"$(path)$(Inp.windINPfilename)\"\nifw_libfile = Inp.ifw_libfile\nif ifw_libfile == \"nothing\"\n    ifw_libfile = nothing\nend\nBlade_Height = Inp.Blade_Height\nBlade_Radius = Inp.Blade_Radius\nnumTS = 5 # shortened since the floating simulation can take awhile\ndelta_t = Inp.delta_t\nNuMad_geom_xlscsv_file_twr = \"$(path)$(Inp.NuMad_geom_xlscsv_file_twr)\"\nNuMad_mat_xlscsv_file_twr = \"$(path)$(Inp.NuMad_mat_xlscsv_file_twr)\"\nNuMad_geom_xlscsv_file_bld = \"$(path)$(Inp.NuMad_geom_xlscsv_file_bld[1:end-4])DMS.csv\"\nNuMad_mat_xlscsv_file_bld = \"$(path)$(Inp.NuMad_mat_xlscsv_file_bld)\"\nNuMad_geom_xlscsv_file_strut = \"$(path)$(Inp.NuMad_geom_xlscsv_file_strut)\"\nNuMad_mat_xlscsv_file_strut = \"$(path)$(Inp.NuMad_mat_xlscsv_file_strut)\"\nadi_lib = Inp.adi_lib\nif adi_lib == \"nothing\"\n    adi_lib = nothing\nend\nadi_rootname = \"$(path)$(Inp.adi_rootname)\"\n\nB = Nbld\nR = Blade_Radius#177.2022*0.3048 #m\nH = Blade_Height#1.02*R*2 #m\n\nshapeZ = collect(LinRange(0,H,Nslices+1))\nshapeX = R.*(1.0.-4.0.*(shapeZ/H.-.5).^2)#shapeX_spline(shapeZ)\n\nnothing","category":"page"},{"location":"examples/D_simulatingFloatingPlatforms/","page":"Simulating Floating Platforms","title":"Simulating Floating Platforms","text":"We will continue to use helper functions here to fully define the topside mesh, sectional properties, and their connection. However, note that our naming convention will be different in order to differentiate this mesh from the bottom side mesh. The outputs to the helper functions not being used elsewhere in the tutorial are returned as \"_\" to improve clarity.","category":"page"},{"location":"examples/D_simulatingFloatingPlatforms/","page":"Simulating Floating Platforms","title":"Simulating Floating Platforms","text":"Note that, unlike the previous examples, we will not apply a boundary condition to this mesh. The boundary condition previously was essentially fixing the bottom of the turbine tower in place, since it is installed in the ground. However, for our floating platform, we want the loads from the topside to propagate to the platform, so our restoring hydrodynamics and mooring loads will \"constain\" the combined meshes as we want.","category":"page"},{"location":"examples/D_simulatingFloatingPlatforms/","page":"Simulating Floating Platforms","title":"Simulating Floating Platforms","text":"topMesh, topEl, topOrt, topJoint, topSectionProps,\n_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _,\naeroForces, deformAero, _, _,topSystem,topAssembly, sections, _, _ = OWENS.setupOWENS(OWENSAero,path;\n    rho, Nslices, ntheta, RPM, Vinf, eta, B, H, R, shapeZ, shapeX,\n    ifw, WindType, delta_t, numTS, adi_lib, adi_rootname, windINPfilename, ifw_libfile,\n    NuMad_geom_xlscsv_file_twr,# = \"$path/data/NuMAD_Geom_SNL_5MW_ARCUS_Cables.csv\",\n    NuMad_mat_xlscsv_file_twr,# = \"$path/data/NuMAD_Materials_SNL_5MW_D_TaperedTower.csv\",\n    NuMad_geom_xlscsv_file_bld,# = \"$path/data/NuMAD_Geom_SNL_5MW_ARCUS.csv\",\n    NuMad_mat_xlscsv_file_bld,# = \"$path/data/NuMAD_Materials_SNL_5MW_D_Carbon_LCDT_ThickFoils_ThinSkin.csv\",\n    NuMad_geom_xlscsv_file_strut,\n    NuMad_mat_xlscsv_file_strut,\n    Htwr_base=towerHeight,\n    ntelem,\n    nbelem,\n    ncelem,\n    nselem,\n    joint_type = 0,\n    c_mount_ratio = 0.05,\n    AeroModel, #AD, DMS, AC\n    DynamicStallModel=\"BV\",\n    RPI=true,\n    cables_connected_to_blade_base = true,\n    meshtype = turbineType)\n\nnothing","category":"page"},{"location":"examples/D_simulatingFloatingPlatforms/","page":"Simulating Floating Platforms","title":"Simulating Floating Platforms","text":"Now we need to define the properties of the bottom side mesh, which we will do manually here instead of reading in values from a YAML file. This mesh is very simple: it consists of a single element with a nodal connection on either end. OWENS assumes the platform is a rigid body, so the element has very high stiffness to effectively function as a point mass.","category":"page"},{"location":"examples/D_simulatingFloatingPlatforms/","page":"Simulating Floating Platforms","title":"Simulating Floating Platforms","text":"nothing","category":"page"},{"location":"examples/D_simulatingFloatingPlatforms/","page":"Simulating Floating Platforms","title":"Simulating Floating Platforms","text":"Since the mesh is so simple, most of these inputs are trivial and affect little. However, a few items are of note:","category":"page"},{"location":"examples/D_simulatingFloatingPlatforms/","page":"Simulating Floating Platforms","title":"Simulating Floating Platforms","text":"The z positions in bottomMesh start at zero for the first node, and the second node is at the height of the tower base above the platform reference point (aka the platform location at the still water level above the platform centroid). In the case of the OC4 platform, this is 10 meters. This is also reflected in the Length argument in bottomOrt\nThe bottomSectionProps structure has very large values for EIyy, EIzz, GJ, and EA, which are all the relevant stiffness properties, in order to effectively model the platform as a rigid body.\nThe zcm parameter in bottomSectionProps is set to the vertical distance of the platform with respect to the platform reference point. For the OC4 platform, this is 8.6588 meters below sea level.","category":"page"},{"location":"examples/D_simulatingFloatingPlatforms/","page":"Simulating Floating Platforms","title":"Simulating Floating Platforms","text":"bottomMesh = OWENSFEA.Mesh(\n    [1, 2], #nodeNum\n    1, #numElx\n    2, #numNodes\n    [0.0, 0.0], #x\n    [0.0, 0.0], #y\n    [0.0, 10.0], #z\n    [1], #elNum\n    [1 2], #conn\n    [0], #type\n    [0, 1], #meshSeg\n    zeros(1,1), #structuralSpanLocNorm\n    zeros(Int,1,1), #structuralNodeNumbers\n    zeros(Int,1,1) #structuralElNumbers\n    )\nnumBottomNodes = length(bottomMesh.z)\nbottomOrt = OWENSFEA.Ort(\n    [180.0], #Psi_d\n    [-90.0],  #Theta_d\n    [90.0], #Twist_d\n    [10.0], #Length\n    ones(1,1), #elNum\n    zeros(3,1)#Offset\n    )\nn_ptfm_elem = 1\nbottomSectionProps = Array{OWENSFEA.SectionPropsArray,1}(undef, n_ptfm_elem)\nfor ii = 1:n_ptfm_elem\n    bottomSectionProps[ii] = OWENSFEA.SectionPropsArray(\n        [0.0, 0.0], #ac\n        [0.0, 0.0], #twist_d\n        [0.0, 0.0], #rhoA\n        [1e18, 1e18], #EIyy\n        [1e18, 1e18], #EIzz\n        [1e18, 1e18], #GJ\n        [1e18, 1e18], #EA\n        [0.0, 0.0], #rhoIyy\n        [0.0, 0.0], #rhoIzz\n        [0.0, 0.0], #rhoJ\n        [-8.6588, 0.0], #zcm\n        [0.0, 0.0], #ycm,\n        [0.0, 0.0], #a\n        [0.0, 0.0], #EIyz\n        [0.0, 0.0], #alpha1\n        [0.0, 0.0], #alpha2\n        [0.0, 0.0], #alpha3\n        [0.0, 0.0], #alpha4\n        [0.0, 0.0], #alpha5\n        [0.0, 0.0], #alpha6\n        [0.0, 0.0], #rhoIyz\n        [0.0, 0.0], #b\n        [0.0, 0.0], #a0\n        [0.0, 0.0], #aeroCenterOffset\n    )\nend\n\nnothing","category":"page"},{"location":"examples/D_simulatingFloatingPlatforms/","page":"Simulating Floating Platforms","title":"Simulating Floating Platforms","text":"We also want to provide some additional general inputs to enable floating simulation. platformActive being the principal and obvious one, but also the input files needed by HydroDyn and MoorDyn, which are the external libraries that calculate the hydrodynamic and mooring loads to send to the bottom side mesh. These input files include:","category":"page"},{"location":"examples/D_simulatingFloatingPlatforms/","page":"Simulating Floating Platforms","title":"Simulating Floating Platforms","text":"interpOrder: the degree of interpolation used to predict the future states within HydroDyn and MoorDyn, used in the HD_UpdateStates and MD_UpdateStates functions\nhdinputfile: the base HydroDyn input file with a .dat extension\nmdinputfile: the base MoorDyn input file with a .dat extension\nssinputfile: the sea state input file with a .dat extension used to define the environmental conditions of the sea. This is used within HydroDyn.\npotfilefile: the prefix of the potential flow files. At minimum, the directory must contain the .1, .3, and .hst WAMIT output files. This is also used within HydroDyn.","category":"page"},{"location":"examples/D_simulatingFloatingPlatforms/","page":"Simulating Floating Platforms","title":"Simulating Floating Platforms","text":"See the OpenFAST documentation for HydroDyn (https://openfast.readthedocs.io/en/main/source/user/hydrodyn/input_files.html) and MoorDyn (https://moordyn.readthedocs.io/en/latest/inputs.html) for more information about how to format these input files. For simplicity here, we will use predefined input files for the OC4 semisubmersible platform, which comes with OpenFAST and is copied to the data folder here.","category":"page"},{"location":"examples/D_simulatingFloatingPlatforms/","page":"Simulating Floating Platforms","title":"Simulating Floating Platforms","text":"if AeroModel==\"AD\"\n    AD15On = true\nelse\n    AD15On = false\nend\nplatformActive = true\ninterpOrder = 2\nhd_input_file = \"$(path)/data/HydroDyn.dat\"\nmd_input_file = \"$(path)/data/MoorDyn.dat\"\nss_input_file = \"$(path)/data/SeaState.dat\"\npotflowfile = \"$(path)/data/potflowdata/marin_semi\"\n\ninputs = OWENS.Inputs(;analysisType = analysisType,\ntocp = [0.0,100000.1],\nOmegaocp = [RPM,RPM] ./ 60,\ntocp_Vinf = [0.0,100000.1],\nVinfocp = [Vinf,Vinf],\nnumTS,\ndelta_t,\nAD15On,\naeroLoadsOn = 2,\nplatformActive,\ninterpOrder,\nhd_input_file,\nmd_input_file,\nss_input_file,\npotflowfile)\n\nnothing","category":"page"},{"location":"examples/D_simulatingFloatingPlatforms/","page":"Simulating Floating Platforms","title":"Simulating Floating Platforms","text":"We also will need to specify where the HydroDyn and MoorDyn libraries exist on the computer. We will set these to nothing so the auto-installed libraries will be used by default. Change these variables as needed if the location of these libraries are different.","category":"page"},{"location":"examples/D_simulatingFloatingPlatforms/","page":"Simulating Floating Platforms","title":"Simulating Floating Platforms","text":"hd_lib = nothing\nmd_lib = nothing\nbin = OWENS.Bin(hd_lib, md_lib)\n\nnothing","category":"page"},{"location":"examples/D_simulatingFloatingPlatforms/","page":"Simulating Floating Platforms","title":"Simulating Floating Platforms","text":"As in previous examples, we need to define the inputs for the finite element models, though now we need a definition for both the topside and the bottom side.","category":"page"},{"location":"examples/D_simulatingFloatingPlatforms/","page":"Simulating Floating Platforms","title":"Simulating Floating Platforms","text":"The changes to the topside from example A are the lack of boundary conditions, non-default gamma and alpha terms (for better convergence with the platform mesh).","category":"page"},{"location":"examples/D_simulatingFloatingPlatforms/","page":"Simulating Floating Platforms","title":"Simulating Floating Platforms","text":"topFEAModel = OWENS.FEAModel(;\n    analysisType = analysisType,\n    dataOutputFilename = \"none\",\n    joint = topJoint,\n    platformTurbineConnectionNodeNumber = 1,\n    nlOn = true,\n    numNodes = topMesh.numNodes,\n    RayleighAlpha = 0.05,\n    RayleighBeta = 0.05,\n    iterationType = \"DI\",\n    gamma = 1.0,\n    alpha = 0.5)\n\nnothing","category":"page"},{"location":"examples/D_simulatingFloatingPlatforms/","page":"Simulating Floating Platforms","title":"Simulating Floating Platforms","text":"The bottom finite element mesh will use the same inputs with two exceptions: joints is now empty (since we're considering the platform as a single rigid body), and we add an additional concentrated term at the bottom node to represent the rigid body mass matrix of the platform. The values here are pulled from the report \"Definition of the Semisubmersible Floating System for Phase II of OC4\" by Robertson et al. (2014) (https://doi.org/10.2172/1155123).","category":"page"},{"location":"examples/D_simulatingFloatingPlatforms/","page":"Simulating Floating Platforms","title":"Simulating Floating Platforms","text":"numDOFPerNode = 6\n\nptfm_mass = 3.85218e6\nptfm_roll_iner = 2.56193e9\nptfm_pitch_iner = 2.56193e9\nptfm_yaw_iner = 4.24265e9\nptfm_Ixx = ptfm_roll_iner\nptfm_Iyy = ptfm_pitch_iner\nptfm_Izz = ptfm_yaw_iner\nptfm_Ixy = 0.0\nptfm_Iyz = 0.0\nptfm_Ixz = 0.0\nptfm_mass = [\n    ptfm_mass 0.0 0.0 0.0 0.0 0.0\n    0.0 ptfm_mass 0.0 0.0 0.0 0.0\n    0.0 0.0 ptfm_mass 0.0 0.0 0.0\n    0.0 0.0 0.0 ptfm_Ixx ptfm_Ixy ptfm_Ixz\n    0.0 0.0 0.0 ptfm_Ixy ptfm_Iyy -ptfm_Iyz\n    0.0 0.0 0.0 ptfm_Ixz -ptfm_Iyz ptfm_Izz\n]\nbottomConcInputs = [\n    1 \"M6\" 1 1 ptfm_mass[1, 1]\n    1 \"M6\" 1 2 ptfm_mass[1, 2]\n    1 \"M6\" 1 3 ptfm_mass[1, 3]\n    1 \"M6\" 1 4 ptfm_mass[1, 4]\n    1 \"M6\" 1 5 ptfm_mass[1, 5]\n    1 \"M6\" 1 6 ptfm_mass[1, 6]\n    1 \"M6\" 2 1 ptfm_mass[2, 1]\n    1 \"M6\" 2 2 ptfm_mass[2, 2]\n    1 \"M6\" 2 3 ptfm_mass[2, 3]\n    1 \"M6\" 2 4 ptfm_mass[2, 4]\n    1 \"M6\" 2 5 ptfm_mass[2, 5]\n    1 \"M6\" 2 6 ptfm_mass[2, 6]\n    1 \"M6\" 3 1 ptfm_mass[3, 1]\n    1 \"M6\" 3 2 ptfm_mass[3, 2]\n    1 \"M6\" 3 3 ptfm_mass[3, 3]\n    1 \"M6\" 3 4 ptfm_mass[3, 4]\n    1 \"M6\" 3 5 ptfm_mass[3, 5]\n    1 \"M6\" 3 6 ptfm_mass[3, 6]\n    1 \"M6\" 4 1 ptfm_mass[4, 1]\n    1 \"M6\" 4 2 ptfm_mass[4, 2]\n    1 \"M6\" 4 3 ptfm_mass[4, 3]\n    1 \"M6\" 4 4 ptfm_mass[4, 4]\n    1 \"M6\" 4 5 ptfm_mass[4, 5]\n    1 \"M6\" 4 6 ptfm_mass[4, 6]\n    1 \"M6\" 5 1 ptfm_mass[5, 1]\n    1 \"M6\" 5 2 ptfm_mass[5, 2]\n    1 \"M6\" 5 3 ptfm_mass[5, 3]\n    1 \"M6\" 5 4 ptfm_mass[5, 4]\n    1 \"M6\" 5 5 ptfm_mass[5, 5]\n    1 \"M6\" 5 6 ptfm_mass[5, 6]\n    1 \"M6\" 6 1 ptfm_mass[6, 1]\n    1 \"M6\" 6 2 ptfm_mass[6, 2]\n    1 \"M6\" 6 3 ptfm_mass[6, 3]\n    1 \"M6\" 6 4 ptfm_mass[6, 4]\n    1 \"M6\" 6 5 ptfm_mass[6, 5]\n    1 \"M6\" 6 6 ptfm_mass[6, 6]\n]\nbottomConcTerms = OWENSFEA.applyConcentratedTerms(\n    bottomMesh.numNodes,\n    numDOFPerNode,\n    data=bottomConcInputs,\n    jointData=[])\nbottomFEAModel = OWENS.FEAModel(;\n    analysisType = analysisType,\n    dataOutputFilename = \"none\",\n    joint = [],\n    platformTurbineConnectionNodeNumber = 1,\n    nlOn = true,\n    numNodes = bottomMesh.numNodes,\n    RayleighAlpha = 0.05,\n    RayleighBeta = 0.05,\n    iterationType = \"DI\",\n    gamma = 1.0,\n    alpha = 0.5,\n    nodalTerms=bottomConcTerms)\n\nnothing","category":"page"},{"location":"examples/D_simulatingFloatingPlatforms/","page":"Simulating Floating Platforms","title":"Simulating Floating Platforms","text":"Finally, some additional structure definitions for the bottom mesh. These don't contain anything new, but are required for OWENS to run properly.","category":"page"},{"location":"examples/D_simulatingFloatingPlatforms/","page":"Simulating Floating Platforms","title":"Simulating Floating Platforms","text":"bottomEl = OWENSFEA.El(bottomSectionProps,\n                       bottomOrt.Length,\n                       bottomOrt.Psi_d,\n                       bottomOrt.Theta_d,\n                       bottomOrt.Twist_d,\n                       ones(bottomMesh.numEl))\n\nnothing","category":"page"},{"location":"examples/D_simulatingFloatingPlatforms/","page":"Simulating Floating Platforms","title":"Simulating Floating Platforms","text":"We can now run our floating simulation in OWENS. Note that we are using OWENS.Unsteady now instead of OWENS.Unsteady_Land.","category":"page"},{"location":"examples/D_simulatingFloatingPlatforms/","page":"Simulating Floating Platforms","title":"Simulating Floating Platforms","text":"println(\"Running Unsteady\")\nt, aziHist, OmegaHist, OmegaDotHist, gbHist, gbDotHist, gbDotDotHist, FReactionHist, FTwrBsHist,\ngenTorque, genPower, torqueDriveShaft, uHist, uHist_prp,\nepsilon_x_hist, epsilon_y_hist, epsilon_z_hist, kappa_x_hist, kappa_y_hist, kappa_z_hist,\nFPtfmHist, FHydroHist, FMooringHist = OWENS.Unsteady(inputs,\n    system=topSystem,\n    assembly=topAssembly,\n    topModel=topFEAModel,\n    topMesh=topMesh,\n    topEl=topEl,\n    aero=aeroForces,\n    deformAero=deformAero,\n    bottomModel=bottomFEAModel,\n    bottomMesh=bottomMesh,\n    bottomEl=bottomEl,\n    bin=bin)\n\nif AD15On #TODO: move this into the run functions\n    OWENS.OWENSOpenFASTWrappers.endTurb()\nend\n\nnothing","category":"page"},{"location":"examples/D_simulatingFloatingPlatforms/","page":"Simulating Floating Platforms","title":"Simulating Floating Platforms","text":"Since we ran the simulation for such a short time period for sake of demonstrating completion of the simulation, the plots below are not too interesting. Try experimenting with changing the numTS variable above to a longer simulation to see how the floating VAWT responds over time. Note that the platform modeled here is not necessarily design for the Darrieus VAWT it is supporting, so your mileage may vary on the simulation results. PyPlot.plot(t, uHist_prp[:, 1]) PyPlot.title(\"Platform Surge Response\") PyPlot.xlabel(\"Time [s]\") PyPlot.ylabel(\"Force [N]\") PyPlot.plot(t, FHydroHist[:, 1]) PyPlot.xlabel(\"Time [s]\") PyPlot.ylabel(\"Force [N]\") PyPlot.title(\"Hydrodynamic Surge Loading\")","category":"page"},{"location":"examples/D_simulatingFloatingPlatforms/","page":"Simulating Floating Platforms","title":"Simulating Floating Platforms","text":"nothing","category":"page"},{"location":"examples/D_simulatingFloatingPlatforms/","page":"Simulating Floating Platforms","title":"Simulating Floating Platforms","text":"","category":"page"},{"location":"examples/D_simulatingFloatingPlatforms/","page":"Simulating Floating Platforms","title":"Simulating Floating Platforms","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/referenceAero/#OWENSAero","page":"OWENSAero","title":"OWENSAero","text":"","category":"section"},{"location":"reference/referenceAero/#Types-and-functions","page":"OWENSAero","title":"Types and functions","text":"","category":"section"},{"location":"reference/referenceAero/#OWENSAero.Environment","page":"OWENSAero","title":"OWENSAero.Environment","text":"Environment(rho::TF,mu::TF,Vx::TAF #Vinf is Vx,Vy::TAF,Vz::TAF,Vtwist::TAF,windangle::TF #radians,DynamicStallModel::TS,AeroModel::TS,awwarm::TVF,steplast::TAI,idxRPI::TAI,Vwakeold::TVF2,BVDynamicFlagL::TAI,BVDynamicFlagD::TAI,alphalast::TAF2,suction::TB) Environment(rho,mu,Vx,Vy,Vz,Vtwist,windangle,DynamicStallModel,AeroModel,awwarm) = Environment(rho,mu,Vx,Vy,Vz,Vtwist,windangle,DynamicStallModel,AeroModel,awwarm,zeros(Int,1),zeros(Int,length(Vx)),deepcopy(Vx),zeros(Int,1),zeros(Int,1),zeros(Real,1),false) Environment(rho,mu,Vx,DynamicStallModel,AeroModel,awwarm) = Environment(rho,mu,Vx,zeros(Real,size(Vx)),zeros(Real,size(Vx)),zeros(Real,size(Vx)),0.0,DynamicStallModel,AeroModel,awwarm,zeros(Int,1),zeros(Int,length(Vx)),deepcopy(Vx),zeros(Int,1),zeros(Int,1),zeros(Real,1),false)\n\nContains specications for turbine slice environment/operating conditions as well as some backend memory for dynamic stall and unsteady calculations\n\nInputs\n\nrho::TF: Working fluid density (kg/m^3)\nmu::TF: Working fluid viscosity (standard SI units)\nV_x::TAF Vinf is Vx for simple simulations (m/s), array corresponding to each azimuthal position\nV_y::TAF: y input velocity (m/s), array corresponding to each azimuthal position\nV_z::TAF: z input velocity (m/s), array corresponding to each azimuthal position\nV_twist::TAF: rotational velocity from active twist (rad/s), array corresponding to each azimuthal position\nwindangle::TF: angle of mean oncoming wind (rad)\nDynamicStallModel::TS: dynamic stall model (\"BV\" or \"none\" or \"LB\" - once it is finished)\nAeroModel::TS: aero model used (\"DMS\" or \"AC\")\naw_warm::TVF: warm start induction factor array, first half corresponding to u, second half to v\nsteplast::TAI: prior simulation step index, used for unsteady wake propogation\nidx_RPI::TAI: used to specify the azimuthal indices needed for a partial solve (i.e. not every azimuthal index), such as is used in the RPI method\nV_wake_old::TVF2: Prior step's mean wake velocity (m/s)\nBV_DynamicFlagL::TAI: Boeing-vertol dynamic stall lift flag\nBV_DynamicFlagD::TAI: Boeing-vertol dynamic stall drag flag\nalpha_last::TAF2: Boeing-vertol dynamic stall prior step's angle of attack\nsuction::TB: DMS flag for alternate induction model\n\nOutputs:\n\nnone:\n\n\n\n\n\n","category":"type"},{"location":"reference/referenceAero/#OWENSAero.Turbine","page":"OWENSAero","title":"OWENSAero.Turbine","text":"Turbine(R::TF,r::TAF,z::TF,chord::TAF3,twist::TAF5,delta::TAF,omega::TAF4,B::TI,af::TFN,ntheta::TI,r_delta_influence::TB,centerX::TAF2,centerY::TAF2)\nTurbine(R,r,z,chord,twist,delta,omega,B,af,ntheta,r_delta_infl) = Turbine(R,r,z,chord,twist,delta,omega,B,af,ntheta,r_delta_infl,zeros(Real,size(R)),zeros(Real,size(R)))\nTurbine(R,r,chord,twist,delta,omega,B,af,ntheta,r_delta_infl) = Turbine(R,r,1.0,chord,twist,delta,omega,B,af,ntheta,r_delta_infl,zeros(Real,size(R)),zeros(Real,size(R)))\n\nContains specications for turbine slice (geometry, location, airfoil)\n\nInputs\n\nR::TF: Nominal turbine radius (m)\nr::TAF: Array of local radaii corresponding to each azimuthal position for the slice, allows for active blade deformation (m)\nz::TF: Vertical location of slice (only used when calling inflow-wind turbulent input)(m)\nchord::TAF3: Array of chord corresponding to each azimuthal position, allows for active blade deformation (m)\ntwist::TAF5: Array of blade twist corresponding to each azimuthal position, allows for active blade deformation (rad)\ndelta::TAF: Array of blade slope corresponding to each azimuthal position, allows for active blade deformation (rad)\nomega::TAF4: Array of rotational rate corresponding to each azimuthal position, allows for active blade deformation (rad/s)\nB::TI: Number of blades\naf::TFN: Airfoil function - see tests for example of how to create\nntheta::TI: Number of azimuthal discretizations\nr_delta_influence::TB: Specification of whether local radius and blade slope are used in the influence coefficients for the actuator cylinder method\ncenterX::TAF2: Turbine center x location (only used if multiple turbines are modeled)\ncenterY::TAF2: Turbine center y location (only used if multiple turbines are modeled)\n\nOutputs:\n\nnone:\n\n\n\n\n\n","category":"type"},{"location":"reference/referenceAero/#OWENSAero.UnsteadyParams","page":"OWENSAero","title":"OWENSAero.UnsteadyParams","text":"UnsteadyParams(RPI::TB,tau::TAF,ifw::TB,IECgust::TB,nominalVinf::TF,G_amp::TF,gustX0::TF,gustT::TF) UnsteadyParams(RPI,tau,ifw) = UnsteadyParams(RPI,tau,ifw,false,1.0,0.0,1.0,1.0)\n\nContains specications for turbine slice unsteady inputs\n\nInputs\n\nRPI::TB: Flag to specify if RPI is being used\ntau::TAF: Unsteady method wake propogation weighting [3.0,0.3]\nifw::TB: Flag to specify if inflow-wind is being used\nIECgust::TB: Flag to specify if the simple sin-cos gust profile in the x-direction will be used\nnominalVinf::TF: Nominal velocity used to calculate the IEC gust size (m/s)\nG_amp::TF: IEC gust amplitude (m/s)\ngustX0::TF: IEC gust normalized starting point (x-location divided by reference radius)\ngustT::TF: IEC gust duration (s)\n\nOutputs:\n\nnone:\n\n\n\n\n\n","category":"type"},{"location":"reference/referenceAero/#OWENSAero.AC-Tuple{Any, Any}","page":"OWENSAero","title":"OWENSAero.AC","text":"AC(turbines, env; w=zeros(Real,2turbines[1].ntheta), idx_RPI=1:2turbine.ntheta, solve=true, ifw=false)\n\nsee ?steady for detailed i/o description\n\nDouble multiple streamtube model\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceAero/#OWENSAero.AyIJ-NTuple{5, Any}","page":"OWENSAero","title":"OWENSAero.AyIJ","text":"integrand used for computing AIJ\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceAero/#OWENSAero.Ayintegrand-NTuple{5, Any}","page":"OWENSAero","title":"OWENSAero.Ayintegrand","text":"integrand used for computing Ay\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceAero/#OWENSAero.Boeing_Vertol-NTuple{11, Any}","page":"OWENSAero","title":"OWENSAero.Boeing_Vertol","text":"Boeing_Vertol(af,alpha,adotnorm,umach,Re,aoaStallPos,aoaStallNeg,AOA0,tc,BV_DynamicFlagL,BV_DynamicFlagD; family_factor = 0.0)\n\nBoeing-Vertol Dynamic Stall Model. All angles are in rad unless explicitely stated otherwise (e.g. alpha_d) Arguments\n\naf::airfoil_data4D: airfoil function callable by: CL, CD, CM = af(aoa,Re,mach,family_factor)\nalpha::Float64: Static Angle of Attack (at 0.75 chord)\nadotnorm::Float64: Normalized Change in Angle of Attack adotc/(2U)\numach::Float64: Blade mach number\nRe::Float64: Blade Reynolds number\naoaStallPos::Float64: Positive Stall Angle (onset)\naoaStallNeg::Float64: Negative Stall Angle (onset)\nAOA0::Float64: Zero Lift AOA\ntc::Float64: Thickness to chord ratio\nBV_DynamicFlagL::Int: lagged dynamic stall state for lift\nBV_DynamicFlagD::Int: lagged dynamic stall state for drag\nfamily_factor::float64: factor indexing airfoil family, if used\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceAero/#OWENSAero.DMS-Tuple{Any, Any}","page":"OWENSAero","title":"OWENSAero.DMS","text":"DMS(turbine, env; w=0, idx_RPI=1:turbine.ntheta, solve=true)\n\nsee ?steady for detailed i/o description\n\nDouble multiple streamtube model\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceAero/#OWENSAero.DxII-Tuple{Any}","page":"OWENSAero","title":"OWENSAero.DxII","text":"integrand used for computing DxII\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceAero/#OWENSAero.DxIJ-NTuple{5, Any}","page":"OWENSAero","title":"OWENSAero.DxIJ","text":"integrand used for computing DxIJ\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceAero/#OWENSAero.Dxintegrand-NTuple{5, Any}","page":"OWENSAero","title":"OWENSAero.Dxintegrand","text":"integrand used for computing Dx\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceAero/#OWENSAero.Unsteady_Step-NTuple{4, Any}","page":"OWENSAero","title":"OWENSAero.Unsteady_Step","text":"Unsteady_Step(turbine,env,us_param,mystep)\n\ncalls inflow wind init\n\nInputs\n\nturbine::Turbine: turbine input for slice see ?Turbine\nenv::Env: environment input for slice see ?Env\nus_param::UnsteadyParams: unsteady inputs for slice see ?UnsteadyParams\nmystep::int: continuous index cooresponding to the azimuthal discretation - i.e. for ntheta of 30 step 1 is the first step of rev 1, sep 31 is the first step of rev 2, etc.  Keeps track of temporal locaion\n\nOutputs:\n\nCP: This slice's coefficient of performance at this step\nTh: This slice's thrust coefficient at this step\nQ: Torque (N0m) at this step\nRp: Radial force per height (N) at this step\nTp: Tangential force per height (N) at this step\nZp: Vertical force per height (N) at this step\nVloc: Local velocity array for each azimuthal position (includes induction) (m/s) at this step\nCD: This slice's drag coefficient at this step\nCT: This slice's thrust coefficient (should equal drag, but may no depending on usage or solver status) at this step\namean: Mean turbine induction in the streamwise direction at this step\nastar: Solved induction factors for each azimuthal location. First half are streamwise (u), second are cross-steam (v) at this step\nalpha: Local angle of attack array for each azimuthal position (includes induction) (rad) at this step\ncl: Local lift coefficient used for each azimuthal position at this step\ncd_af: Local drag coefficient used for each azimuthal position at this step\nthetavec: Azimuthal location of each discretization (rad)\nRe: Reynolds number for each azimuthal position at this step\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceAero/#OWENSAero.WxII-Tuple{Any}","page":"OWENSAero","title":"OWENSAero.WxII","text":"integrand used for computing WxII\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceAero/#OWENSAero.WxIJ-Tuple{Any, Any, Any}","page":"OWENSAero","title":"OWENSAero.WxIJ","text":"integrand used for computing WxIJ\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceAero/#OWENSAero.advanceTurb-Tuple{Any}","page":"OWENSAero","title":"OWENSAero.advanceTurb","text":"advanceTurb(tnew;ts=2*pi/(turbslices[1].omega[1]*turbslices[1].ntheta))\n\nRuns a previously initialized aero model (see ?setupTurb) in the unsteady mode (can be repeateadly called, or called for a specific time, or repeatedly called for sections of time)\n\nInputs\n\ntnew::float: new time (s); will run from last time specified from the last call, to the current time specified, or from t=ts if the first time called\nts::float: optional, desired timestep.  Will run at finer timesteps than the azimuthal discretization without interfering with wake propogation.  While possible, it is not recommended to run with timesteps larger than the azimuthal discretization (hence the optional nature and automatic calculation)\n\nOutputs:\n\nCP: Turbine coefficient of performance\nRp: Array(B,Nslices,nsteps) of radial force (N) where nsteps = max(1,round(Int,(tnew-timelast)/ts))\nTp: Array(B,Nslices,n_steps) of tangential force (N)\nZp: Array(B,Nslices,n_steps) of vertical force (N)\nalpha: Array(B,Nslices,n_steps) of angle of attack (rad)\ncl: Array(B,Nslices,n_steps) of airfoil cl used\ncd_af: Array(B,Nslices,n_steps) of airfoil cd used\nVloc: Array(B,Nslices,n_steps) of airfoil local velocity used\nRe: Array(B,Nslices,n_steps) of airfoil Reynolds number used\nthetavec: Azimuthal discretization location (rad)\nntheta: number of azimuthal discretizations used\nFx_base: Array(ntheta)Turbine base Fx (N)\nFy_base: Array(ntheta)Turbine base Fy (N)\nFz_base: Array(ntheta)Turbine base Fz (N)\nMx_base: Array(ntheta)Turbine base Mx (N-m)\nMy_base: Array(ntheta)Turbine base My (N-m)\nMz_base: Array(ntheta)Turbine base Mz (N-m)\npower: Array(ntheta)Turbine power (watts)\npower2: Turbine average power for the revolution (watts)\ntorque: Array(ntheta)Turbine torque (N-m) (alternative calculation method from Mz-base)\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceAero/#OWENSAero.deformTurb-Tuple{Any}","page":"OWENSAero","title":"OWENSAero.deformTurb","text":"deformTurb(azi;newOmega=-1,newVinf=-1,bldx=-1,     bldz=-1,     bld_twist=-1,     steady=false)\n\nEquivalent to an update states call, mutating the internal aerodynamic inputs within the unsteady model.\n\nInputs\n\nazi: Current azimuth position of the turbine in radians (continuously growing with numbers of revolutions)\nbld_x: Blade structural x shape, size(NBlade,any), any as it is splined against bld_z and the aero discretization\nbld_z: Blade structural z shape, size(NBlade,any), any as it is splined against bld_x and the aero discretization\nbld_twist: Blade structural twist, size(NBlade,any), any as it is splined against bld_z and the aero discretization.  Note that in the calcs, this will be in addition to the aero twist offset already applied in initialization.\naccel_flap_in: Blade structural acceleration in the flap direction, size(NBlade,any), any as it is splined against bld_z and the aero discretization\naccel_edge_in: Blade structural acceleration in the edge direction, size(NBlade,any), any as it is splined against bld_z and the aero discretization\nsteady::bool: if steady is true, it just updates a single step.  TODO: verify this is correct\n\nOutputs:\n\nnone:\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceAero/#OWENSAero.matrixAssemble-NTuple{5, Any}","page":"OWENSAero","title":"OWENSAero.matrixAssemble","text":"Internal, assembles the matrices of multiple turbine systems into a combined system centerX, centerY: array of x,y coordinates for centers of the VAWTs in the farm radii: corresponding array of their radii\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceAero/#OWENSAero.pInt-Tuple{Any, Any}","page":"OWENSAero","title":"OWENSAero.pInt","text":"Internal, integration for a periodic function where end points don't reach ends (uses trapezoidal method)\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceAero/#OWENSAero.panelIntegration-NTuple{6, Any}","page":"OWENSAero","title":"OWENSAero.panelIntegration","text":"applies for both Ay and Rx depending on which function ifunc(x, y, phi) is passed in\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceAero/#OWENSAero.precomputeMatrices-NTuple{4, Any}","page":"OWENSAero","title":"OWENSAero.precomputeMatrices","text":"Internal, precomputes influence coefficient matricies and saves them as HDF5 files\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceAero/#OWENSAero.radialforce-NTuple{5, Any}","page":"OWENSAero","title":"OWENSAero.radialforce","text":"Internal, calculates the radial force used in the residual function as well as the turbine performance when converged\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceAero/#OWENSAero.readaerodyn-Tuple{Any}","page":"OWENSAero","title":"OWENSAero.readaerodyn","text":"readaerodyn(filename)\n\ncreate airfoil lookup for a file with only one reynolds number\n\nInputs\n\nfilename::string: file path/name to airfoil file formatted like in the test folder\n\nOutputs:\n\naf::function: cl, cd = af(alpha,re,mach) with alpha in rad\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceAero/#OWENSAero.readaerodyn_BV-Tuple{Any}","page":"OWENSAero","title":"OWENSAero.readaerodyn_BV","text":"readaerodyn_BV(filename)\n\ncreate airfoil lookup function with boeing vertol dynamic stall model for a file with only one reynolds number\n\nInputs\n\nfilename::string: file path/name to airfoil file formatted like in the test folder\n\nOutputs:\n\naf::function: cl, cd = afBV(alpha,Re,M,env,Vtwist,c,dt,U;solvestep=false) with alpha in rad, OWENSAero.Env, V_twist in rad/s, c chord in m, dt in sec, U Vloc in m/s, solvestep true during solve loop\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceAero/#OWENSAero.readaerodyn_BV_NEW-Tuple{Any}","page":"OWENSAero","title":"OWENSAero.readaerodyn_BV_NEW","text":"readaerodyn_BV_NEW(filename;DynamicStallModel=\"BV\")\n\nfor a file with multiple reynolds numbers create airfoil lookup function with boeing vertol dynamic stall model and wrap interpolation\n\nInputs\n\nfilename::string: file path/name to airfoil file formatted like in the test folder\nDynamicStallModel::string: \"BV\" or \"none\"\n\nOutputs:\n\naf::function: cl, cd = afBV(alpha,Re,M,env,Vtwist,c,dt,U;solvestep=false) with alpha in rad, OWENSAero.Env, V_twist in rad/s, c chord in m, dt in sec, U Vloc in m/s, solvestep true during solve loop\naf::function: cl, cd = af(alpha,re,mach) with alpha in rad\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceAero/#OWENSAero.residual-NTuple{6, Any}","page":"OWENSAero","title":"OWENSAero.residual","text":"Internal, sets up the residual function\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceAero/#OWENSAero.setupTurb-NTuple{6, Any}","page":"OWENSAero","title":"OWENSAero.setupTurb","text":"setupTurb(bldx,bldz,B,chord,omega,Vinf;     Height = maximum(bldz),     Radius = maximum(bldx),     eta = 0.25,     twist = 0.0, #or array{Float,Nslices}     rho = 1.225,     mu = 1.7894e-5,     RPI = true,     tau = [0.3,3.0],     ntheta = 30,     Nslices = 30, #TODO: make this different from ntheta     ifw = false,     DynamicStallModel = \"BV\",     AeroModel = \"DMS\",     windangleD = 0.0,     afname = \"(path)/airfoils/NACA0015RE3E5.dat\", #TODO: analytical airfoil as default     turbsimfilename = \"(path)/data/ifw/turbDLC1p313mps330mseed1.bts\",     ifwlibfile = joinpath(dirname(@FILE), \"../bin/libifwcbinding\"),     AeroAddedMassActive = false,     AeroBuoyancyActive = false,     AeroRotAccelActive = false,     AddedMassCoeff_Ca = 1.0)\n\nInitializes aerodynamic models and sets up backend persistent memory to simplify intermittent calling within coupled solver loops\n\nInputs\n\nbld_x: Blade x shape\nbld_z: Blade z shape\nB: Number of blades\nchord: chord length (m)\nomega: rotation rate in rad/s.  size(1) or size(ntheta), pass in an array(Real,ntheta) when propogating automatic gradients\nVinf: Inflow velocity\nHeight:  turbine total height (m) typically maximum(bldz) unless only the shape and not size of bldz is being used\nRadius:  turbine nominal radius (m) typically maximum(bldx) unless only shape and not size of bldx is used\neta: blade mount point ratio, i.e. 0.25 would be at the quarter chord\ntwist: 0.0, #or array{Float,Nslices}\nrho: working fluid density (kg/m^3)\nmu:  working fluid dynamic viscosity (Pa*s)\nRPI: RPI method flag\ntau: Unsteady wake propogation time constants [0.3,3.0],\nntheta: Number of azimuthal discretizations\nNslices: Number of vertical slices of the turbine\nifw: flag for inflow wind\nDynamicStallModel:  Dynamic stall model \"BV\" or \"none\" or \"LB\" when we get it working\nAeroModel:  Aerodynamic model \"DMS\" or \"AC\"\nwindangle_D:  Inflow wind angle (degrees)\nafname: airfoil path and name e.g. \"(path)/airfoils/NACA0015RE3E5.dat\"\nturbsim_filename: turbsim path and name e.g. \"(path)/data/ifw/turbDLC1p313mps330mseed1.bts\",\nifw_libfile:  inflow wind dynamic library location e.g. joinpath(dirname(@FILE), \"../../../openfast/build/modules/inflowwind/libifwcbinding\"))\nAero_AddedMass_Active::bool: flag to turn on added mass effects\nAero_Buoyancy_Active::bool: flag to turn on buoyancy forces\nAero_RotAccel_Active::bool: flag to turn on the rotational acceleration portion of added mass for a crossflow turbine\nAddedMass_Coeff_Ca::float: added mass coefficient, typically 1.0\n\nOutputs:\n\nnone:\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceAero/#OWENSAero.steady-Tuple{Any, Any}","page":"OWENSAero","title":"OWENSAero.steady","text":"steady(turbine::Turbine, env::Env; w=zeros(Real,2*turbine.ntheta), idx_RPI=1:2*turbine.ntheta,solve=true,ifw=false)\n\nCalculates steady state aerodynamics for a single VAWT slice\n\nInputs\n\nturbine::Turbine: Turbine struct, see ?Turbine for details\nenv::Env: Env struct, see ?Env for details\nw::Array(<:Real): Optional, used if solve=false, induction factor array, first half corresponding to u, second half to v\nidx_RPI::Array(<:Int): Optional, used to specify the azimuthal indices needed for a partial solve (i.e. not every azimuthal index), such as is used in the RPI method\nsolve::Bool: Optional, False is used when you want the model outputs for a given set of induction factors without resolving them.\nifw::Bool: Optional, used to tell the Vinf lookup to attempt to use the dynamic inflow wind library, requires preprocessing as is shown in the test cases.\n\nOutputs:\n\nCP: This slice's coefficient of performance\nTh: This slice's thrust coefficient\nQ: Torque (N0m)\nRp: Radial force per height (N)\nTp: Tangential force per height (N)\nZp: Vertical force per height (N)\nVloc: Local velocity array for each azimuthal position (includes induction) (m/s)\nCD: This slice's drag coefficient\nCT: This slice's thrust coefficient (should equal drag, but may no depending on usage or solver status)\namean: Mean turbine induction in the streamwise direction\nastar: Solved induction factors for each azimuthal location. First half are streamwise (u), second are cross-steam (v)\nalpha: Local angle of attack array for each azimuthal position (includes induction) (rad)\ncl: Local lift coefficient used for each azimuthal position\ncd_af: Local drag coefficient used for each azimuthal position\nthetavec: Azimuthal location of each discretization (rad)\nRe: Reynolds number for each azimuthal position\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceAero/#OWENSAero.steadyTurb-Tuple{}","page":"OWENSAero","title":"OWENSAero.steadyTurb","text":"steadyTurb(omega,Vinf)\n\nRuns a previously initialized aero model (see ?setupTurb) in the steady state mode\n\nInputs\n\nomega::float: turbine rotation rate (rad/s)\nVinf::float: turbine steady inflow velocity (m/s)\n\nOutputs:\n\nCP: Turbine coefficient of performance\nRp: Array(B,Nslices,ntheta) of radial force (N)\nTp: Array(B,Nslices,ntheta) of tangential force (N)\nZp: Array(B,Nslices,ntheta) of vertical force (N)\nalpha: Array(B,Nslices,ntheta) of angle of attack (rad)\ncl: Array(B,Nslices,ntheta) of airfoil cl used\ncd_af: Array(B,Nslices,ntheta) of airfoil cd used\nVloc: Array(B,Nslices,ntheta) of airfoil local velocity used\nRe: Array(B,Nslices,ntheta) of airfoil Reynolds number used\nthetavec: Azimuthal discretization location (rad)\nntheta: number of azimuthal discretizations used\nFx_base: Array(ntheta)Turbine base Fx (N)\nFy_base: Array(ntheta)Turbine base Fy (N)\nFz_base: Array(ntheta)Turbine base Fz (N)\nMx_base: Array(ntheta)Turbine base Mx (N-m)\nMy_base: Array(ntheta)Turbine base My (N-m)\nMz_base: Array(ntheta)Turbine base Mz (N-m)\npower: Array(ntheta)Turbine power (watts)\npower2: Turbine average power for the revolution (watts)\ntorque: Array(ntheta)Turbine torque (N-m) (alternative calculation method from Mz-base)\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceAero/#OWENSAero.streamtube-NTuple{4, Any}","page":"OWENSAero","title":"OWENSAero.streamtube","text":"INTERNAL streamtube(a,theta,turbine,env;output_all=false,Vxwake=nothing,solvestep=false)\n\nDouble multiple streamtube individual streamtube calculation\n\nOutput:\n\nif outputall     return Th, Q, Rp, Tp, Zp, Vloc, CD, CT, alpha, cl, cdaf, Re else     return CD-CT # Residual, section 2.4 end\n\n\n\n\n\n","category":"method"},{"location":"reference/referenceAero/#OWENSAero.trapz-Tuple{Any, Any}","page":"OWENSAero","title":"OWENSAero.trapz","text":"Internal, trapezoidal integration of y w.r.t. x\n\n\n\n\n\n","category":"method"},{"location":"OWENS_Dev_Guide/","page":"Developer Guide","title":"Developer Guide","text":"","category":"page"},{"location":"OWENS_Dev_Guide/","page":"Developer Guide","title":"Developer Guide","text":"author:","category":"page"},{"location":"OWENS_Dev_Guide/","page":"Developer Guide","title":"Developer Guide","text":"Kevin R. Moore","category":"page"},{"location":"OWENS_Dev_Guide/","page":"Developer Guide","title":"Developer Guide","text":"bibliography:","category":"page"},{"location":"OWENS_Dev_Guide/","page":"Developer Guide","title":"Developer Guide","text":"ac_sources.bib","category":"page"},{"location":"OWENS_Dev_Guide/","page":"Developer Guide","title":"Developer Guide","text":"title: Offshore Wind Energy Simulator (OWENS) Glue Code Basic Theory,   Frames of Reference, and Inter-Module Coupling Methods –-","category":"page"},{"location":"OWENS_Dev_Guide/#Introduction","page":"Developer Guide","title":"Introduction","text":"","category":"section"},{"location":"OWENS_Dev_Guide/","page":"Developer Guide","title":"Developer Guide","text":"The Offshore Wind Energy Simulator (OWENS) Code is a floating turbine-platform code capable of steady, unsteady, and modal analysis. It is comprised of, or coupled to many modules for aerodynamics, hydrodynamics, mooring dynamics, and finite element formulations.","category":"page"},{"location":"OWENS_Dev_Guide/","page":"Developer Guide","title":"Developer Guide","text":"How many of these items are used is not straightforward or a-priori and can easily lead to confusion or mistake (like how the aerodynamics uses inflow data; is it just simple based on the mean hub velocity, or in the rotating blade frame of reference? If the latter, what is that frame of reference so that we make sure we don't incorrectly map the vectors?) This document is intended as a developers guide for the intent of clearing up the relative ambiguity between the many moving and modular pieces. It is not a full theory document or users guide. For theory and use, please see the theory and user guides respectively. Within this document, we give enough detail about the operations of the \\\"glue\\\" code, the frames of reference, and coupling methods to aid further development.","category":"page"},{"location":"OWENS_Dev_Guide/#Contributing","page":"Developer Guide","title":"Contributing","text":"","category":"section"},{"location":"OWENS_Dev_Guide/","page":"Developer Guide","title":"Developer Guide","text":"Please make all feature changes and bug fixes as branches and then create pull requests against the dev branch. The dev branch will be periodically pulled into master.","category":"page"},{"location":"OWENS_Dev_Guide/#Julia-Code-Formatting","page":"Developer Guide","title":"Julia Code Formatting","text":"","category":"section"},{"location":"OWENS_Dev_Guide/","page":"Developer Guide","title":"Developer Guide","text":"To ensure code consistency, all Julia code in the src/ folder must be formatted using JuliaFormatter.jl. Formatting is automatically checked in continuous integration (CI) for all changes to the src/ directory. Contributors are required to run JuliaFormatter locally on the src/ folder before submitting pull requests. You can do this by running:","category":"page"},{"location":"OWENS_Dev_Guide/","page":"Developer Guide","title":"Developer Guide","text":"julia --project -e 'using JuliaFormatter; format(\"src\")'","category":"page"},{"location":"OWENS_Dev_Guide/","page":"Developer Guide","title":"Developer Guide","text":"Only the src/ folder is required to be formatted. Other folders (such as examples/ or test/) are not currently enforced by CI.","category":"page"},{"location":"OWENS_Dev_Guide/#Glue-Code-Basic-Theory","page":"Developer Guide","title":"Glue Code Basic Theory","text":"","category":"section"},{"location":"OWENS_Dev_Guide/","page":"Developer Guide","title":"Developer Guide","text":"Due to the nonlinearity and non-closed-form nature of the floating turbine problem in both the design and temporal space, OWENS uses many types of iterative solution methods, specific to the physics involved. Loose or Gauss-Seidel iteration is used for the coupling between the modules. gives an overview of the general code structure for transient analysis, with the main equations being solved and the relative location of the iteration loops.","category":"page"},{"location":"OWENS_Dev_Guide/","page":"Developer Guide","title":"Developer Guide","text":"::: algorithm ::: spacing 1.18","category":"page"},{"location":"OWENS_Dev_Guide/","page":"Developer Guide","title":"Developer Guide","text":"::: algorithmic Initialize simulation (all module parameters, meshing, composite properties, etc) Initialize displacements and forces as 0","category":"page"},{"location":"OWENS_Dev_Guide/","page":"Developer Guide","title":"Developer Guide","text":"Get driveshaft displacement from generator torque Get rotor speed, rotational displacement from generator torque, aero torque, and turbine inertia Get aero forces from rotor speed, position Get structural displacements and reaction forces from aero forces Update displacements_textguess with the calculated displacements ::: :::","category":"page"},{"location":"OWENS_Dev_Guide/","page":"Developer Guide","title":"Developer Guide","text":"[]{#alg:Transient label=\"alg:Transient\"} :::","category":"page"},{"location":"OWENS_Dev_Guide/#WindIO-Usage","page":"Developer Guide","title":"WindIO Usage","text":"","category":"section"},{"location":"OWENS_Dev_Guide/","page":"Developer Guide","title":"Developer Guide","text":"The majority of the WindIO standard can be used for the structural and aerodynamic design.  Airfoil polars are forthcoming.  However, there are the following additional and limitations:","category":"page"},{"location":"OWENS_Dev_Guide/","page":"Developer Guide","title":"Developer Guide","text":"Gravity single value or array of 3, is in the global frame of reference, so positive gravity would be pulling the structure up.\nStart and end nd_arc values are the only input supported.  Otherwise, there are as many as 12 different ways to specify this input.\nGrids must be defined from end to end, set number of plies to 1e-6 at unused spanwise sections.\nThe blade object is reused for the tower, struts, cables, etc. since these elements can be modeled at the same fidelity as the blade and can be simplified via simpler inputs, but the other WindIO definitions don't allow for the more complex inputs.","category":"page"},{"location":"OWENS_Dev_Guide/#Global-Frame-of-Reference","page":"Developer Guide","title":"Global Frame of Reference","text":"","category":"section"},{"location":"OWENS_Dev_Guide/","page":"Developer Guide","title":"Developer Guide","text":"Thanks to some legacy VAWT frames of reference where wind was originally coming from the top down, and then from the left right, the convention was to simply rotate the axes instead of properly redefining the global frame of reference to match standard math convention again. Therefore, an azimuth angle of 0, or yaw angle for standard VAWT frame of reference is top dead center. Therefore, blade 1 of a vawt should also be top dead center, i.e. aligned with the y+ axis as shown below.","category":"page"},{"location":"OWENS_Dev_Guide/","page":"Developer Guide","title":"Developer Guide","text":"(Image: Global Frame of Reference. Wind comes in from the left in the direction of the positive X-axis, the positive Y-axis is 90 degrees counter-clockwise to the X-axis. Z-axis is vertical. Positive rotations follow right hand rule. Note that the turbine is modeled in the rotating frame of reference. Therefore, the turbine stays stationary in its initial meshed position, excepting deformations, and inertial effects are calculated. The developer must use the calculated rotational position to map to the other models as necessary.){#fig:ac_velocities width=\"60%\"}","category":"page"},{"location":"OWENS_Dev_Guide/#InflowWind-and-TurbSim-Velocity-Inflow","page":"Developer Guide","title":"InflowWind and TurbSim Velocity Inflow","text":"","category":"section"},{"location":"OWENS_Dev_Guide/","page":"Developer Guide","title":"Developer Guide","text":"This is how it is defined in the manual, despite inverting the positive direction of rotation compared to standard notation.","category":"page"},{"location":"OWENS_Dev_Guide/","page":"Developer Guide","title":"Developer Guide","text":"(Image: Wind frame of reference is the same as global. However, the angle follows TurbSim and [InflowWind](https://github.com/old-NWTC/InflowWind) notation Wind propagation angle is zero when aligned with the positive X-axis and clockwise positive, in the direction of the negative negative Y-axis.){#fig:ac_velocities width=\"50%\"}","category":"page"},{"location":"OWENS_Dev_Guide/#Airfoils","page":"Developer Guide","title":"Airfoils","text":"","category":"section"},{"location":"OWENS_Dev_Guide/","page":"Developer Guide","title":"Developer Guide","text":"Airfoil geometry is typically defined starting at the trailing edge (1,0), looping around the bottom/pressure side to the leading edge (0,0), and then back along the top/suction side to the trailing edge (1,0) again.  There are several automatic corrections to handle files that slightly ill formatted, with output warnings, but this is limited and should not be relied on.","category":"page"},{"location":"OWENS_Dev_Guide/","page":"Developer Guide","title":"Developer Guide","text":"Airfoil polars are currently in different formats for OWENSAero and AeroDyn, see examples.  The airfoil name in the structural definition is assumed to be the same airfoil name as the geometry and the polar data.  The path to these files is automatically resolved as relative to the run location, so it expects an airfoils folder there.","category":"page"},{"location":"OWENS_Dev_Guide/","page":"Developer Guide","title":"Developer Guide","text":"Future work is planned to include enabling OWENSAero to read in the same airfoil files as AeroDyn, and to automatically generate polars from xfoil.jl.","category":"page"},{"location":"OWENS_Dev_Guide/#OWENSAero-Aerodynamics-(AC-and-DMS)","page":"Developer Guide","title":"OWENSAero Aerodynamics (AC and DMS)","text":"","category":"section"},{"location":"OWENS_Dev_Guide/","page":"Developer Guide","title":"Developer Guide","text":"(Image: VAWT 2D section looking downwards with induced velocity $w$ vector broken into $u$ and $v$ components depicted by arrows. Airfoils show example blade locations with dots aligning to the circumferential discretization. Aero frame of reference is the same as global, however a blade is at 0 degrees azimuth when it is aligned with the Y-axis. If an aero module is 2D, it is made quasi-3D by stacking slices from lower to higher in the Z-axis.){#fig:ac_velocities width=\"50%\"}","category":"page"},{"location":"OWENS_Dev_Guide/","page":"Developer Guide","title":"Developer Guide","text":"Note: CACTUS, does not fully follow this scheme and differs from the global frame of reference by switching the Y and Z axes for a VAWT. Also, be careful with the geometry inputs; if the blade 1 starts out at the \\\"south\\\" position, as opposed to the north, then it will behave as though it were a north starting blade rotating clockwise, and a symmetric gust velocity will match (if the simple iec uniform gust is used). All else for CACTUS follows the description above.","category":"page"},{"location":"OWENS_Dev_Guide/","page":"Developer Guide","title":"Developer Guide","text":"Aerodynamics forces are radial inward positive and tangential in direction of rotation positive. So, the blade local accelerations in the radial will be outward positive and in the tangential  will be in the opposite direction of rotation for a CCW rotor.  CW rotors are still in work and would need to have the local frame of reference rotation verified.  Therefor, for the added mass  equations, the forces should be negated. ","category":"page"},{"location":"OWENS_Dev_Guide/#OWENSFEA-Structures","page":"Developer Guide","title":"OWENSFEA Structures","text":"","category":"section"},{"location":"OWENS_Dev_Guide/","page":"Developer Guide","title":"Developer Guide","text":"Yaw is equivalent to the global azimuth angle as above, and is denoted in the code as Psi. Zero is top dead center, right hand rule positive rotation. The subscript D indicates degrees. Theta is the element slope, or delta, and","category":"page"},{"location":"OWENS_Dev_Guide/","page":"Developer Guide","title":"Developer Guide","text":"The rotation sequence is a Roll (Rx) - Pitch (Ry) - Yaw (Rz) sequence in OWENSFEA (R = Rz * Ry *Rx in multiplication order). This corresponds to Twist - Theta - Psi angle ordering. In the matrix multiplication this is R = R_psi * R_theta * R_twist, which is a [3,2,1] matrix ordering.","category":"page"},{"location":"OWENS_Dev_Guide/","page":"Developer Guide","title":"Developer Guide","text":"::: center    Name    Rotation Axis   OWENS Angle Names   –––- –––––––- –––––––––-    Roll       about X            Twist    Pitch      about Y            Theta     Yaw       about Z             Psi","category":"page"},{"location":"OWENS_Dev_Guide/","page":"Developer Guide","title":"Developer Guide","text":": Module Level of Detail in This Document :::","category":"page"},{"location":"OWENS_Dev_Guide/","page":"Developer Guide","title":"Developer Guide","text":"We apply these in order of Roll, then Pitch, then Yaw, which is R = Rz * Ry * Rx (application is from right to left in rotations) for a rotation of vector x by R. i.e R(x) = Rz * Ry * Rx * x.","category":"page"},{"location":"OWENS_Dev_Guide/","page":"Developer Guide","title":"Developer Guide","text":"In the code I now have ang = [ort.Psid[idx], ort.Thetad[idx],ort.Twistd[idx]+180,-90]; DCM = CH2G * createGeneralTransformationMatrix(ang,[3,2,1,2]); Where I have an additional rotation by -90 about the Y axis to align Z with X before applying the other rotation sequences. This is due to AD15 using the IEC conventions with +Z along the blade, but the beam solver using the more typical beam formulation of +X along the beam.","category":"page"},{"location":"OWENS_Dev_Guide/","page":"Developer Guide","title":"Developer Guide","text":"This is almost consistent between blades and struts (have a +90 rotation on struts for some reason that I haven't sorted out yet).","category":"page"},{"location":"OWENS_Dev_Guide/","page":"Developer Guide","title":"Developer Guide","text":"Rotating Frame of Reference, 6 DOF where 1 = turbine vertical force, 2 = turbine 2D slice tangential force, 3 = turbine 2D slice normal force, 4 = blade M25 twisting moment, 5 = blade curvature twisting moment, 6 = blade sweep moment.","category":"page"},{"location":"OWENS_Dev_Guide/","page":"Developer Guide","title":"Developer Guide","text":"The Mesh matches the global frame of reference of x, y, and z. Element length is the length along the element.","category":"page"},{"location":"OWENS_Dev_Guide/","page":"Developer Guide","title":"Developer Guide","text":"The mesh itself is comprised only of components. For example, a tower, two blades, and four struts. The element number is sequential. There are overlapping points where each component connects. The mesh has a connectivity vector, which has rows corresponding to each element, column 1 corresponds to the \\\"master\\\" node, and column 2 corresponds to the \\\"slave\\\" node. The element connection in the mesh is only intra-component. I.e. there is no connectivity between components - that is defined in the joint matrix, which has columns for: Joint Number, Joint Master Node, Joint Slave Node, Joint Type, Joint Mass, Not Used, PsiD, ThetaD. The D indicates angle in degrees. Joint types are: (0 = weld(fixed), 1=pinned, 2 = hinge joint with axis about slave node element's e2 axis, 3 = hinge joint axis about slave node element's e1 axis, 4 = hinge joint axis about slave node element's e3 axis). The Psi and Theta are of the slave node (or its closest neighbor of the same component due to the gaps in element mesh connectivity). The not used column is just filled with zeros. The \\\"flapwise\\\" normal vector of an element is forced to be away from the machine for consistency. During the meshing process, the component type need to be known in order to get this right: Mesh Type: 0-blade 1-tower 2-strut.","category":"page"},{"location":"OWENS_Dev_Guide/","page":"Developer Guide","title":"Developer Guide","text":"Note: Precomp calculates the sectional properties based on the input airfoil geometry.  A change in the leading edge offset will change the sectional properties.  The beam mesh in OWENS always aligns with the precomp defined axis.  This should align with reality, if for example, you define the leading edge offset as the quarter chord (so the beam forces align with the aero definition), then applied forces on the beam will bend with expected coupling, just like an airfoil with forcing that does not correspond to the sectional shear center.  There are terms for \"a\" in the structural solver, which which are for the internal flutter calculation.  These terms DO NOT offset the sectional property calculation.","category":"page"},{"location":"OWENS_Dev_Guide/#Marine-Considerations","page":"Developer Guide","title":"Marine Considerations","text":"","category":"section"},{"location":"OWENS_Dev_Guide/","page":"Developer Guide","title":"Developer Guide","text":"When we turn on AddedMassCoeffCa>0.0, this causes a few changes.  The added mass is included in the GXBeam 6x6 inertia terms (2,2 and 3,3) since a force coupling is unstable.  This changes the more smooth gravitational and centrifugal loads, so they are offloaded to the aero model, and are handled in the buoyancy and centrifugal force respectively.  Note, that for the GX implementation, this is required, but for the Timoshenko implementation, added mass is not coupled to the internal centrifugal force, so one could use TNB or ROM with added mass, turn gravity on, turn it off for the aero, and turn the centrifugal forcing off for aero as well.  That's a lot to change, so it is recommended to keep with the current implementation until development occurs otherwise. The example cases and/or tests contain verification cases of the added mass and buoyancy implementations.","category":"page"},{"location":"OWENS_Dev_Guide/#Composites","page":"Developer Guide","title":"Composites","text":"","category":"section"},{"location":"OWENS_Dev_Guide/#Hydrodynamics","page":"Developer Guide","title":"Hydrodynamics","text":"","category":"section"},{"location":"OWENS_Dev_Guide/","page":"Developer Guide","title":"Developer Guide","text":"Hydrodynamics are applied into OWENS using the HydroDyn module native to OpenFAST, but applied here through a standalone library linked to OWENS. The physics contained in the HydroDyn standalone library is virtually unchanged from its native application in OpenFAST. HydroDyn user documentation can be found here.","category":"page"},{"location":"OWENS_Dev_Guide/#Platform-Structure","page":"Developer Guide","title":"Platform Structure","text":"","category":"section"},{"location":"OWENS_Dev_Guide/","page":"Developer Guide","title":"Developer Guide","text":"To enable capturing the hydrodynamics in OWENS for floating turbines, a second mesh is created to represent the platform. OWENS assumes the platform is a rigid body, so the mesh is composed of a single element with effectively infinite stiffness. The two nodes forming this element are:","category":"page"},{"location":"OWENS_Dev_Guide/","page":"Developer Guide","title":"Developer Guide","text":"The platform reference point (i.e., the platform at the still water level along the vertical centerline of its center of gravity) is the bottom node\nThe tower base point is the top node","category":"page"},{"location":"OWENS_Dev_Guide/","page":"Developer Guide","title":"Developer Guide","text":"The structures composing the platform mesh itself are the same as the OWENSFEA structures documented above, though most of the definitions to define the mesh can be set to zero or are very simple. There are two main exceptions:","category":"page"},{"location":"OWENS_Dev_Guide/","page":"Developer Guide","title":"Developer Guide","text":"The platform center of gravity must be defined, since neither node is at this location. This is defined in the zcm parameter in the SectionPropsArray for the platform mesh.\nThe 6x6 rigid body mass matrix is defined as a concentrated input at the platform reference point node","category":"page"},{"location":"OWENS_Dev_Guide/","page":"Developer Guide","title":"Developer Guide","text":"A full example of these definitions can be found in the floating platform example notebook (TODO).","category":"page"},{"location":"OWENS_Dev_Guide/#Solve-Procedure","page":"Developer Guide","title":"Solve Procedure","text":"","category":"section"},{"location":"OWENS_Dev_Guide/","page":"Developer Guide","title":"Developer Guide","text":"When applying hydrodynamics, OWENS adds additional Gauss-Seidel loops to solve for the structural motions of both the platform mesh and the \"topside\" mesh (i.e. everything above the platform) in a way that generates global convergence. This process is:","category":"page"},{"location":"OWENS_Dev_Guide/","page":"Developer Guide","title":"Developer Guide","text":"Solve via a Gauss-Seidel loop for the topside mesh using platform motions from the previous time step","category":"page"},{"location":"OWENS_Dev_Guide/","page":"Developer Guide","title":"Developer Guide","text":"Setting platform motions to zero is how OWENS runs for land-based turbines","category":"page"},{"location":"OWENS_Dev_Guide/","page":"Developer Guide","title":"Developer Guide","text":"Solve via an outer Gauss-Seidel loop and an inner Newton-Raphson loop for the platform mesh, using updated external hydrodynamic loads from HydroDyn and tower base loads from step 1","category":"page"},{"location":"OWENS_Dev_Guide/","page":"Developer Guide","title":"Developer Guide","text":"The Newton-Raphson loop is contained in Unsteady.OWENS_HD_Coupled_Solve, and is necessary to properly account for added mass impacting both HydroDyn and OWENS in a tightly coupled manner.","category":"page"},{"location":"OWENS_Dev_Guide/","page":"Developer Guide","title":"Developer Guide","text":"This solve process is complex, but is documented in detail in Section 2.4.1 of Devin et al. (2022) here.   This is a very similar procedure used to coupled HydroDyn to the ElastoDyn module in OpenFAST.","category":"page"},{"location":"OWENS_Dev_Guide/","page":"Developer Guide","title":"Developer Guide","text":"Solve via a Gauss-Seidel loop for the topside mesh using platform motions from the current time step, i.e. the motions calculated in step 2.","category":"page"},{"location":"OWENS_Dev_Guide/","page":"Developer Guide","title":"Developer Guide","text":"This flow chart visualizes this solve procedure, and which step corresponds to which modules connecting to the core OWENS glue code: (Image: Hydrodynamics Solve Procedure Flowchart)","category":"page"},{"location":"OWENS_Dev_Guide/#Reference-Frame-Conversions","page":"Developer Guide","title":"Reference Frame Conversions","text":"","category":"section"},{"location":"OWENS_Dev_Guide/","page":"Developer Guide","title":"Developer Guide","text":"Since HydroDyn operates in the global reference frame, the hydrodynamics capabilities in OWENS deviate from the general convention in OWENS of operating in the hub reference frame. As a result, operations manipulating the platform mesh (e.g. running OWENSFEA.structuralDynamicsTransient) are also applied in the global reference frame. Functionally, this means that the rbData vector input is set to zero when using the platform mesh in OWENSFEA.structuralDynamicsTransient. Care must be taken for I/O procedures between the platform and topside meshes! The Unsteady_utilities.frame_convert function is intended to make this process simpler.","category":"page"},{"location":"OWENS_Dev_Guide/#Mooring","page":"Developer Guide","title":"Mooring","text":"","category":"section"},{"location":"OWENS_Dev_Guide/","page":"Developer Guide","title":"Developer Guide","text":"Mooring dynamics for floating platforms in OWENS are calculated using a standalone library linking to MoorDyn, another module native to OpenFAST. The mooring loads calculated in MoorDyn are applied as an external load to the same platform mesh as the hydrodynamics, as described above. Since the mooring dynamics do not need to account for added mass, the coupling between MoorDyn and OWENS is much simpler, and the mooring dynamics are applied in the Gauss-Seidel solve procedure without being modified by the additional Newton-Raphson solve in Unsteady.OWENS_HD_Coupled_Solve. Note that MoorDyn operates in the global reference frame, so be careful with reference frame conversions for MoorDyn I/O.","category":"page"},{"location":"OWENS_Dev_Guide/#Coupling-Methods","page":"Developer Guide","title":"Coupling Methods","text":"","category":"section"},{"location":"OWENS_Dev_Guide/#Inflow-Aero","page":"Developer Guide","title":"Inflow - Aero","text":"","category":"section"},{"location":"OWENS_Dev_Guide/","page":"Developer Guide","title":"Developer Guide","text":"Direct: Aero module supplies an x-y-z and time coordinate, inflow returns x-y-z velocity. This is repeated for all blade discrete points as per the aero formulation.","category":"page"},{"location":"OWENS_Dev_Guide/#Aero-Turbine-Structure","page":"Developer Guide","title":"Aero - Turbine Structure","text":"","category":"section"},{"location":"OWENS_Dev_Guide/","page":"Developer Guide","title":"Developer Guide","text":"Loose Iteration: Structure provides blade local radius, twist, sweep, and 6 DOF velocities, aero returns forces, moments. This is iterated on until convergence. It is preferred to change this to a N-dimensional root solver and pass gradients to the root solver to increase performance.","category":"page"},{"location":"OWENS_Dev_Guide/","page":"Developer Guide","title":"Developer Guide","text":"Specifically, from the meshing process, the starting and ending node numbers for the blades are known and the aerodynamic loads mapped to the elements between those nodes.","category":"page"},{"location":"OWENS_Dev_Guide/#Turbine-Structure-Platform-Structure","page":"Developer Guide","title":"Turbine Structure - Platform Structure","text":"","category":"section"},{"location":"OWENS_Dev_Guide/","page":"Developer Guide","title":"Developer Guide","text":"Same as Aero-Structure","category":"page"},{"location":"OWENS_Dev_Guide/#Hydro-Platform-Structure-Mooring","page":"Developer Guide","title":"Hydro - Platform Structure - Mooring","text":"","category":"section"},{"location":"OWENS_Dev_Guide/","page":"Developer Guide","title":"Developer Guide","text":"Same as Aero-Structure","category":"page"},{"location":"OWENS_Dev_Guide/#Structures-Composites","page":"Developer Guide","title":"Structures - Composites","text":"","category":"section"},{"location":"OWENS_Dev_Guide/","page":"Developer Guide","title":"Developer Guide","text":"Initialization is Direct: Structures provides macro geometry, Composites provide sectional properties. Composite Failure is Direct: Structure provides strains, composites provides failure. Buckling is also calculated.","category":"page"},{"location":"OWENS_Dev_Guide/#Controllers-Control-Elements","page":"Developer Guide","title":"Controllers - Control Elements","text":"","category":"section"},{"location":"OWENS_Dev_Guide/","page":"Developer Guide","title":"Developer Guide","text":"Direct: Controllers provide reactionary inputs to control inputs in real time based on dynamics.","category":"page"},{"location":"#OWENS-(Onshore/Offshore-Wind/Water-ENergy-Simulator)","page":"Home","title":"OWENS (Onshore/Offshore Wind/Water ENergy Simulator)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: ) (Image: ) (Image: codecov.io)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Documentation: sandialabs.github.io/OWENS.jl/\nCode: github.com/sandialabs/OWENS.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package is for experienced researchers and analyists with both software and engineering experience who need generalized flexibility and performance that is 100% open source and is compatible with gradient based optimization with automatic gradients in process.  If you want a windows compatible GUI, please use QBlade.  ","category":"page"},{"location":"","page":"Home","title":"Home","text":"OWENS is an ontology, or way of coupling modular aerodynamic, structural, hydrodynamic, and controls packages.  It was originally based on the structural dynamics solver by Brian Owens (see dissertation: http://hdl.handle.net/1969.1/151813). However, it has been rewritten into the Julia programming language, modularized, and many of the issues related to aerodynamic coupling and floating dynamics solved, with extensive expansion into other areas and features to provide a seamless and automated process that takes in high level design details and does all of the preprocessing, running, and post processing that is normally done under different roofs or by different manual processes.  This was done with the intent of enabling fast, parametric design.  We have many of the modules propogating automatic gradients, however this is still a future challenge to solve well. ","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For Julia 1.11+.  For new Julia users, developer install, and those wishing to use Julia 1.10 and below, see the In-Depth Installation page.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(PackageSpec(url=\"https://github.com/sandialabs/OWENS.jl.git\"))","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that the following demo was recorded using the julia 1.10 installation method.","category":"page"},{"location":"","page":"Home","title":"Home","text":"<div style=\"position:relative;padding-top:50%;\">\n    <iframe style=\"position:absolute;left:0;top:0;height:80%;width:71.0%;\"\n        src=\"https://www.youtube.com/embed/FTx9Jui_0CA?hd=1\"\n        title=\"YouTube video player\" frameborder=\"0\"\n        allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\"\n        allowfullscreen></iframe>\n</div>","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here are several examples of OWENS use cases, current and past, including the Sandia 34m research turbine.","category":"page"},{"location":"","page":"Home","title":"Home","text":"<p align=\"center\">\n    <img src=\"./assets/SNL34m.png\" alt=\"img\" style=\"width:40%\">\n</p>","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then here is an example of a helical design.  Note that arbitrary numbers of struts can be specified in the automatic meshing functions.  You can also write your own generalized mesh using the internal building blocks, but it is not thouroughly documented.","category":"page"},{"location":"","page":"Home","title":"Home","text":"<p align=\"center\">\n    <img src=\"./assets/helical.png\" alt=\"img\" style=\"width:40%\">\n</p>","category":"page"},{"location":"","page":"Home","title":"Home","text":"The generalized meshing was modified to include HAWT concepts, like this bi-wing concept.  OWENS is capable of axial flow turbines/HAWTs, but it is not a mature feature, and no where near as developed as OpenFAST (i.e. for regular HAWTs it is recommended to use that software).","category":"page"},{"location":"","page":"Home","title":"Home","text":"<p align=\"center\">\n    <img src=\"./assets/biwing.png\" alt=\"img\" style=\"width:40%\">\n</p>","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then, floating turbines are a possibility, though this feature adds another dimension to the nonlinear time stepping convergance and in turn a fair amount of time.  Future work is to make this general interface and functionality an easy to use feature (right now it needs a high level of experience to use).","category":"page"},{"location":"","page":"Home","title":"Home","text":"<p align=\"center\">\n    <img src=\"./assets/arcus.png\" alt=\"img\" style=\"width:40%\">\n</p>","category":"page"},{"location":"#OWENS-under-the-hood","page":"Home","title":"OWENS under the hood","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The OWENS.jl package contains functions and interfaces related to the ontology (how everything comes together, forms a wind turbine, and operates like a wind turbine), with preprocessing and postprocessing helper functions. These include automated meshing functions, sectional property mapping, two-way loads mapping, generalized torque and direct mesh controls, algorithms for two-way coupling and time stepping, fatigue and design equivalent load calculation, and all of the ontology and coupling to the other packages used.","category":"page"},{"location":"","page":"Home","title":"Home","text":"OWENSPrecomp.jl is a translation of Precomp and calculates the sectional properties","category":"page"},{"location":"","page":"Home","title":"Home","text":"Composites.jl provides classical laminate theory definitions used for both pre and post processing","category":"page"},{"location":"","page":"Home","title":"Home","text":"OWENSFEA.jl is one of the structural models including a Timoshenko beam solver in the linear and nonlinear steady, modal, time domain, and reduced order modal domains.","category":"page"},{"location":"","page":"Home","title":"Home","text":"GXBeam.jl has also been integrated for geometrically exact beam solutions of the same above","category":"page"},{"location":"","page":"Home","title":"Home","text":"The aerodynamics are provided by the OWENSAero.jl module, or optionally OpenFAST OLAF via OWENSOpenFASTWrappers.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"Floating dynamics are provided by OWENSOpenFASTWrappers.jl and the HydroDyn and MoorDyn libraries","category":"page"},{"location":"","page":"Home","title":"Home","text":"Turbulent inflow is provided by OWENSOpenFASTWrappers.jl and the inflowwind and turbsim libraries","category":"page"},{"location":"","page":"Home","title":"Home","text":"Rainflow counting was provided by Rainflow.jl, however, this package became orphained and was pulled into the OWENS code base.","category":"page"},{"location":"","page":"Home","title":"Home","text":"<p align=\"center\">\n    <img src=\"./assets/OWENS_Processes.png\" alt=\"img\" style=\"width:40%\">\n</p>","category":"page"},{"location":"#Documentation","page":"Home","title":"Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"-\tAll of the functions have docstrings describing the i/o and function purpose, which can be accessed the docs site or by:     * import module     * ? module.function() \t\t\t\t -\tA note about julia debuggers – if you don’t want it to step through everything, you need to tell it what packages to compile vs while packages to step through. This will make the debugger comparable (if not faster) than Matlab in speed. In VSCode, this can be done in the debug pane, or by optionally loading the provided VS code profile in the OWENS.jl/docs folder.  This VS code profile will also set up the julia environment and other useful packages and key bindings, and can be modified as desired.","category":"page"},{"location":"#Software-License","page":"Home","title":"Software License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Copyright 2021 National Technology & Engineering Solutions of Sandia, LLC (NTESS). Under the terms of Contract DE-NA0003525 with NTESS, there is a non-exclusive license for use of this work by or on behalf of the U.S. Government. Export of this data may require a license from the United States Government.","category":"page"},{"location":"","page":"Home","title":"Home","text":"See Copyright.txt file for more information","category":"page"}]
}
